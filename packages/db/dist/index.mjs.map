{"version":3,"sources":["../../../node_modules/src/entity.ts","../../../node_modules/src/logger.ts","../../../node_modules/src/query-promise.ts","../../../node_modules/src/table.ts","../../../node_modules/src/tracing-utils.ts","../../../node_modules/drizzle-orm/version.js","../../../node_modules/src/tracing.ts","../../../node_modules/src/column.ts","../../../node_modules/src/subquery.ts","../../../node_modules/src/view-common.ts","../../../node_modules/src/sql/sql.ts","../../../node_modules/src/utils.ts","../../../node_modules/src/pg-core/query-builders/delete.ts","../../../node_modules/src/pg-core/query-builders/insert.ts","../../../node_modules/src/alias.ts","../../../node_modules/src/errors.ts","../../../node_modules/src/column-builder.ts","../../../node_modules/src/pg-core/table.ts","../../../node_modules/src/pg-core/foreign-keys.ts","../../../node_modules/src/pg-core/unique-constraint.ts","../../../node_modules/src/pg-core/utils/array.ts","../../../node_modules/src/pg-core/columns/common.ts","../../../node_modules/src/pg-core/columns/boolean.ts","../../../node_modules/src/pg-core/columns/date.common.ts","../../../node_modules/src/pg-core/columns/date.ts","../../../node_modules/src/pg-core/columns/enum.ts","../../../node_modules/src/pg-core/columns/integer.ts","../../../node_modules/src/pg-core/columns/json.ts","../../../node_modules/src/pg-core/columns/jsonb.ts","../../../node_modules/src/pg-core/columns/numeric.ts","../../../node_modules/src/pg-core/columns/serial.ts","../../../node_modules/src/pg-core/columns/text.ts","../../../node_modules/src/pg-core/columns/time.ts","../../../node_modules/src/pg-core/columns/timestamp.ts","../../../node_modules/src/pg-core/columns/uuid.ts","../../../node_modules/src/pg-core/columns/varchar.ts","../../../node_modules/src/pg-core/primary-keys.ts","../../../node_modules/src/sql/expressions/conditions.ts","../../../node_modules/src/sql/expressions/select.ts","../../../node_modules/src/relations.ts","../../../node_modules/src/pg-core/view-base.ts","../../../node_modules/src/pg-core/dialect.ts","../../../node_modules/src/query-builders/query-builder.ts","../../../node_modules/src/selection-proxy.ts","../../../node_modules/src/pg-core/query-builders/select.ts","../../../node_modules/src/pg-core/query-builders/query-builder.ts","../../../node_modules/src/pg-core/query-builders/refresh-materialized-view.ts","../../../node_modules/src/pg-core/query-builders/update.ts","../../../node_modules/src/pg-core/query-builders/query.ts","../../../node_modules/src/pg-core/query-builders/raw.ts","../../../node_modules/src/pg-core/db.ts","../../../node_modules/src/pg-core/session.ts","../../../node_modules/src/postgres-js/session.ts","../../../node_modules/src/postgres-js/driver.ts","../src/index.ts","../src/schema.ts"],"sourcesContent":["export const entityKind = Symbol.for('drizzle:entityKind');\nexport const hasOwnEntityKind = Symbol.for('drizzle:hasOwnEntityKind');\n\nexport interface DrizzleEntity {\n\t[entityKind]: string;\n}\n\nexport type DrizzleEntityClass<T> =\n\t& ((abstract new(...args: any[]) => T) | (new(...args: any[]) => T))\n\t& DrizzleEntity;\n\nexport function is<T extends DrizzleEntityClass<any>>(value: any, type: T): value is InstanceType<T> {\n\tif (!value || typeof value !== 'object') {\n\t\treturn false;\n\t}\n\n\tif (value instanceof type) { // eslint-disable-line no-instanceof/no-instanceof\n\t\treturn true;\n\t}\n\n\tif (!Object.prototype.hasOwnProperty.call(type, entityKind)) {\n\t\tthrow new Error(\n\t\t\t`Class \"${\n\t\t\t\ttype.name ?? '<unknown>'\n\t\t\t}\" doesn't look like a Drizzle entity. If this is incorrect and the class is provided by Drizzle, please report this as a bug.`,\n\t\t);\n\t}\n\n\tlet cls = value.constructor;\n\tif (cls) {\n\t\t// Traverse the prototype chain to find the entityKind\n\t\twhile (cls) {\n\t\t\tif (entityKind in cls && cls[entityKind] === type[entityKind]) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tcls = Object.getPrototypeOf(cls);\n\t\t}\n\t}\n\n\treturn false;\n}\n","import { entityKind } from '~/entity.ts';\n\nexport interface Logger {\n\tlogQuery(query: string, params: unknown[]): void;\n}\n\nexport interface LogWriter {\n\twrite(message: string): void;\n}\n\nexport class ConsoleLogWriter implements LogWriter {\n\tstatic readonly [entityKind]: string = 'ConsoleLogWriter';\n\n\twrite(message: string) {\n\t\tconsole.log(message);\n\t}\n}\n\nexport class DefaultLogger implements Logger {\n\tstatic readonly [entityKind]: string = 'DefaultLogger';\n\n\treadonly writer: LogWriter;\n\n\tconstructor(config?: { writer: LogWriter }) {\n\t\tthis.writer = config?.writer ?? new ConsoleLogWriter();\n\t}\n\n\tlogQuery(query: string, params: unknown[]): void {\n\t\tconst stringifiedParams = params.map((p) => {\n\t\t\ttry {\n\t\t\t\treturn JSON.stringify(p);\n\t\t\t} catch {\n\t\t\t\treturn String(p);\n\t\t\t}\n\t\t});\n\t\tconst paramsStr = stringifiedParams.length ? ` -- params: [${stringifiedParams.join(', ')}]` : '';\n\t\tthis.writer.write(`Query: ${query}${paramsStr}`);\n\t}\n}\n\nexport class NoopLogger implements Logger {\n\tstatic readonly [entityKind]: string = 'NoopLogger';\n\n\tlogQuery(): void {\n\t\t// noop\n\t}\n}\n","import { entityKind } from '~/entity.ts';\n\nexport abstract class QueryPromise<T> implements Promise<T> {\n\tstatic readonly [entityKind]: string = 'QueryPromise';\n\n\t[Symbol.toStringTag] = 'QueryPromise';\n\n\tcatch<TResult = never>(\n\t\tonRejected?: ((reason: any) => TResult | PromiseLike<TResult>) | null | undefined,\n\t): Promise<T | TResult> {\n\t\treturn this.then(undefined, onRejected);\n\t}\n\n\tfinally(onFinally?: (() => void) | null | undefined): Promise<T> {\n\t\treturn this.then(\n\t\t\t(value) => {\n\t\t\t\tonFinally?.();\n\t\t\t\treturn value;\n\t\t\t},\n\t\t\t(reason) => {\n\t\t\t\tonFinally?.();\n\t\t\t\tthrow reason;\n\t\t\t},\n\t\t);\n\t}\n\n\tthen<TResult1 = T, TResult2 = never>(\n\t\tonFulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,\n\t\tonRejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null,\n\t): Promise<TResult1 | TResult2> {\n\t\treturn this.execute().then(onFulfilled, onRejected);\n\t}\n\n\tabstract execute(): Promise<T>;\n}\n","import type { Column, GetColumnData } from './column.ts';\nimport { entityKind } from './entity.ts';\nimport type { OptionalKeyOnly, RequiredKeyOnly } from './operations.ts';\nimport type { SQLWrapper } from './sql/sql.ts';\nimport type { Simplify, Update } from './utils.ts';\n\nexport interface TableConfig<TColumn extends Column = Column<any>> {\n\tname: string;\n\tschema: string | undefined;\n\tcolumns: Record<string, TColumn>;\n\tdialect: string;\n}\n\nexport type UpdateTableConfig<T extends TableConfig, TUpdate extends Partial<TableConfig>> = Required<\n\tUpdate<T, TUpdate>\n>;\n\n/** @internal */\nexport const TableName = Symbol.for('drizzle:Name');\n\n/** @internal */\nexport const Schema = Symbol.for('drizzle:Schema');\n\n/** @internal */\nexport const Columns = Symbol.for('drizzle:Columns');\n\n/** @internal */\nexport const OriginalName = Symbol.for('drizzle:OriginalName');\n\n/** @internal */\nexport const BaseName = Symbol.for('drizzle:BaseName');\n\n/** @internal */\nexport const IsAlias = Symbol.for('drizzle:IsAlias');\n\n/** @internal */\nexport const ExtraConfigBuilder = Symbol.for('drizzle:ExtraConfigBuilder');\n\nconst IsDrizzleTable = Symbol.for('drizzle:IsDrizzleTable');\n\nexport interface Table<\n\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\tT extends TableConfig = TableConfig,\n> extends SQLWrapper {\n\t// SQLWrapper runtime implementation is defined in 'sql/sql.ts'\n}\n\nexport class Table<T extends TableConfig = TableConfig> implements SQLWrapper {\n\tstatic readonly [entityKind]: string = 'Table';\n\n\tdeclare readonly _: {\n\t\treadonly brand: 'Table';\n\t\treadonly config: T;\n\t\treadonly name: T['name'];\n\t\treadonly schema: T['schema'];\n\t\treadonly columns: T['columns'];\n\t\treadonly inferSelect: InferSelectModel<Table<T>>;\n\t\treadonly inferInsert: InferInsertModel<Table<T>>;\n\t};\n\n\tdeclare readonly $inferSelect: InferSelectModel<Table<T>>;\n\tdeclare readonly $inferInsert: InferInsertModel<Table<T>>;\n\n\t/** @internal */\n\tstatic readonly Symbol = {\n\t\tName: TableName as typeof TableName,\n\t\tSchema: Schema as typeof Schema,\n\t\tOriginalName: OriginalName as typeof OriginalName,\n\t\tColumns: Columns as typeof Columns,\n\t\tBaseName: BaseName as typeof BaseName,\n\t\tIsAlias: IsAlias as typeof IsAlias,\n\t\tExtraConfigBuilder: ExtraConfigBuilder as typeof ExtraConfigBuilder,\n\t};\n\n\t/**\n\t * @internal\n\t * Can be changed if the table is aliased.\n\t */\n\t[TableName]: string;\n\n\t/**\n\t * @internal\n\t * Used to store the original name of the table, before any aliasing.\n\t */\n\t[OriginalName]: string;\n\n\t/** @internal */\n\t[Schema]: string | undefined;\n\n\t/** @internal */\n\t[Columns]!: T['columns'];\n\n\t/**\n\t *  @internal\n\t * Used to store the table name before the transformation via the `tableCreator` functions.\n\t */\n\t[BaseName]: string;\n\n\t/** @internal */\n\t[IsAlias] = false;\n\n\t/** @internal */\n\t[ExtraConfigBuilder]: ((self: any) => Record<string, unknown>) | undefined = undefined;\n\n\t[IsDrizzleTable] = true;\n\n\tconstructor(name: string, schema: string | undefined, baseName: string) {\n\t\tthis[TableName] = this[OriginalName] = name;\n\t\tthis[Schema] = schema;\n\t\tthis[BaseName] = baseName;\n\t}\n}\n\nexport function isTable(table: unknown): table is Table {\n\treturn typeof table === 'object' && table !== null && IsDrizzleTable in table;\n}\n\n/**\n * Any table with a specified boundary.\n *\n * @example\n\t```ts\n\t// Any table with a specific name\n\ttype AnyUsersTable = AnyTable<{ name: 'users' }>;\n\t```\n *\n * To describe any table with any config, simply use `Table` without any type arguments, like this:\n *\n\t```ts\n\tfunction needsTable(table: Table) {\n\t\t...\n\t}\n\t```\n */\nexport type AnyTable<TPartial extends Partial<TableConfig>> = Table<UpdateTableConfig<TableConfig, TPartial>>;\n\nexport function getTableName<T extends Table>(table: T): T['_']['name'] {\n\treturn table[TableName];\n}\n\nexport type MapColumnName<TName extends string, TColumn extends Column, TDBColumNames extends boolean> =\n\tTDBColumNames extends true ? TColumn['_']['name']\n\t\t: TName;\n\nexport type InferModelFromColumns<\n\tTColumns extends Record<string, Column>,\n\tTInferMode extends 'select' | 'insert' = 'select',\n\tTConfig extends { dbColumnNames: boolean } = { dbColumnNames: false },\n> = Simplify<\n\tTInferMode extends 'insert' ? \n\t\t\t& {\n\t\t\t\t[\n\t\t\t\t\tKey in keyof TColumns & string as RequiredKeyOnly<\n\t\t\t\t\t\tMapColumnName<Key, TColumns[Key], TConfig['dbColumnNames']>,\n\t\t\t\t\t\tTColumns[Key]\n\t\t\t\t\t>\n\t\t\t\t]: GetColumnData<TColumns[Key], 'query'>;\n\t\t\t}\n\t\t\t& {\n\t\t\t\t[\n\t\t\t\t\tKey in keyof TColumns & string as OptionalKeyOnly<\n\t\t\t\t\t\tMapColumnName<Key, TColumns[Key], TConfig['dbColumnNames']>,\n\t\t\t\t\t\tTColumns[Key]\n\t\t\t\t\t>\n\t\t\t\t]?: GetColumnData<TColumns[Key], 'query'>;\n\t\t\t}\n\t\t: {\n\t\t\t[\n\t\t\t\tKey in keyof TColumns & string as MapColumnName<\n\t\t\t\t\tKey,\n\t\t\t\t\tTColumns[Key],\n\t\t\t\t\tTConfig['dbColumnNames']\n\t\t\t\t>\n\t\t\t]: GetColumnData<TColumns[Key], 'query'>;\n\t\t}\n>;\n\n/** @deprecated Use one of the alternatives: {@link InferSelectModel} / {@link InferInsertModel}, or `table.$inferSelect` / `table.$inferInsert`\n */\nexport type InferModel<\n\tTTable extends Table,\n\tTInferMode extends 'select' | 'insert' = 'select',\n\tTConfig extends { dbColumnNames: boolean } = { dbColumnNames: false },\n> = InferModelFromColumns<TTable['_']['columns'], TInferMode, TConfig>;\n\nexport type InferSelectModel<\n\tTTable extends Table,\n\tTConfig extends { dbColumnNames: boolean } = { dbColumnNames: false },\n> = InferModelFromColumns<TTable['_']['columns'], 'select', TConfig>;\n\nexport type InferInsertModel<\n\tTTable extends Table,\n\tTConfig extends { dbColumnNames: boolean } = { dbColumnNames: false },\n> = InferModelFromColumns<TTable['_']['columns'], 'insert', TConfig>;\n","export function iife<T extends unknown[], U>(fn: (...args: T) => U, ...args: T): U {\n\treturn fn(...args);\n}","// package.json\nvar version = \"0.29.5\";\n\n// src/version.ts\nvar compatibilityVersion = 6;\nexport {\n  compatibilityVersion,\n  version as npmVersion\n};\n","import type { Span, Tracer } from '@opentelemetry/api';\nimport { iife } from '~/tracing-utils.ts';\nimport { npmVersion } from '~/version.ts';\n\nlet otel: typeof import('@opentelemetry/api') | undefined;\nlet rawTracer: Tracer | undefined;\n// try {\n// \totel = await import('@opentelemetry/api');\n// } catch (err: any) {\n// \tif (err.code !== 'MODULE_NOT_FOUND' && err.code !== 'ERR_MODULE_NOT_FOUND') {\n// \t\tthrow err;\n// \t}\n// }\n\ntype SpanName =\n\t| 'drizzle.operation'\n\t| 'drizzle.prepareQuery'\n\t| 'drizzle.buildSQL'\n\t| 'drizzle.execute'\n\t| 'drizzle.driver.execute'\n\t| 'drizzle.mapResponse';\n\n/** @internal */\nexport const tracer = {\n\tstartActiveSpan<F extends (span?: Span) => unknown>(name: SpanName, fn: F): ReturnType<F> {\n\t\tif (!otel) {\n\t\t\treturn fn() as ReturnType<F>;\n\t\t}\n\n\t\tif (!rawTracer) {\n\t\t\trawTracer = otel.trace.getTracer('drizzle-orm', npmVersion);\n\t\t}\n\n\t\treturn iife(\n\t\t\t(otel, rawTracer) =>\n\t\t\t\trawTracer.startActiveSpan(\n\t\t\t\t\tname,\n\t\t\t\t\t((span: Span) => {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\treturn fn(span);\n\t\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t\tspan.setStatus({\n\t\t\t\t\t\t\t\tcode: otel.SpanStatusCode.ERROR,\n\t\t\t\t\t\t\t\tmessage: e instanceof Error ? e.message : 'Unknown error', // eslint-disable-line no-instanceof/no-instanceof\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tthrow e;\n\t\t\t\t\t\t} finally {\n\t\t\t\t\t\t\tspan.end();\n\t\t\t\t\t\t}\n\t\t\t\t\t}) as F,\n\t\t\t\t),\n\t\t\totel,\n\t\t\trawTracer,\n\t\t);\n\t},\n};\n","import type { ColumnBuilderBaseConfig, ColumnBuilderRuntimeConfig, ColumnDataType } from './column-builder.ts';\nimport { entityKind } from './entity.ts';\nimport type { DriverValueMapper, SQL, SQLWrapper } from './sql/sql.ts';\nimport type { Table } from './table.ts';\nimport type { Update } from './utils.ts';\n\nexport interface ColumnBaseConfig<\n\tTDataType extends ColumnDataType,\n\tTColumnType extends string,\n> extends ColumnBuilderBaseConfig<TDataType, TColumnType> {\n\ttableName: string;\n\tnotNull: boolean;\n\thasDefault: boolean;\n}\n\nexport type ColumnTypeConfig<T extends ColumnBaseConfig<ColumnDataType, string>, TTypeConfig extends object> = T & {\n\tbrand: 'Column';\n\ttableName: T['tableName'];\n\tname: T['name'];\n\tdataType: T['dataType'];\n\tcolumnType: T['columnType'];\n\tdata: T['data'];\n\tdriverParam: T['driverParam'];\n\tnotNull: T['notNull'];\n\thasDefault: T['hasDefault'];\n\tenumValues: T['enumValues'];\n\tbaseColumn: T extends { baseColumn: infer U } ? U : unknown;\n} & TTypeConfig;\n\nexport type ColumnRuntimeConfig<TData, TRuntimeConfig extends object> = ColumnBuilderRuntimeConfig<\n\tTData,\n\tTRuntimeConfig\n>;\n\nexport interface Column<\n\tT extends ColumnBaseConfig<ColumnDataType, string> = ColumnBaseConfig<ColumnDataType, string>,\n\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\tTRuntimeConfig extends object = object,\n\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\tTTypeConfig extends object = object,\n> extends DriverValueMapper<T['data'], T['driverParam']>, SQLWrapper {\n\t// SQLWrapper runtime implementation is defined in 'sql/sql.ts'\n}\n/*\n\t`Column` only accepts a full `ColumnConfig` as its generic.\n\tTo infer parts of the config, use `AnyColumn` that accepts a partial config.\n\tSee `GetColumnData` for example usage of inferring.\n*/\nexport abstract class Column<\n\tT extends ColumnBaseConfig<ColumnDataType, string> = ColumnBaseConfig<ColumnDataType, string>,\n\tTRuntimeConfig extends object = object,\n\tTTypeConfig extends object = object,\n> implements DriverValueMapper<T['data'], T['driverParam']>, SQLWrapper {\n\tstatic readonly [entityKind]: string = 'Column';\n\n\tdeclare readonly _: ColumnTypeConfig<T, TTypeConfig>;\n\n\treadonly name: string;\n\treadonly primary: boolean;\n\treadonly notNull: boolean;\n\treadonly default: T['data'] | SQL | undefined;\n\treadonly defaultFn: (() => T['data'] | SQL) | undefined;\n\treadonly hasDefault: boolean;\n\treadonly isUnique: boolean;\n\treadonly uniqueName: string | undefined;\n\treadonly uniqueType: string | undefined;\n\treadonly dataType: T['dataType'];\n\treadonly columnType: T['columnType'];\n\treadonly enumValues: T['enumValues'] = undefined;\n\n\tprotected config: ColumnRuntimeConfig<T['data'], TRuntimeConfig>;\n\n\tconstructor(\n\t\treadonly table: Table,\n\t\tconfig: ColumnRuntimeConfig<T['data'], TRuntimeConfig>,\n\t) {\n\t\tthis.config = config;\n\t\tthis.name = config.name;\n\t\tthis.notNull = config.notNull;\n\t\tthis.default = config.default;\n\t\tthis.defaultFn = config.defaultFn;\n\t\tthis.hasDefault = config.hasDefault;\n\t\tthis.primary = config.primaryKey;\n\t\tthis.isUnique = config.isUnique;\n\t\tthis.uniqueName = config.uniqueName;\n\t\tthis.uniqueType = config.uniqueType;\n\t\tthis.dataType = config.dataType as T['dataType'];\n\t\tthis.columnType = config.columnType;\n\t}\n\n\tabstract getSQLType(): string;\n\n\tmapFromDriverValue(value: unknown): unknown {\n\t\treturn value;\n\t}\n\n\tmapToDriverValue(value: unknown): unknown {\n\t\treturn value;\n\t}\n}\n\nexport type UpdateColConfig<\n\tT extends ColumnBaseConfig<ColumnDataType, string>,\n\tTUpdate extends Partial<ColumnBaseConfig<ColumnDataType, string>>,\n> = Update<T, TUpdate>;\n\nexport type AnyColumn<TPartial extends Partial<ColumnBaseConfig<ColumnDataType, string>> = {}> = Column<\n\tRequired<Update<ColumnBaseConfig<ColumnDataType, string>, TPartial>>\n>;\n\nexport type GetColumnData<TColumn extends Column, TInferMode extends 'query' | 'raw' = 'query'> =\n\t// dprint-ignore\n\tTInferMode extends 'raw' // Raw mode\n\t\t? TColumn['_']['data'] // Just return the underlying type\n\t\t: TColumn['_']['notNull'] extends true // Query mode\n\t\t? TColumn['_']['data'] // Query mode, not null\n\t\t: TColumn['_']['data'] | null; // Query mode, nullable\n\nexport type InferColumnsDataTypes<TColumns extends Record<string, Column>> = {\n\t[Key in keyof TColumns]: GetColumnData<TColumns[Key], 'query'>;\n};\n","import { entityKind } from './entity.ts';\nimport type { SQL, SQLWrapper, ColumnsSelection } from './sql/sql.ts';\n\nexport const SubqueryConfig = Symbol.for('drizzle:SubqueryConfig');\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nexport interface Subquery<TAlias extends string = string, TSelectedFields = unknown> extends SQLWrapper {\n\t// SQLWrapper runtime implementation is defined in 'sql/sql.ts'\n}\nexport class Subquery<TAlias extends string = string, TSelectedFields = unknown> implements SQLWrapper {\n\tstatic readonly [entityKind]: string = 'Subquery';\n\n\tdeclare _: {\n\t\tbrand: 'Subquery';\n\t\tselectedFields: TSelectedFields;\n\t\talias: TAlias;\n\t};\n\n\t/** @internal */\n\t[SubqueryConfig]: {\n\t\tsql: SQL;\n\t\tselection: ColumnsSelection;\n\t\talias: string;\n\t\tisWith: boolean;\n\t};\n\n\tconstructor(sql: SQL, selection: Record<string, unknown>, alias: string, isWith = false) {\n\t\tthis[SubqueryConfig] = {\n\t\t\tsql,\n\t\t\tselection,\n\t\t\talias,\n\t\t\tisWith,\n\t\t};\n\t}\n\n\t// getSQL(): SQL<unknown> {\n\t// \treturn new SQL([this]);\n\t// }\n}\n\nexport class WithSubquery<TAlias extends string = string, TSelection = unknown> extends Subquery<TAlias, TSelection> {\n\tstatic readonly [entityKind]: string = 'WithSubquery';\n}","export const ViewBaseConfig = Symbol.for('drizzle:ViewBaseConfig');\n","import { entityKind, is } from '~/entity.ts';\nimport type { SelectedFields } from '~/operations.ts';\nimport { Subquery, SubqueryConfig } from '~/subquery.ts';\nimport { tracer } from '~/tracing.ts';\nimport { ViewBaseConfig } from '~/view-common.ts';\nimport type { AnyColumn } from '../column.ts';\nimport { Column } from '../column.ts';\nimport { Table } from '../table.ts';\n\n/**\n * This class is used to indicate a primitive param value that is used in `sql` tag.\n * It is only used on type level and is never instantiated at runtime.\n * If you see a value of this type in the code, its runtime value is actually the primitive param value.\n */\nexport class FakePrimitiveParam {\n\tstatic readonly [entityKind]: string = 'FakePrimitiveParam';\n}\n\nexport type Chunk =\n\t| string\n\t| Table\n\t| View\n\t| AnyColumn\n\t| Name\n\t| Param\n\t| Placeholder\n\t| SQL;\n\nexport interface BuildQueryConfig {\n\tescapeName(name: string): string;\n\tescapeParam(num: number, value: unknown): string;\n\tescapeString(str: string): string;\n\tprepareTyping?: (encoder: DriverValueEncoder<unknown, unknown>) => QueryTypingsValue;\n\tparamStartIndex?: { value: number };\n\tinlineParams?: boolean;\n}\n\nexport type QueryTypingsValue = 'json' | 'decimal' | 'time' | 'timestamp' | 'uuid' | 'date' | 'none';\n\nexport interface Query {\n\tsql: string;\n\tparams: unknown[];\n}\n\nexport interface QueryWithTypings extends Query {\n\ttypings?: QueryTypingsValue[];\n}\n\n/**\n * Any value that implements the `getSQL` method. The implementations include:\n * - `Table`\n * - `Column`\n * - `View`\n * - `Subquery`\n * - `SQL`\n * - `SQL.Aliased`\n * - `Placeholder`\n * - `Param`\n */\nexport interface SQLWrapper {\n\tgetSQL(): SQL;\n}\n\nexport function isSQLWrapper(value: unknown): value is SQLWrapper {\n\treturn typeof value === 'object' && value !== null && 'getSQL' in value\n\t\t&& typeof (value as any).getSQL === 'function';\n}\n\nfunction mergeQueries(queries: QueryWithTypings[]): QueryWithTypings {\n\tconst result: QueryWithTypings = { sql: '', params: [] };\n\tfor (const query of queries) {\n\t\tresult.sql += query.sql;\n\t\tresult.params.push(...query.params);\n\t\tif (query.typings?.length) {\n\t\t\tif (!result.typings) {\n\t\t\t\tresult.typings = [];\n\t\t\t}\n\t\t\tresult.typings.push(...query.typings);\n\t\t}\n\t}\n\treturn result;\n}\n\nexport class StringChunk implements SQLWrapper {\n\tstatic readonly [entityKind]: string = 'StringChunk';\n\n\treadonly value: string[];\n\n\tconstructor(value: string | string[]) {\n\t\tthis.value = Array.isArray(value) ? value : [value];\n\t}\n\n\tgetSQL(): SQL<unknown> {\n\t\treturn new SQL([this]);\n\t}\n}\n\nexport class SQL<T = unknown> implements SQLWrapper {\n\tstatic readonly [entityKind]: string = 'SQL';\n\n\tdeclare _: {\n\t\tbrand: 'SQL';\n\t\ttype: T;\n\t};\n\n\t/** @internal */\n\tdecoder: DriverValueDecoder<T, any> = noopDecoder;\n\tprivate shouldInlineParams = false;\n\n\tconstructor(readonly queryChunks: SQLChunk[]) {}\n\n\tappend(query: SQL): this {\n\t\tthis.queryChunks.push(...query.queryChunks);\n\t\treturn this;\n\t}\n\n\ttoQuery(config: BuildQueryConfig): QueryWithTypings {\n\t\treturn tracer.startActiveSpan('drizzle.buildSQL', (span) => {\n\t\t\tconst query = this.buildQueryFromSourceParams(this.queryChunks, config);\n\t\t\tspan?.setAttributes({\n\t\t\t\t'drizzle.query.text': query.sql,\n\t\t\t\t'drizzle.query.params': JSON.stringify(query.params),\n\t\t\t});\n\t\t\treturn query;\n\t\t});\n\t}\n\n\tbuildQueryFromSourceParams(chunks: SQLChunk[], _config: BuildQueryConfig): Query {\n\t\tconst config = Object.assign({}, _config, {\n\t\t\tinlineParams: _config.inlineParams || this.shouldInlineParams,\n\t\t\tparamStartIndex: _config.paramStartIndex || { value: 0 },\n\t\t});\n\n\t\tconst {\n\t\t\tescapeName,\n\t\t\tescapeParam,\n\t\t\tprepareTyping,\n\t\t\tinlineParams,\n\t\t\tparamStartIndex,\n\t\t} = config;\n\n\t\treturn mergeQueries(chunks.map((chunk): QueryWithTypings => {\n\t\t\tif (is(chunk, StringChunk)) {\n\t\t\t\treturn { sql: chunk.value.join(''), params: [] };\n\t\t\t}\n\n\t\t\tif (is(chunk, Name)) {\n\t\t\t\treturn { sql: escapeName(chunk.value), params: [] };\n\t\t\t}\n\n\t\t\tif (chunk === undefined) {\n\t\t\t\treturn { sql: '', params: [] };\n\t\t\t}\n\n\t\t\tif (Array.isArray(chunk)) {\n\t\t\t\tconst result: SQLChunk[] = [new StringChunk('(')];\n\t\t\t\tfor (const [i, p] of chunk.entries()) {\n\t\t\t\t\tresult.push(p);\n\t\t\t\t\tif (i < chunk.length - 1) {\n\t\t\t\t\t\tresult.push(new StringChunk(', '));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tresult.push(new StringChunk(')'));\n\t\t\t\treturn this.buildQueryFromSourceParams(result, config);\n\t\t\t}\n\n\t\t\tif (is(chunk, SQL)) {\n\t\t\t\treturn this.buildQueryFromSourceParams(chunk.queryChunks, {\n\t\t\t\t\t...config,\n\t\t\t\t\tinlineParams: inlineParams || chunk.shouldInlineParams,\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif (is(chunk, Table)) {\n\t\t\t\tconst schemaName = chunk[Table.Symbol.Schema];\n\t\t\t\tconst tableName = chunk[Table.Symbol.Name];\n\t\t\t\treturn {\n\t\t\t\t\tsql: schemaName === undefined\n\t\t\t\t\t\t? escapeName(tableName)\n\t\t\t\t\t\t: escapeName(schemaName) + '.' + escapeName(tableName),\n\t\t\t\t\tparams: [],\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tif (is(chunk, Column)) {\n\t\t\t\treturn { sql: escapeName(chunk.table[Table.Symbol.Name]) + '.' + escapeName(chunk.name), params: [] };\n\t\t\t}\n\n\t\t\tif (is(chunk, View)) {\n\t\t\t\tconst schemaName = chunk[ViewBaseConfig].schema;\n\t\t\t\tconst viewName = chunk[ViewBaseConfig].name;\n\t\t\t\treturn {\n\t\t\t\t\tsql: schemaName === undefined\n\t\t\t\t\t\t? escapeName(viewName)\n\t\t\t\t\t\t: escapeName(schemaName) + '.' + escapeName(viewName),\n\t\t\t\t\tparams: [],\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tif (is(chunk, Param)) {\n\t\t\t\tconst mappedValue = (chunk.value === null) ? null : chunk.encoder.mapToDriverValue(chunk.value);\n\n\t\t\t\tif (is(mappedValue, SQL)) {\n\t\t\t\t\treturn this.buildQueryFromSourceParams([mappedValue], config);\n\t\t\t\t}\n\n\t\t\t\tif (inlineParams) {\n\t\t\t\t\treturn { sql: this.mapInlineParam(mappedValue, config), params: [] };\n\t\t\t\t}\n\n\t\t\t\tlet typings: QueryTypingsValue[] | undefined;\n\t\t\t\tif (prepareTyping !== undefined) {\n\t\t\t\t\ttypings = [prepareTyping(chunk.encoder)];\n\t\t\t\t}\n\n\t\t\t\treturn { sql: escapeParam(paramStartIndex.value++, mappedValue), params: [mappedValue], typings };\n\t\t\t}\n\n\t\t\tif (is(chunk, Placeholder)) {\n\t\t\t\treturn { sql: escapeParam(paramStartIndex.value++, chunk), params: [chunk] };\n\t\t\t}\n\n\t\t\tif (is(chunk, SQL.Aliased) && chunk.fieldAlias !== undefined) {\n\t\t\t\treturn { sql: escapeName(chunk.fieldAlias), params: [] };\n\t\t\t}\n\n\t\t\tif (is(chunk, Subquery)) {\n\t\t\t\tif (chunk[SubqueryConfig].isWith) {\n\t\t\t\t\treturn { sql: escapeName(chunk[SubqueryConfig].alias), params: [] };\n\t\t\t\t}\n\t\t\t\treturn this.buildQueryFromSourceParams([\n\t\t\t\t\tnew StringChunk('('),\n\t\t\t\t\tchunk[SubqueryConfig].sql,\n\t\t\t\t\tnew StringChunk(') '),\n\t\t\t\t\tnew Name(chunk[SubqueryConfig].alias),\n\t\t\t\t], config);\n\t\t\t}\n\n\t\t\tif (isSQLWrapper(chunk)) {\n\t\t\t\treturn this.buildQueryFromSourceParams([\n\t\t\t\t\tnew StringChunk('('),\n\t\t\t\t\tchunk.getSQL(),\n\t\t\t\t\tnew StringChunk(')'),\n\t\t\t\t], config);\n\t\t\t}\n\n\t\t\tif (inlineParams) {\n\t\t\t\treturn { sql: this.mapInlineParam(chunk, config), params: [] };\n\t\t\t}\n\n\t\t\treturn { sql: escapeParam(paramStartIndex.value++, chunk), params: [chunk] };\n\t\t}));\n\t}\n\n\tprivate mapInlineParam(\n\t\tchunk: unknown,\n\t\t{ escapeString }: BuildQueryConfig,\n\t): string {\n\t\tif (chunk === null) {\n\t\t\treturn 'null';\n\t\t}\n\t\tif (typeof chunk === 'number' || typeof chunk === 'boolean') {\n\t\t\treturn chunk.toString();\n\t\t}\n\t\tif (typeof chunk === 'string') {\n\t\t\treturn escapeString(chunk);\n\t\t}\n\t\tif (typeof chunk === 'object') {\n\t\t\tconst mappedValueAsString = chunk.toString();\n\t\t\tif (mappedValueAsString === '[object Object]') {\n\t\t\t\treturn escapeString(JSON.stringify(chunk));\n\t\t\t}\n\t\t\treturn escapeString(mappedValueAsString);\n\t\t}\n\t\tthrow new Error('Unexpected param value: ' + chunk);\n\t}\n\n\tgetSQL(): SQL {\n\t\treturn this;\n\t}\n\n\tas(alias: string): SQL.Aliased<T>;\n\t/**\n\t * @deprecated\n\t * Use ``sql<DataType>`query`.as(alias)`` instead.\n\t */\n\tas<TData>(): SQL<TData>;\n\t/**\n\t * @deprecated\n\t * Use ``sql<DataType>`query`.as(alias)`` instead.\n\t */\n\tas<TData>(alias: string): SQL.Aliased<TData>;\n\tas(alias?: string): SQL<T> | SQL.Aliased<T> {\n\t\t// TODO: remove with deprecated overloads\n\t\tif (alias === undefined) {\n\t\t\treturn this;\n\t\t}\n\n\t\treturn new SQL.Aliased(this, alias);\n\t}\n\n\tmapWith<\n\t\tTDecoder extends\n\t\t\t| DriverValueDecoder<any, any>\n\t\t\t| DriverValueDecoder<any, any>['mapFromDriverValue'],\n\t>(decoder: TDecoder): SQL<GetDecoderResult<TDecoder>> {\n\t\tthis.decoder = typeof decoder === 'function' ? { mapFromDriverValue: decoder } : decoder;\n\t\treturn this as SQL<GetDecoderResult<TDecoder>>;\n\t}\n\n\tinlineParams(): this {\n\t\tthis.shouldInlineParams = true;\n\t\treturn this;\n\t}\n}\n\nexport type GetDecoderResult<T> = T extends Column ? T['_']['data'] : T extends\n\t| DriverValueDecoder<infer TData, any>\n\t| DriverValueDecoder<infer TData, any>['mapFromDriverValue'] ? TData\n: never;\n\n/**\n * Any DB name (table, column, index etc.)\n */\nexport class Name implements SQLWrapper {\n\tstatic readonly [entityKind]: string = 'Name';\n\n\tprotected brand!: 'Name';\n\n\tconstructor(readonly value: string) {}\n\n\tgetSQL(): SQL<unknown> {\n\t\treturn new SQL([this]);\n\t}\n}\n\n/**\n * Any DB name (table, column, index etc.)\n * @deprecated Use `sql.identifier` instead.\n */\nexport function name(value: string): Name {\n\treturn new Name(value);\n}\n\nexport interface DriverValueDecoder<TData, TDriverParam> {\n\tmapFromDriverValue(value: TDriverParam): TData;\n}\n\nexport interface DriverValueEncoder<TData, TDriverParam> {\n\tmapToDriverValue(value: TData): TDriverParam | SQL;\n}\n\nexport function isDriverValueEncoder(value: unknown): value is DriverValueEncoder<any, any> {\n\treturn typeof value === 'object' && value !== null && 'mapToDriverValue' in value\n\t\t&& typeof (value as any).mapToDriverValue === 'function';\n}\n\nexport const noopDecoder: DriverValueDecoder<any, any> = {\n\tmapFromDriverValue: (value) => value,\n};\n\nexport const noopEncoder: DriverValueEncoder<any, any> = {\n\tmapToDriverValue: (value) => value,\n};\n\nexport interface DriverValueMapper<TData, TDriverParam>\n\textends DriverValueDecoder<TData, TDriverParam>, DriverValueEncoder<TData, TDriverParam>\n{}\n\nexport const noopMapper: DriverValueMapper<any, any> = {\n\t...noopDecoder,\n\t...noopEncoder,\n};\n\n/** Parameter value that is optionally bound to an encoder (for example, a column). */\nexport class Param<TDataType = unknown, TDriverParamType = TDataType> implements SQLWrapper {\n\tstatic readonly [entityKind]: string = 'Param';\n\n\tprotected brand!: 'BoundParamValue';\n\n\t/**\n\t * @param value - Parameter value\n\t * @param encoder - Encoder to convert the value to a driver parameter\n\t */\n\tconstructor(\n\t\treadonly value: TDataType,\n\t\treadonly encoder: DriverValueEncoder<TDataType, TDriverParamType> = noopEncoder,\n\t) {}\n\n\tgetSQL(): SQL<unknown> {\n\t\treturn new SQL([this]);\n\t}\n}\n\n/** @deprecated Use `sql.param` instead. */\nexport function param<TData, TDriver>(\n\tvalue: TData,\n\tencoder?: DriverValueEncoder<TData, TDriver>,\n): Param<TData, TDriver> {\n\treturn new Param(value, encoder);\n}\n\n/**\n * Anything that can be passed to the `` sql`...` `` tagged function.\n */\nexport type SQLChunk =\n\t| StringChunk\n\t| SQLChunk[]\n\t| SQLWrapper\n\t| SQL\n\t| Table\n\t| View\n\t| Subquery\n\t| AnyColumn\n\t| Param\n\t| Name\n\t| undefined\n\t| FakePrimitiveParam\n\t| Placeholder;\n\nexport function sql<T>(strings: TemplateStringsArray, ...params: any[]): SQL<T>;\n/*\n\tThe type of `params` is specified as `SQLSourceParam[]`, but that's slightly incorrect -\n\tin runtime, users won't pass `FakePrimitiveParam` instances as `params` - they will pass primitive values\n\twhich will be wrapped in `Param` using `buildChunksFromParam(...)`. That's why the overload\n\tspecify `params` as `any[]` and not as `SQLSourceParam[]`. This type is used to make our lives easier and\n\tthe type checker happy.\n*/\nexport function sql(strings: TemplateStringsArray, ...params: SQLChunk[]): SQL {\n\tconst queryChunks: SQLChunk[] = [];\n\tif (params.length > 0 || (strings.length > 0 && strings[0] !== '')) {\n\t\tqueryChunks.push(new StringChunk(strings[0]!));\n\t}\n\tfor (const [paramIndex, param] of params.entries()) {\n\t\tqueryChunks.push(param, new StringChunk(strings[paramIndex + 1]!));\n\t}\n\n\treturn new SQL(queryChunks);\n}\n\nexport namespace sql {\n\texport function empty(): SQL {\n\t\treturn new SQL([]);\n\t}\n\n\t/** @deprecated - use `sql.join()` */\n\texport function fromList(list: SQLChunk[]): SQL {\n\t\treturn new SQL(list);\n\t}\n\n\t/**\n\t * Convenience function to create an SQL query from a raw string.\n\t * @param str The raw SQL query string.\n\t */\n\texport function raw(str: string): SQL {\n\t\treturn new SQL([new StringChunk(str)]);\n\t}\n\n\t/**\n\t * Join a list of SQL chunks with a separator.\n\t * @example\n\t * ```ts\n\t * const query = sql.join([sql`a`, sql`b`, sql`c`]);\n\t * // sql`abc`\n\t * ```\n\t * @example\n\t * ```ts\n\t * const query = sql.join([sql`a`, sql`b`, sql`c`], sql`, `);\n\t * // sql`a, b, c`\n\t * ```\n\t */\n\texport function join(chunks: SQLChunk[], separator?: SQLChunk): SQL {\n\t\tconst result: SQLChunk[] = [];\n\t\tfor (const [i, chunk] of chunks.entries()) {\n\t\t\tif (i > 0 && separator !== undefined) {\n\t\t\t\tresult.push(separator);\n\t\t\t}\n\t\t\tresult.push(chunk);\n\t\t}\n\t\treturn new SQL(result);\n\t}\n\n\t/**\n\t * Create a SQL chunk that represents a DB identifier (table, column, index etc.).\n\t * When used in a query, the identifier will be escaped based on the DB engine.\n\t * For example, in PostgreSQL, identifiers are escaped with double quotes.\n\t *\n\t * **WARNING: This function does not offer any protection against SQL injections, so you must validate any user input beforehand.**\n\t *\n\t * @example ```ts\n\t * const query = sql`SELECT * FROM ${sql.identifier('my-table')}`;\n\t * // 'SELECT * FROM \"my-table\"'\n\t * ```\n\t */\n\texport function identifier(value: string): Name {\n\t\treturn new Name(value);\n\t}\n\n\texport function placeholder<TName extends string>(name: TName): Placeholder<TName> {\n\t\treturn new Placeholder(name);\n\t}\n\n\texport function param<TData, TDriver>(\n\t\tvalue: TData,\n\t\tencoder?: DriverValueEncoder<TData, TDriver>,\n\t): Param<TData, TDriver> {\n\t\treturn new Param(value, encoder);\n\t}\n}\n\nexport namespace SQL {\n\texport class Aliased<T = unknown> implements SQLWrapper {\n\t\tstatic readonly [entityKind]: string = 'SQL.Aliased';\n\n\t\tdeclare _: {\n\t\t\tbrand: 'SQL.Aliased';\n\t\t\ttype: T;\n\t\t};\n\n\t\t/** @internal */\n\t\tisSelectionField = false;\n\n\t\tconstructor(\n\t\t\treadonly sql: SQL,\n\t\t\treadonly fieldAlias: string,\n\t\t) {}\n\n\t\tgetSQL(): SQL {\n\t\t\treturn this.sql;\n\t\t}\n\n\t\t/** @internal */\n\t\tclone() {\n\t\t\treturn new Aliased(this.sql, this.fieldAlias);\n\t\t}\n\t}\n}\n\nexport class Placeholder<TName extends string = string, TValue = any> implements SQLWrapper {\n\tstatic readonly [entityKind]: string = 'Placeholder';\n\n\tdeclare protected: TValue;\n\n\tconstructor(readonly name: TName) {}\n\n\tgetSQL(): SQL {\n\t\treturn new SQL([this]);\n\t}\n}\n\n/** @deprecated Use `sql.placeholder` instead. */\nexport function placeholder<TName extends string>(name: TName): Placeholder<TName> {\n\treturn new Placeholder(name);\n}\n\nexport function fillPlaceholders(params: unknown[], values: Record<string, unknown>): unknown[] {\n\treturn params.map((p) => {\n\t\tif (is(p, Placeholder)) {\n\t\t\tif (!(p.name in values)) {\n\t\t\t\tthrow new Error(`No value for placeholder \"${p.name}\" was provided`);\n\t\t\t}\n\t\t\treturn values[p.name];\n\t\t}\n\n\t\treturn p;\n\t});\n}\n\nexport type ColumnsSelection = Record<string, unknown>;\n\nexport abstract class View<\n\tTName extends string = string,\n\tTExisting extends boolean = boolean,\n\tTSelection extends ColumnsSelection = ColumnsSelection,\n> implements SQLWrapper {\n\tstatic readonly [entityKind]: string = 'View';\n\n\tdeclare _: {\n\t\tbrand: 'View';\n\t\tviewBrand: string;\n\t\tname: TName;\n\t\texisting: TExisting;\n\t\tselectedFields: TSelection;\n\t};\n\n\t/** @internal */\n\t[ViewBaseConfig]: {\n\t\tname: TName;\n\t\toriginalName: TName;\n\t\tschema: string | undefined;\n\t\tselectedFields: SelectedFields<AnyColumn, Table>;\n\t\tisExisting: TExisting;\n\t\tquery: TExisting extends true ? undefined : SQL;\n\t\tisAlias: boolean;\n\t};\n\n\tconstructor(\n\t\t{ name, schema, selectedFields, query }: {\n\t\t\tname: TName;\n\t\t\tschema: string | undefined;\n\t\t\tselectedFields: SelectedFields<AnyColumn, Table>;\n\t\t\tquery: SQL | undefined;\n\t\t},\n\t) {\n\t\tthis[ViewBaseConfig] = {\n\t\t\tname,\n\t\t\toriginalName: name,\n\t\t\tschema,\n\t\t\tselectedFields,\n\t\t\tquery: query as (TExisting extends true ? undefined : SQL),\n\t\t\tisExisting: !query as TExisting,\n\t\t\tisAlias: false,\n\t\t};\n\t}\n\n\tgetSQL(): SQL<unknown> {\n\t\treturn new SQL([this]);\n\t}\n}\n\n// Defined separately from the Column class to resolve circular dependency\nColumn.prototype.getSQL = function() {\n\treturn new SQL([this]);\n};\n\n// Defined separately from the Table class to resolve circular dependency\nTable.prototype.getSQL = function() {\n\treturn new SQL([this]);\n};\n\n// Defined separately from the Column class to resolve circular dependency\nSubquery.prototype.getSQL = function() {\n\treturn new SQL([this]);\n};\n","import type { AnyColumn } from './column.ts';\nimport { Column } from './column.ts';\nimport { is } from './entity.ts';\nimport type { Logger } from './logger.ts';\nimport type { SelectedFieldsOrdered } from './operations.ts';\nimport type { TableLike } from './query-builders/select.types.ts';\nimport { Param, SQL, View } from './sql/sql.ts';\nimport type { DriverValueDecoder } from './sql/sql.ts';\nimport { Subquery, SubqueryConfig } from './subquery.ts';\nimport { getTableName, Table } from './table.ts';\nimport { ViewBaseConfig } from './view-common.ts';\n\n/** @internal */\nexport function mapResultRow<TResult>(\n\tcolumns: SelectedFieldsOrdered<AnyColumn>,\n\trow: unknown[],\n\tjoinsNotNullableMap: Record<string, boolean> | undefined,\n): TResult {\n\t// Key -> nested object key, value -> table name if all fields in the nested object are from the same table, false otherwise\n\tconst nullifyMap: Record<string, string | false> = {};\n\n\tconst result = columns.reduce<Record<string, any>>(\n\t\t(result, { path, field }, columnIndex) => {\n\t\t\tlet decoder: DriverValueDecoder<unknown, unknown>;\n\t\t\tif (is(field, Column)) {\n\t\t\t\tdecoder = field;\n\t\t\t} else if (is(field, SQL)) {\n\t\t\t\tdecoder = field.decoder;\n\t\t\t} else {\n\t\t\t\tdecoder = field.sql.decoder;\n\t\t\t}\n\t\t\tlet node = result;\n\t\t\tfor (const [pathChunkIndex, pathChunk] of path.entries()) {\n\t\t\t\tif (pathChunkIndex < path.length - 1) {\n\t\t\t\t\tif (!(pathChunk in node)) {\n\t\t\t\t\t\tnode[pathChunk] = {};\n\t\t\t\t\t}\n\t\t\t\t\tnode = node[pathChunk];\n\t\t\t\t} else {\n\t\t\t\t\tconst rawValue = row[columnIndex]!;\n\t\t\t\t\tconst value = node[pathChunk] = rawValue === null ? null : decoder.mapFromDriverValue(rawValue);\n\n\t\t\t\t\tif (joinsNotNullableMap && is(field, Column) && path.length === 2) {\n\t\t\t\t\t\tconst objectName = path[0]!;\n\t\t\t\t\t\tif (!(objectName in nullifyMap)) {\n\t\t\t\t\t\t\tnullifyMap[objectName] = value === null ? getTableName(field.table) : false;\n\t\t\t\t\t\t} else if (\n\t\t\t\t\t\t\ttypeof nullifyMap[objectName] === 'string' && nullifyMap[objectName] !== getTableName(field.table)\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tnullifyMap[objectName] = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\t\t},\n\t\t{},\n\t);\n\n\t// Nullify all nested objects from nullifyMap that are nullable\n\tif (joinsNotNullableMap && Object.keys(nullifyMap).length > 0) {\n\t\tfor (const [objectName, tableName] of Object.entries(nullifyMap)) {\n\t\t\tif (typeof tableName === 'string' && !joinsNotNullableMap[tableName]) {\n\t\t\t\tresult[objectName] = null;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn result as TResult;\n}\n\n/** @internal */\nexport function orderSelectedFields<TColumn extends AnyColumn>(\n\tfields: Record<string, unknown>,\n\tpathPrefix?: string[],\n): SelectedFieldsOrdered<TColumn> {\n\treturn Object.entries(fields).reduce<SelectedFieldsOrdered<AnyColumn>>((result, [name, field]) => {\n\t\tif (typeof name !== 'string') {\n\t\t\treturn result;\n\t\t}\n\n\t\tconst newPath = pathPrefix ? [...pathPrefix, name] : [name];\n\t\tif (is(field, Column) || is(field, SQL) || is(field, SQL.Aliased)) {\n\t\t\tresult.push({ path: newPath, field });\n\t\t} else if (is(field, Table)) {\n\t\t\tresult.push(...orderSelectedFields(field[Table.Symbol.Columns], newPath));\n\t\t} else {\n\t\t\tresult.push(...orderSelectedFields(field as Record<string, unknown>, newPath));\n\t\t}\n\t\treturn result;\n\t}, []) as SelectedFieldsOrdered<TColumn>;\n}\n\nexport function haveSameKeys(left: Record<string, unknown>, right: Record<string, unknown>) {\n\tconst leftKeys = Object.keys(left);\n\tconst rightKeys = Object.keys(right);\n\n\tif (leftKeys.length !== rightKeys.length) {\n\t\treturn false;\n\t}\n\n\tfor (const [index, key] of leftKeys.entries()) {\n\t\tif (key !== rightKeys[index]) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\n/** @internal */\nexport function mapUpdateSet(table: Table, values: Record<string, unknown>): UpdateSet {\n\tconst entries: [string, UpdateSet[string]][] = Object.entries(values)\n\t\t.filter(([, value]) => value !== undefined)\n\t\t.map(([key, value]) => {\n\t\t\t// eslint-disable-next-line unicorn/prefer-ternary\n\t\t\tif (is(value, SQL)) {\n\t\t\t\treturn [key, value];\n\t\t\t} else {\n\t\t\t\treturn [key, new Param(value, table[Table.Symbol.Columns][key])];\n\t\t\t}\n\t\t});\n\n\tif (entries.length === 0) {\n\t\tthrow new Error('No values to set');\n\t}\n\n\treturn Object.fromEntries(entries);\n}\n\nexport type UpdateSet = Record<string, SQL | Param | null | undefined>;\n\nexport type OneOrMany<T> = T | T[];\n\nexport type Update<T, TUpdate> = Simplify<\n\t& {\n\t\t[K in Exclude<keyof T, keyof TUpdate>]: T[K];\n\t}\n\t& TUpdate\n>;\n\nexport type Simplify<T> =\n\t& {\n\t\t// @ts-ignore - \"Type parameter 'K' has a circular constraint\", not sure why\n\t\t[K in keyof T]: T[K];\n\t}\n\t& {};\n\nexport type SimplifyMappedType<T> = [T] extends [unknown] ? T : never;\n\nexport type ShallowRecord<K extends keyof any, T> = SimplifyMappedType<{ [P in K]: T }>;\n\nexport type Assume<T, U> = T extends U ? T : U;\n\nexport type Equal<X, Y> = (<T>() => T extends X ? 1 : 2) extends (<T>() => T extends Y ? 1 : 2) ? true : false;\n\nexport interface DrizzleTypeError<T extends string> {\n\t$drizzleTypeError: T;\n}\n\nexport type ValueOrArray<T> = T | T[];\n\n/** @internal */\nexport function applyMixins(baseClass: any, extendedClasses: any[]) {\n\tfor (const extendedClass of extendedClasses) {\n\t\tfor (const name of Object.getOwnPropertyNames(extendedClass.prototype)) {\n\t\t\tif (name === 'constructor') continue;\n\n\t\t\tObject.defineProperty(\n\t\t\t\tbaseClass.prototype,\n\t\t\t\tname,\n\t\t\t\tObject.getOwnPropertyDescriptor(extendedClass.prototype, name) || Object.create(null),\n\t\t\t);\n\t\t}\n\t}\n}\n\nexport type Or<T1, T2> = T1 extends true ? true : T2 extends true ? true : false;\n\nexport type IfThenElse<If, Then, Else> = If extends true ? Then : Else;\n\nexport type PromiseOf<T> = T extends Promise<infer U> ? U : T;\n\nexport type Writable<T> = {\n\t-readonly [P in keyof T]: T[P];\n};\n\nexport function getTableColumns<T extends Table>(table: T): T['_']['columns'] {\n\treturn table[Table.Symbol.Columns];\n}\n\n/** @internal */\nexport function getTableLikeName(table: TableLike): string | undefined {\n\treturn is(table, Subquery)\n\t\t? table[SubqueryConfig].alias\n\t\t: is(table, View)\n\t\t? table[ViewBaseConfig].name\n\t\t: is(table, SQL)\n\t\t? undefined\n\t\t: table[Table.Symbol.IsAlias]\n\t\t? table[Table.Symbol.Name]\n\t\t: table[Table.Symbol.BaseName];\n}\n\nexport type ColumnsWithTable<\n\tTTableName extends string,\n\tTForeignTableName extends string,\n\tTColumns extends AnyColumn<{ tableName: TTableName }>[],\n> = { [Key in keyof TColumns]: AnyColumn<{ tableName: TForeignTableName }> };\n\nexport interface DrizzleConfig<TSchema extends Record<string, unknown> = Record<string, never>> {\n\tlogger?: boolean | Logger;\n\tschema?: TSchema;\n}\nexport type ValidateShape<T, ValidShape, TResult = T> = T extends ValidShape\n\t? Exclude<keyof T, keyof ValidShape> extends never ? TResult\n\t: DrizzleTypeError<\n\t\t`Invalid key(s): ${Exclude<(keyof T) & (string | number | bigint | boolean | null | undefined), keyof ValidShape>}`\n\t>\n\t: never;\n\nexport type KnownKeysOnly<T, U> = {\n\t[K in keyof T]: K extends keyof U ? T[K] : never;\n};\n\nexport type IsAny<T> = 0 extends (1 & T) ? true : false;\n","import { entityKind } from '~/entity.ts';\nimport type { PgDialect } from '~/pg-core/dialect.ts';\nimport type {\n\tPgPreparedQuery,\n\tPgSession,\n\tPreparedQueryConfig,\n\tQueryResultHKT,\n\tQueryResultKind,\n} from '~/pg-core/session.ts';\nimport type { PgTable } from '~/pg-core/table.ts';\nimport type { SelectResultFields } from '~/query-builders/select.types.ts';\nimport { QueryPromise } from '~/query-promise.ts';\nimport type { RunnableQuery } from '~/runnable-query.ts';\nimport type { Query, SQL, SQLWrapper } from '~/sql/sql.ts';\nimport type { Subquery } from '~/subquery.ts';\nimport { Table } from '~/table.ts';\nimport { tracer } from '~/tracing.ts';\nimport { orderSelectedFields } from '~/utils.ts';\nimport type { PgColumn } from '../columns/common.ts';\nimport type { SelectedFieldsFlat, SelectedFieldsOrdered } from './select.types.ts';\n\nexport type PgDeleteWithout<\n\tT extends AnyPgDeleteBase,\n\tTDynamic extends boolean,\n\tK extends keyof T & string,\n> = TDynamic extends true ? T\n\t: Omit<\n\t\tPgDeleteBase<\n\t\t\tT['_']['table'],\n\t\t\tT['_']['queryResult'],\n\t\t\tT['_']['returning'],\n\t\t\tTDynamic,\n\t\t\tT['_']['excludedMethods'] | K\n\t\t>,\n\t\tT['_']['excludedMethods'] | K\n\t>;\n\nexport type PgDelete<\n\tTTable extends PgTable = PgTable,\n\tTQueryResult extends QueryResultHKT = QueryResultHKT,\n\tTReturning extends Record<string, unknown> | undefined = Record<string, unknown> | undefined,\n> = PgDeleteBase<TTable, TQueryResult, TReturning, true, never>;\n\nexport interface PgDeleteConfig {\n\twhere?: SQL | undefined;\n\ttable: PgTable;\n\treturning?: SelectedFieldsOrdered;\n\twithList?: Subquery[];\n}\n\nexport type PgDeleteReturningAll<\n\tT extends AnyPgDeleteBase,\n\tTDynamic extends boolean,\n> = PgDeleteWithout<\n\tPgDeleteBase<\n\t\tT['_']['table'],\n\t\tT['_']['queryResult'],\n\t\tT['_']['table']['$inferSelect'],\n\t\tTDynamic,\n\t\tT['_']['excludedMethods']\n\t>,\n\tTDynamic,\n\t'returning'\n>;\n\nexport type PgDeleteReturning<\n\tT extends AnyPgDeleteBase,\n\tTDynamic extends boolean,\n\tTSelectedFields extends SelectedFieldsFlat,\n> = PgDeleteWithout<\n\tPgDeleteBase<\n\t\tT['_']['table'],\n\t\tT['_']['queryResult'],\n\t\tSelectResultFields<TSelectedFields>,\n\t\tTDynamic,\n\t\tT['_']['excludedMethods']\n\t>,\n\tTDynamic,\n\t'returning'\n>;\n\nexport type PgDeletePrepare<T extends AnyPgDeleteBase> = PgPreparedQuery<\n\tPreparedQueryConfig & {\n\t\texecute: T['_']['returning'] extends undefined ? QueryResultKind<T['_']['queryResult'], never>\n\t\t\t: T['_']['returning'][];\n\t}\n>;\n\nexport type PgDeleteDynamic<T extends AnyPgDeleteBase> = PgDelete<\n\tT['_']['table'],\n\tT['_']['queryResult'],\n\tT['_']['returning']\n>;\n\nexport type AnyPgDeleteBase = PgDeleteBase<any, any, any, any, any>;\n\nexport interface PgDeleteBase<\n\tTTable extends PgTable,\n\tTQueryResult extends QueryResultHKT,\n\tTReturning extends Record<string, unknown> | undefined = undefined,\n\tTDynamic extends boolean = false,\n\tTExcludedMethods extends string = never,\n> extends\n\tQueryPromise<TReturning extends undefined ? QueryResultKind<TQueryResult, never> : TReturning[]>,\n\tRunnableQuery<TReturning extends undefined ? QueryResultKind<TQueryResult, never> : TReturning[], 'pg'>,\n\tSQLWrapper\n{\n\treadonly _: {\n\t\tdialect: 'pg';\n\t\treadonly table: TTable;\n\t\treadonly queryResult: TQueryResult;\n\t\treadonly returning: TReturning;\n\t\treadonly dynamic: TDynamic;\n\t\treadonly excludedMethods: TExcludedMethods;\n\t\treadonly result: TReturning extends undefined ? QueryResultKind<TQueryResult, never> : TReturning[];\n\t};\n}\n\nexport class PgDeleteBase<\n\tTTable extends PgTable,\n\tTQueryResult extends QueryResultHKT,\n\tTReturning extends Record<string, unknown> | undefined = undefined,\n\tTDynamic extends boolean = false,\n\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\tTExcludedMethods extends string = never,\n> extends QueryPromise<TReturning extends undefined ? QueryResultKind<TQueryResult, never> : TReturning[]>\n\timplements\n\t\tRunnableQuery<TReturning extends undefined ? QueryResultKind<TQueryResult, never> : TReturning[], 'pg'>,\n\t\tSQLWrapper\n{\n\tstatic readonly [entityKind]: string = 'PgDelete';\n\n\tprivate config: PgDeleteConfig;\n\n\tconstructor(\n\t\ttable: TTable,\n\t\tprivate session: PgSession,\n\t\tprivate dialect: PgDialect,\n\t\twithList?: Subquery[],\n\t) {\n\t\tsuper();\n\t\tthis.config = { table, withList };\n\t}\n\n\t/**\n\t * Adds a `where` clause to the query.\n\t *\n\t * Calling this method will delete only those rows that fulfill a specified condition.\n\t *\n\t * See docs: {@link https://orm.drizzle.team/docs/delete}\n\t *\n\t * @param where the `where` clause.\n\t *\n\t * @example\n\t * You can use conditional operators and `sql function` to filter the rows to be deleted.\n\t *\n\t * ```ts\n\t * // Delete all cars with green color\n\t * await db.delete(cars).where(eq(cars.color, 'green'));\n\t * // or\n\t * await db.delete(cars).where(sql`${cars.color} = 'green'`)\n\t * ```\n\t *\n\t * You can logically combine conditional operators with `and()` and `or()` operators:\n\t *\n\t * ```ts\n\t * // Delete all BMW cars with a green color\n\t * await db.delete(cars).where(and(eq(cars.color, 'green'), eq(cars.brand, 'BMW')));\n\t *\n\t * // Delete all cars with the green or blue color\n\t * await db.delete(cars).where(or(eq(cars.color, 'green'), eq(cars.color, 'blue')));\n\t * ```\n\t */\n\twhere(where: SQL | undefined): PgDeleteWithout<this, TDynamic, 'where'> {\n\t\tthis.config.where = where;\n\t\treturn this as any;\n\t}\n\n\t/**\n\t * Adds a `returning` clause to the query.\n\t *\n\t * Calling this method will return the specified fields of the deleted rows. If no fields are specified, all fields will be returned.\n\t *\n\t * See docs: {@link https://orm.drizzle.team/docs/delete#delete-with-return}\n\t *\n\t * @example\n\t * ```ts\n\t * // Delete all cars with the green color and return all fields\n\t * const deletedCars: Car[] = await db.delete(cars)\n\t *   .where(eq(cars.color, 'green'))\n\t *   .returning();\n\t *\n\t * // Delete all cars with the green color and return only their id and brand fields\n\t * const deletedCarsIdsAndBrands: { id: number, brand: string }[] = await db.delete(cars)\n\t *   .where(eq(cars.color, 'green'))\n\t *   .returning({ id: cars.id, brand: cars.brand });\n\t * ```\n\t */\n\treturning(): PgDeleteReturningAll<this, TDynamic>;\n\treturning<TSelectedFields extends SelectedFieldsFlat>(\n\t\tfields: TSelectedFields,\n\t): PgDeleteReturning<this, TDynamic, TSelectedFields>;\n\treturning(\n\t\tfields: SelectedFieldsFlat = this.config.table[Table.Symbol.Columns],\n\t): PgDeleteReturning<this, TDynamic, any> {\n\t\tthis.config.returning = orderSelectedFields<PgColumn>(fields);\n\t\treturn this as any;\n\t}\n\n\t/** @internal */\n\tgetSQL(): SQL {\n\t\treturn this.dialect.buildDeleteQuery(this.config);\n\t}\n\n\ttoSQL(): Query {\n\t\tconst { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());\n\t\treturn rest;\n\t}\n\n\t/** @internal */\n\t_prepare(name?: string): PgDeletePrepare<this> {\n\t\treturn tracer.startActiveSpan('drizzle.prepareQuery', () => {\n\t\t\treturn this.session.prepareQuery<\n\t\t\t\tPreparedQueryConfig & {\n\t\t\t\t\texecute: TReturning extends undefined ? QueryResultKind<TQueryResult, never> : TReturning[];\n\t\t\t\t}\n\t\t\t>(this.dialect.sqlToQuery(this.getSQL()), this.config.returning, name);\n\t\t});\n\t}\n\n\tprepare(name: string): PgDeletePrepare<this> {\n\t\treturn this._prepare(name);\n\t}\n\n\toverride execute: ReturnType<this['prepare']>['execute'] = (placeholderValues) => {\n\t\treturn tracer.startActiveSpan('drizzle.operation', () => {\n\t\t\treturn this._prepare().execute(placeholderValues);\n\t\t});\n\t};\n\n\t$dynamic(): PgDeleteDynamic<this> {\n\t\treturn this as any;\n\t}\n}\n","import { entityKind, is } from '~/entity.ts';\nimport type { PgDialect } from '~/pg-core/dialect.ts';\nimport type { IndexColumn } from '~/pg-core/indexes.ts';\nimport type {\n\tPgPreparedQuery,\n\tPgSession,\n\tPreparedQueryConfig,\n\tQueryResultHKT,\n\tQueryResultKind,\n} from '~/pg-core/session.ts';\nimport type { PgTable } from '~/pg-core/table.ts';\nimport type { SelectResultFields } from '~/query-builders/select.types.ts';\nimport { QueryPromise } from '~/query-promise.ts';\nimport type { RunnableQuery } from '~/runnable-query.ts';\nimport type { Placeholder, Query, SQLWrapper } from '~/sql/sql.ts';\nimport { Param, SQL, sql } from '~/sql/sql.ts';\nimport type { Subquery } from '~/subquery.ts';\nimport { Table } from '~/table.ts';\nimport { tracer } from '~/tracing.ts';\nimport { mapUpdateSet, orderSelectedFields } from '~/utils.ts';\nimport type { PgColumn } from '../columns/common.ts';\nimport type { SelectedFieldsFlat, SelectedFieldsOrdered } from './select.types.ts';\nimport type { PgUpdateSetSource } from './update.ts';\n\nexport interface PgInsertConfig<TTable extends PgTable = PgTable> {\n\ttable: TTable;\n\tvalues: Record<string, Param | SQL>[];\n\twithList?: Subquery[];\n\tonConflict?: SQL;\n\treturning?: SelectedFieldsOrdered;\n}\n\nexport type PgInsertValue<TTable extends PgTable> =\n\t& {\n\t\t[Key in keyof TTable['$inferInsert']]: TTable['$inferInsert'][Key] | SQL | Placeholder;\n\t}\n\t& {};\n\nexport class PgInsertBuilder<TTable extends PgTable, TQueryResult extends QueryResultHKT> {\n\tstatic readonly [entityKind]: string = 'PgInsertBuilder';\n\n\tconstructor(\n\t\tprivate table: TTable,\n\t\tprivate session: PgSession,\n\t\tprivate dialect: PgDialect,\n\t\tprivate withList?: Subquery[],\n\t) {}\n\n\tvalues(value: PgInsertValue<TTable>): PgInsertBase<TTable, TQueryResult>;\n\tvalues(values: PgInsertValue<TTable>[]): PgInsertBase<TTable, TQueryResult>;\n\tvalues(values: PgInsertValue<TTable> | PgInsertValue<TTable>[]): PgInsertBase<TTable, TQueryResult> {\n\t\tvalues = Array.isArray(values) ? values : [values];\n\t\tif (values.length === 0) {\n\t\t\tthrow new Error('values() must be called with at least one value');\n\t\t}\n\t\tconst mappedValues = values.map((entry) => {\n\t\t\tconst result: Record<string, Param | SQL> = {};\n\t\t\tconst cols = this.table[Table.Symbol.Columns];\n\t\t\tfor (const colKey of Object.keys(entry)) {\n\t\t\t\tconst colValue = entry[colKey as keyof typeof entry];\n\t\t\t\tresult[colKey] = is(colValue, SQL) ? colValue : new Param(colValue, cols[colKey]);\n\t\t\t}\n\t\t\treturn result;\n\t\t});\n\n\t\treturn new PgInsertBase(this.table, mappedValues, this.session, this.dialect, this.withList);\n\t}\n}\n\nexport type PgInsertWithout<T extends AnyPgInsert, TDynamic extends boolean, K extends keyof T & string> =\n\tTDynamic extends true ? T\n\t\t: Omit<\n\t\t\tPgInsertBase<\n\t\t\t\tT['_']['table'],\n\t\t\t\tT['_']['queryResult'],\n\t\t\t\tT['_']['returning'],\n\t\t\t\tTDynamic,\n\t\t\t\tT['_']['excludedMethods'] | K\n\t\t\t>,\n\t\t\tT['_']['excludedMethods'] | K\n\t\t>;\n\nexport type PgInsertReturning<\n\tT extends AnyPgInsert,\n\tTDynamic extends boolean,\n\tTSelectedFields extends SelectedFieldsFlat,\n> = PgInsertBase<\n\tT['_']['table'],\n\tT['_']['queryResult'],\n\tSelectResultFields<TSelectedFields>,\n\tTDynamic,\n\tT['_']['excludedMethods']\n>;\n\nexport type PgInsertReturningAll<T extends AnyPgInsert, TDynamic extends boolean> = PgInsertBase<\n\tT['_']['table'],\n\tT['_']['queryResult'],\n\tT['_']['table']['$inferSelect'],\n\tTDynamic,\n\tT['_']['excludedMethods']\n>;\n\nexport interface PgInsertOnConflictDoUpdateConfig<T extends AnyPgInsert> {\n\ttarget: IndexColumn | IndexColumn[];\n\twhere?: SQL;\n\tset: PgUpdateSetSource<T['_']['table']>;\n}\n\nexport type PgInsertPrepare<T extends AnyPgInsert> = PgPreparedQuery<\n\tPreparedQueryConfig & {\n\t\texecute: T['_']['returning'] extends undefined ? QueryResultKind<T['_']['queryResult'], never>\n\t\t\t: T['_']['returning'][];\n\t}\n>;\n\nexport type PgInsertDynamic<T extends AnyPgInsert> = PgInsert<\n\tT['_']['table'],\n\tT['_']['queryResult'],\n\tT['_']['returning']\n>;\n\nexport type AnyPgInsert = PgInsertBase<any, any, any, any, any>;\n\nexport type PgInsert<\n\tTTable extends PgTable = PgTable,\n\tTQueryResult extends QueryResultHKT = QueryResultHKT,\n\tTReturning extends Record<string, unknown> | undefined = Record<string, unknown> | undefined,\n> = PgInsertBase<TTable, TQueryResult, TReturning, true, never>;\n\nexport interface PgInsertBase<\n\tTTable extends PgTable,\n\tTQueryResult extends QueryResultHKT,\n\tTReturning extends Record<string, unknown> | undefined = undefined,\n\tTDynamic extends boolean = false,\n\tTExcludedMethods extends string = never,\n> extends\n\tQueryPromise<TReturning extends undefined ? QueryResultKind<TQueryResult, never> : TReturning[]>,\n\tRunnableQuery<TReturning extends undefined ? QueryResultKind<TQueryResult, never> : TReturning[], 'pg'>,\n\tSQLWrapper\n{\n\treadonly _: {\n\t\treadonly dialect: 'pg';\n\t\treadonly table: TTable;\n\t\treadonly queryResult: TQueryResult;\n\t\treadonly returning: TReturning;\n\t\treadonly dynamic: TDynamic;\n\t\treadonly excludedMethods: TExcludedMethods;\n\t\treadonly result: TReturning extends undefined ? QueryResultKind<TQueryResult, never> : TReturning[];\n\t};\n}\n\nexport class PgInsertBase<\n\tTTable extends PgTable,\n\tTQueryResult extends QueryResultHKT,\n\tTReturning extends Record<string, unknown> | undefined = undefined,\n\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\tTDynamic extends boolean = false,\n\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\tTExcludedMethods extends string = never,\n> extends QueryPromise<TReturning extends undefined ? QueryResultKind<TQueryResult, never> : TReturning[]>\n\timplements\n\t\tRunnableQuery<TReturning extends undefined ? QueryResultKind<TQueryResult, never> : TReturning[], 'pg'>,\n\t\tSQLWrapper\n{\n\tstatic readonly [entityKind]: string = 'PgInsert';\n\n\tprivate config: PgInsertConfig<TTable>;\n\n\tconstructor(\n\t\ttable: TTable,\n\t\tvalues: PgInsertConfig['values'],\n\t\tprivate session: PgSession,\n\t\tprivate dialect: PgDialect,\n\t\twithList?: Subquery[],\n\t) {\n\t\tsuper();\n\t\tthis.config = { table, values, withList };\n\t}\n\n\t/**\n\t * Adds a `returning` clause to the query.\n\t *\n\t * Calling this method will return the specified fields of the inserted rows. If no fields are specified, all fields will be returned.\n\t *\n\t * See docs: {@link https://orm.drizzle.team/docs/insert#insert-returning}\n\t *\n\t * @example\n\t * ```ts\n\t * // Insert one row and return all fields\n\t * const insertedCar: Car[] = await db.insert(cars)\n\t *   .values({ brand: 'BMW' })\n\t *   .returning();\n\t *\n\t * // Insert one row and return only the id\n\t * const insertedCarId: { id: number }[] = await db.insert(cars)\n\t *   .values({ brand: 'BMW' })\n\t *   .returning({ id: cars.id });\n\t * ```\n\t */\n\treturning(): PgInsertWithout<PgInsertReturningAll<this, TDynamic>, TDynamic, 'returning'>;\n\treturning<TSelectedFields extends SelectedFieldsFlat>(\n\t\tfields: TSelectedFields,\n\t): PgInsertWithout<PgInsertReturning<this, TDynamic, TSelectedFields>, TDynamic, 'returning'>;\n\treturning(\n\t\tfields: SelectedFieldsFlat = this.config.table[Table.Symbol.Columns],\n\t): PgInsertWithout<AnyPgInsert, TDynamic, 'returning'> {\n\t\tthis.config.returning = orderSelectedFields<PgColumn>(fields);\n\t\treturn this as any;\n\t}\n\n\t/**\n\t * Adds an `on conflict do nothing` clause to the query.\n\t *\n\t * Calling this method simply avoids inserting a row as its alternative action.\n\t *\n\t * See docs: {@link https://orm.drizzle.team/docs/insert#on-conflict-do-nothing}\n\t *\n\t * @param config The `target` and `where` clauses.\n\t *\n\t * @example\n\t * ```ts\n\t * // Insert one row and cancel the insert if there's a conflict\n\t * await db.insert(cars)\n\t *   .values({ id: 1, brand: 'BMW' })\n\t *   .onConflictDoNothing();\n\t *\n\t * // Explicitly specify conflict target\n\t * await db.insert(cars)\n\t *   .values({ id: 1, brand: 'BMW' })\n\t *   .onConflictDoNothing({ target: cars.id });\n\t * ```\n\t */\n\tonConflictDoNothing(\n\t\tconfig: { target?: IndexColumn | IndexColumn[]; where?: SQL } = {},\n\t): PgInsertWithout<this, TDynamic, 'onConflictDoNothing' | 'onConflictDoUpdate'> {\n\t\tif (config.target === undefined) {\n\t\t\tthis.config.onConflict = sql`do nothing`;\n\t\t} else {\n\t\t\tlet targetColumn = '';\n\t\t\ttargetColumn = Array.isArray(config.target)\n\t\t\t\t? config.target.map((it) => this.dialect.escapeName(it.name)).join(',')\n\t\t\t\t: this.dialect.escapeName(config.target.name);\n\n\t\t\tconst whereSql = config.where ? sql` where ${config.where}` : undefined;\n\t\t\tthis.config.onConflict = sql`(${sql.raw(targetColumn)}) do nothing${whereSql}`;\n\t\t}\n\t\treturn this as any;\n\t}\n\n\t/**\n\t * Adds an `on conflict do update` clause to the query.\n\t *\n\t * Calling this method will update the existing row that conflicts with the row proposed for insertion as its alternative action.\n\t *\n\t * See docs: {@link https://orm.drizzle.team/docs/insert#upserts-and-conflicts}\n\t *\n\t * @param config The `target`, `set` and `where` clauses.\n\t *\n\t * @example\n\t * ```ts\n\t * // Update the row if there's a conflict\n\t * await db.insert(cars)\n\t *   .values({ id: 1, brand: 'BMW' })\n\t *   .onConflictDoUpdate({\n\t *     target: cars.id,\n\t *     set: { brand: 'Porsche' }\n\t *   });\n\t *\n\t * // Upsert with 'where' clause\n\t * await db.insert(cars)\n\t *   .values({ id: 1, brand: 'BMW' })\n\t *   .onConflictDoUpdate({\n\t *     target: cars.id,\n\t *     set: { brand: 'newBMW' },\n\t *     where: sql`${cars.createdAt} > '2023-01-01'::date`,\n\t *   });\n\t * ```\n\t */\n\tonConflictDoUpdate(\n\t\tconfig: PgInsertOnConflictDoUpdateConfig<this>,\n\t): PgInsertWithout<this, TDynamic, 'onConflictDoNothing' | 'onConflictDoUpdate'> {\n\t\tconst whereSql = config.where ? sql` where ${config.where}` : undefined;\n\t\tconst setSql = this.dialect.buildUpdateSet(this.config.table, mapUpdateSet(this.config.table, config.set));\n\t\tlet targetColumn = '';\n\t\ttargetColumn = Array.isArray(config.target)\n\t\t\t? config.target.map((it) => this.dialect.escapeName(it.name)).join(',')\n\t\t\t: this.dialect.escapeName(config.target.name);\n\t\tthis.config.onConflict = sql`(${sql.raw(targetColumn)}) do update set ${setSql}${whereSql}`;\n\t\treturn this as any;\n\t}\n\n\t/** @internal */\n\tgetSQL(): SQL {\n\t\treturn this.dialect.buildInsertQuery(this.config);\n\t}\n\n\ttoSQL(): Query {\n\t\tconst { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());\n\t\treturn rest;\n\t}\n\n\t/** @internal */\n\t_prepare(name?: string): PgInsertPrepare<this> {\n\t\treturn tracer.startActiveSpan('drizzle.prepareQuery', () => {\n\t\t\treturn this.session.prepareQuery<\n\t\t\t\tPreparedQueryConfig & {\n\t\t\t\t\texecute: TReturning extends undefined ? QueryResultKind<TQueryResult, never> : TReturning[];\n\t\t\t\t}\n\t\t\t>(this.dialect.sqlToQuery(this.getSQL()), this.config.returning, name);\n\t\t});\n\t}\n\n\tprepare(name: string): PgInsertPrepare<this> {\n\t\treturn this._prepare(name);\n\t}\n\n\toverride execute: ReturnType<this['prepare']>['execute'] = (placeholderValues) => {\n\t\treturn tracer.startActiveSpan('drizzle.operation', () => {\n\t\t\treturn this._prepare().execute(placeholderValues);\n\t\t});\n\t};\n\n\t$dynamic(): PgInsertDynamic<this> {\n\t\treturn this as any;\n\t}\n}\n","import type { AnyColumn } from './column.ts';\nimport { Column } from './column.ts';\nimport { entityKind, is } from './entity.ts';\nimport type { Relation } from './relations.ts';\nimport type { View } from './sql/sql.ts';\nimport { SQL, sql } from './sql/sql.ts';\nimport { Table } from './table.ts';\nimport { ViewBaseConfig } from './view-common.ts';\n\nexport class ColumnAliasProxyHandler<TColumn extends Column> implements ProxyHandler<TColumn> {\n\tstatic readonly [entityKind]: string = 'ColumnAliasProxyHandler';\n\n\tconstructor(private table: Table | View) {}\n\n\tget(columnObj: TColumn, prop: string | symbol): any {\n\t\tif (prop === 'table') {\n\t\t\treturn this.table;\n\t\t}\n\n\t\treturn columnObj[prop as keyof TColumn];\n\t}\n}\n\nexport class TableAliasProxyHandler<T extends Table | View> implements ProxyHandler<T> {\n\tstatic readonly [entityKind]: string = 'TableAliasProxyHandler';\n\n\tconstructor(private alias: string, private replaceOriginalName: boolean) {}\n\n\tget(target: T, prop: string | symbol): any {\n\t\tif (prop === Table.Symbol.IsAlias) {\n\t\t\treturn true;\n\t\t}\n\n\t\tif (prop === Table.Symbol.Name) {\n\t\t\treturn this.alias;\n\t\t}\n\n\t\tif (this.replaceOriginalName && prop === Table.Symbol.OriginalName) {\n\t\t\treturn this.alias;\n\t\t}\n\n\t\tif (prop === ViewBaseConfig) {\n\t\t\treturn {\n\t\t\t\t...target[ViewBaseConfig as keyof typeof target],\n\t\t\t\tname: this.alias,\n\t\t\t\tisAlias: true,\n\t\t\t};\n\t\t}\n\n\t\tif (prop === Table.Symbol.Columns) {\n\t\t\tconst columns = (target as Table)[Table.Symbol.Columns];\n\t\t\tif (!columns) {\n\t\t\t\treturn columns;\n\t\t\t}\n\n\t\t\tconst proxiedColumns: { [key: string]: any } = {};\n\n\t\t\tObject.keys(columns).map((key) => {\n\t\t\t\tproxiedColumns[key] = new Proxy(\n\t\t\t\t\tcolumns[key]!,\n\t\t\t\t\tnew ColumnAliasProxyHandler(new Proxy(target, this)),\n\t\t\t\t);\n\t\t\t});\n\n\t\t\treturn proxiedColumns;\n\t\t}\n\n\t\tconst value = target[prop as keyof typeof target];\n\t\tif (is(value, Column)) {\n\t\t\treturn new Proxy(value as AnyColumn, new ColumnAliasProxyHandler(new Proxy(target, this)));\n\t\t}\n\n\t\treturn value;\n\t}\n}\n\nexport class RelationTableAliasProxyHandler<T extends Relation> implements ProxyHandler<T> {\n\tstatic readonly [entityKind]: string = 'RelationTableAliasProxyHandler';\n\n\tconstructor(private alias: string) {}\n\n\tget(target: T, prop: string | symbol): any {\n\t\tif (prop === 'sourceTable') {\n\t\t\treturn aliasedTable(target.sourceTable, this.alias);\n\t\t}\n\n\t\treturn target[prop as keyof typeof target];\n\t}\n}\n\nexport function aliasedTable<T extends Table>(table: T, tableAlias: string): T {\n\treturn new Proxy(table, new TableAliasProxyHandler(tableAlias, false));\n}\n\nexport function aliasedRelation<T extends Relation>(relation: T, tableAlias: string): T {\n\treturn new Proxy(relation, new RelationTableAliasProxyHandler(tableAlias));\n}\n\nexport function aliasedTableColumn<T extends AnyColumn>(column: T, tableAlias: string): T {\n\treturn new Proxy(\n\t\tcolumn,\n\t\tnew ColumnAliasProxyHandler(new Proxy(column.table, new TableAliasProxyHandler(tableAlias, false))),\n\t);\n}\n\nexport function mapColumnsInAliasedSQLToAlias(query: SQL.Aliased, alias: string): SQL.Aliased {\n\treturn new SQL.Aliased(mapColumnsInSQLToAlias(query.sql, alias), query.fieldAlias);\n}\n\nexport function mapColumnsInSQLToAlias(query: SQL, alias: string): SQL {\n\treturn sql.join(query.queryChunks.map((c) => {\n\t\tif (is(c, Column)) {\n\t\t\treturn aliasedTableColumn(c, alias);\n\t\t}\n\t\tif (is(c, SQL)) {\n\t\t\treturn mapColumnsInSQLToAlias(c, alias);\n\t\t}\n\t\tif (is(c, SQL.Aliased)) {\n\t\t\treturn mapColumnsInAliasedSQLToAlias(c, alias);\n\t\t}\n\t\treturn c;\n\t}));\n}\n","import { entityKind } from '~/entity.ts';\n\nexport class DrizzleError extends Error {\n\tstatic readonly [entityKind]: string = 'DrizzleError';\n\n\tconstructor({ message, cause }: { message?: string; cause?: unknown }) {\n\t\tsuper(message);\n\t\tthis.name = 'DrizzleError';\n\t\tthis.cause = cause;\n\t}\n}\n\nexport class TransactionRollbackError extends DrizzleError {\n\tstatic readonly [entityKind]: string = 'TransactionRollbackError';\n\n\tconstructor() {\n\t\tsuper({ message: 'Rollback' });\n\t}\n}\n","import { entityKind } from '~/entity.ts';\nimport type { Column } from './column.ts';\nimport type { MySqlColumn } from './mysql-core/index.ts';\nimport type { PgColumn } from './pg-core/index.ts';\nimport type { SQL } from './sql/sql.ts';\nimport type { SQLiteColumn } from './sqlite-core/index.ts';\nimport type { Simplify } from './utils.ts';\n\nexport type ColumnDataType =\n\t| 'string'\n\t| 'number'\n\t| 'boolean'\n\t| 'array'\n\t| 'json'\n\t| 'date'\n\t| 'bigint'\n\t| 'custom'\n\t| 'buffer';\n\nexport type Dialect = 'pg' | 'mysql' | 'sqlite' | 'common';\n\nexport interface ColumnBuilderBaseConfig<TDataType extends ColumnDataType, TColumnType extends string> {\n\tname: string;\n\tdataType: TDataType;\n\tcolumnType: TColumnType;\n\tdata: unknown;\n\tdriverParam: unknown;\n\tenumValues: string[] | undefined;\n}\n\nexport type MakeColumnConfig<\n\tT extends ColumnBuilderBaseConfig<ColumnDataType, string>,\n\tTTableName extends string,\n> = {\n\tname: T['name'];\n\ttableName: TTableName;\n\tdataType: T['dataType'];\n\tcolumnType: T['columnType'];\n\tdata: T extends { $type: infer U } ? U : T['data'];\n\tdriverParam: T['driverParam'];\n\tnotNull: T extends { notNull: true } ? true : false;\n\thasDefault: T extends { hasDefault: true } ? true : false;\n\tenumValues: T['enumValues'];\n\tbaseColumn: T extends { baseBuilder: infer U extends ColumnBuilderBase } ? BuildColumn<TTableName, U, 'common'>\n\t\t: never;\n} & {};\n\nexport type ColumnBuilderTypeConfig<\n\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\tT extends ColumnBuilderBaseConfig<ColumnDataType, string>,\n\tTTypeConfig extends object = object,\n> = Simplify<\n\t& {\n\t\tbrand: 'ColumnBuilder';\n\t\tname: T['name'];\n\t\tdataType: T['dataType'];\n\t\tcolumnType: T['columnType'];\n\t\tdata: T['data'];\n\t\tdriverParam: T['driverParam'];\n\t\tnotNull: T extends { notNull: infer U } ? U : boolean;\n\t\thasDefault: T extends { hasDefault: infer U } ? U : boolean;\n\t\tenumValues: T['enumValues'];\n\t}\n\t& TTypeConfig\n>;\n\nexport type ColumnBuilderRuntimeConfig<TData, TRuntimeConfig extends object = object> = {\n\tname: string;\n\tnotNull: boolean;\n\tdefault: TData | SQL | undefined;\n\tdefaultFn: (() => TData | SQL) | undefined;\n\thasDefault: boolean;\n\tprimaryKey: boolean;\n\tisUnique: boolean;\n\tuniqueName: string | undefined;\n\tuniqueType: string | undefined;\n\tdataType: string;\n\tcolumnType: string;\n} & TRuntimeConfig;\n\nexport interface ColumnBuilderExtraConfig {\n\tprimaryKeyHasDefault?: boolean;\n}\n\nexport type NotNull<T extends ColumnBuilderBase> = T & {\n\t_: {\n\t\tnotNull: true;\n\t};\n};\n\nexport type HasDefault<T extends ColumnBuilderBase> = T & {\n\t_: {\n\t\thasDefault: true;\n\t};\n};\n\nexport type $Type<T extends ColumnBuilderBase, TType> = T & {\n\t_: {\n\t\t$type: TType;\n\t};\n};\n\nexport interface ColumnBuilderBase<\n\tT extends ColumnBuilderBaseConfig<ColumnDataType, string> = ColumnBuilderBaseConfig<ColumnDataType, string>,\n\tTTypeConfig extends object = object,\n> {\n\t_: ColumnBuilderTypeConfig<T, TTypeConfig>;\n}\n\n// To understand how to use `ColumnBuilder` and `AnyColumnBuilder`, see `Column` and `AnyColumn` documentation.\nexport abstract class ColumnBuilder<\n\tT extends ColumnBuilderBaseConfig<ColumnDataType, string> = ColumnBuilderBaseConfig<ColumnDataType, string>,\n\tTRuntimeConfig extends object = object,\n\tTTypeConfig extends object = object,\n\tTExtraConfig extends ColumnBuilderExtraConfig = ColumnBuilderExtraConfig,\n> implements ColumnBuilderBase<T, TTypeConfig> {\n\tstatic readonly [entityKind]: string = 'ColumnBuilder';\n\n\tdeclare _: ColumnBuilderTypeConfig<T, TTypeConfig>;\n\n\tprotected config: ColumnBuilderRuntimeConfig<T['data'], TRuntimeConfig>;\n\n\tconstructor(name: T['name'], dataType: T['dataType'], columnType: T['columnType']) {\n\t\tthis.config = {\n\t\t\tname,\n\t\t\tnotNull: false,\n\t\t\tdefault: undefined,\n\t\t\thasDefault: false,\n\t\t\tprimaryKey: false,\n\t\t\tisUnique: false,\n\t\t\tuniqueName: undefined,\n\t\t\tuniqueType: undefined,\n\t\t\tdataType,\n\t\t\tcolumnType,\n\t\t} as ColumnBuilderRuntimeConfig<T['data'], TRuntimeConfig>;\n\t}\n\n\t/**\n\t * Changes the data type of the column. Commonly used with `json` columns. Also, useful for branded types.\n\t *\n\t * @example\n\t * ```ts\n\t * const users = pgTable('users', {\n\t * \tid: integer('id').$type<UserId>().primaryKey(),\n\t * \tdetails: json('details').$type<UserDetails>().notNull(),\n\t * });\n\t * ```\n\t */\n\t$type<TType>(): $Type<this, TType> {\n\t\treturn this as $Type<this, TType>;\n\t}\n\n\t/**\n\t * Adds a `not null` clause to the column definition.\n\t *\n\t * Affects the `select` model of the table - columns *without* `not null` will be nullable on select.\n\t */\n\tnotNull(): NotNull<this> {\n\t\tthis.config.notNull = true;\n\t\treturn this as NotNull<this>;\n\t}\n\n\t/**\n\t * Adds a `default <value>` clause to the column definition.\n\t *\n\t * Affects the `insert` model of the table - columns *with* `default` are optional on insert.\n\t *\n\t * If you need to set a dynamic default value, use {@link $defaultFn} instead.\n\t */\n\tdefault(value: (this['_'] extends { $type: infer U } ? U : this['_']['data']) | SQL): HasDefault<this> {\n\t\tthis.config.default = value;\n\t\tthis.config.hasDefault = true;\n\t\treturn this as HasDefault<this>;\n\t}\n\n\t/**\n\t * Adds a dynamic default value to the column.\n\t * The function will be called when the row is inserted, and the returned value will be used as the column value.\n\t *\n\t * **Note:** This value does not affect the `drizzle-kit` behavior, it is only used at runtime in `drizzle-orm`.\n\t */\n\t$defaultFn(\n\t\tfn: () => (this['_'] extends { $type: infer U } ? U : this['_']['data']) | SQL,\n\t): HasDefault<this> {\n\t\tthis.config.defaultFn = fn;\n\t\tthis.config.hasDefault = true;\n\t\treturn this as HasDefault<this>;\n\t}\n\n\t/**\n\t * Alias for {@link $defaultFn}.\n\t */\n\t$default = this.$defaultFn;\n\n\t/**\n\t * Adds a `primary key` clause to the column definition. This implicitly makes the column `not null`.\n\t *\n\t * In SQLite, `integer primary key` implicitly makes the column auto-incrementing.\n\t */\n\tprimaryKey(): TExtraConfig['primaryKeyHasDefault'] extends true ? HasDefault<NotNull<this>> : NotNull<this> {\n\t\tthis.config.primaryKey = true;\n\t\tthis.config.notNull = true;\n\t\treturn this as TExtraConfig['primaryKeyHasDefault'] extends true ? HasDefault<NotNull<this>> : NotNull<this>;\n\t}\n}\n\nexport type BuildColumn<\n\tTTableName extends string,\n\tTBuilder extends ColumnBuilderBase,\n\tTDialect extends Dialect,\n> = TDialect extends 'pg' ? PgColumn<MakeColumnConfig<TBuilder['_'], TTableName>>\n\t: TDialect extends 'mysql' ? MySqlColumn<MakeColumnConfig<TBuilder['_'], TTableName>>\n\t: TDialect extends 'sqlite' ? SQLiteColumn<MakeColumnConfig<TBuilder['_'], TTableName>>\n\t: TDialect extends 'common' ? Column<MakeColumnConfig<TBuilder['_'], TTableName>>\n\t: never;\n\nexport type BuildColumns<\n\tTTableName extends string,\n\tTConfigMap extends Record<string, ColumnBuilderBase>,\n\tTDialect extends Dialect,\n> =\n\t& {\n\t\t[Key in keyof TConfigMap]: BuildColumn<TTableName, TConfigMap[Key], TDialect>;\n\t}\n\t& {};\n\nexport type ChangeColumnTableName<TColumn extends Column, TAlias extends string, TDialect extends Dialect> =\n\tTDialect extends 'pg' ? PgColumn<MakeColumnConfig<TColumn['_'], TAlias>>\n\t\t: TDialect extends 'mysql' ? MySqlColumn<MakeColumnConfig<TColumn['_'], TAlias>>\n\t\t: TDialect extends 'sqlite' ? SQLiteColumn<MakeColumnConfig<TColumn['_'], TAlias>>\n\t\t: never;\n","import type { BuildColumns } from '~/column-builder.ts';\nimport { entityKind } from '~/entity.ts';\nimport { Table, type TableConfig as TableConfigBase, type UpdateTableConfig } from '~/table.ts';\nimport type { CheckBuilder } from './checks.ts';\nimport type { PgColumn, PgColumnBuilder, PgColumnBuilderBase } from './columns/common.ts';\nimport type { ForeignKey, ForeignKeyBuilder } from './foreign-keys.ts';\nimport type { AnyIndexBuilder } from './indexes.ts';\nimport type { PrimaryKeyBuilder } from './primary-keys.ts';\nimport type { UniqueConstraintBuilder } from './unique-constraint.ts';\n\nexport type PgTableExtraConfig = Record<\n\tstring,\n\t| AnyIndexBuilder\n\t| CheckBuilder\n\t| ForeignKeyBuilder\n\t| PrimaryKeyBuilder\n\t| UniqueConstraintBuilder\n>;\n\nexport type TableConfig = TableConfigBase<PgColumn>;\n\n/** @internal */\nexport const InlineForeignKeys = Symbol.for('drizzle:PgInlineForeignKeys');\n\nexport class PgTable<T extends TableConfig = TableConfig> extends Table<T> {\n\tstatic readonly [entityKind]: string = 'PgTable';\n\n\t/** @internal */\n\tstatic override readonly Symbol = Object.assign({}, Table.Symbol, {\n\t\tInlineForeignKeys: InlineForeignKeys as typeof InlineForeignKeys,\n\t});\n\n\t/**@internal */\n\t[InlineForeignKeys]: ForeignKey[] = [];\n\n\t/** @internal */\n\toverride [Table.Symbol.ExtraConfigBuilder]: ((self: Record<string, PgColumn>) => PgTableExtraConfig) | undefined =\n\t\tundefined;\n}\n\nexport type AnyPgTable<TPartial extends Partial<TableConfig> = {}> = PgTable<UpdateTableConfig<TableConfig, TPartial>>;\n\nexport type PgTableWithColumns<T extends TableConfig> =\n\t& PgTable<T>\n\t& {\n\t\t[Key in keyof T['columns']]: T['columns'][Key];\n\t};\n\n/** @internal */\nexport function pgTableWithSchema<\n\tTTableName extends string,\n\tTSchemaName extends string | undefined,\n\tTColumnsMap extends Record<string, PgColumnBuilderBase>,\n>(\n\tname: TTableName,\n\tcolumns: TColumnsMap,\n\textraConfig: ((self: BuildColumns<TTableName, TColumnsMap, 'pg'>) => PgTableExtraConfig) | undefined,\n\tschema: TSchemaName,\n\tbaseName = name,\n): PgTableWithColumns<{\n\tname: TTableName;\n\tschema: TSchemaName;\n\tcolumns: BuildColumns<TTableName, TColumnsMap, 'pg'>;\n\tdialect: 'pg';\n}> {\n\tconst rawTable = new PgTable<{\n\t\tname: TTableName;\n\t\tschema: TSchemaName;\n\t\tcolumns: BuildColumns<TTableName, TColumnsMap, 'pg'>;\n\t\tdialect: 'pg';\n\t}>(name, schema, baseName);\n\n\tconst builtColumns = Object.fromEntries(\n\t\tObject.entries(columns).map(([name, colBuilderBase]) => {\n\t\t\tconst colBuilder = colBuilderBase as PgColumnBuilder;\n\t\t\tconst column = colBuilder.build(rawTable);\n\t\t\trawTable[InlineForeignKeys].push(...colBuilder.buildForeignKeys(column, rawTable));\n\t\t\treturn [name, column];\n\t\t}),\n\t) as unknown as BuildColumns<TTableName, TColumnsMap, 'pg'>;\n\n\tconst table = Object.assign(rawTable, builtColumns);\n\n\ttable[Table.Symbol.Columns] = builtColumns;\n\n\tif (extraConfig) {\n\t\ttable[PgTable.Symbol.ExtraConfigBuilder] = extraConfig as any;\n\t}\n\n\treturn table;\n}\n\nexport interface PgTableFn<TSchema extends string | undefined = undefined> {\n\t<\n\t\tTTableName extends string,\n\t\tTColumnsMap extends Record<string, PgColumnBuilderBase>,\n\t>(\n\t\tname: TTableName,\n\t\tcolumns: TColumnsMap,\n\t\textraConfig?: (self: BuildColumns<TTableName, TColumnsMap, 'pg'>) => PgTableExtraConfig,\n\t): PgTableWithColumns<{\n\t\tname: TTableName;\n\t\tschema: TSchema;\n\t\tcolumns: BuildColumns<TTableName, TColumnsMap, 'pg'>;\n\t\tdialect: 'pg';\n\t}>;\n}\n\nexport const pgTable: PgTableFn = (name, columns, extraConfig) => {\n\treturn pgTableWithSchema(name, columns, extraConfig, undefined);\n};\n\nexport function pgTableCreator(customizeTableName: (name: string) => string): PgTableFn {\n\treturn (name, columns, extraConfig) => {\n\t\treturn pgTableWithSchema(customizeTableName(name) as typeof name, columns, extraConfig, undefined, name);\n\t};\n}\n","import { entityKind } from '~/entity.ts';\nimport type { AnyPgColumn, PgColumn } from './columns/index.ts';\nimport { PgTable } from './table.ts';\n\nexport type UpdateDeleteAction = 'cascade' | 'restrict' | 'no action' | 'set null' | 'set default';\n\nexport type Reference = () => {\n\treadonly name?: string;\n\treadonly columns: PgColumn[];\n\treadonly foreignTable: PgTable;\n\treadonly foreignColumns: PgColumn[];\n};\n\nexport class ForeignKeyBuilder {\n\tstatic readonly [entityKind]: string = 'PgForeignKeyBuilder';\n\n\t/** @internal */\n\treference: Reference;\n\n\t/** @internal */\n\t_onUpdate: UpdateDeleteAction | undefined = 'no action';\n\n\t/** @internal */\n\t_onDelete: UpdateDeleteAction | undefined = 'no action';\n\n\tconstructor(\n\t\tconfig: () => {\n\t\t\tname?: string;\n\t\t\tcolumns: PgColumn[];\n\t\t\tforeignColumns: PgColumn[];\n\t\t},\n\t\tactions?: {\n\t\t\tonUpdate?: UpdateDeleteAction;\n\t\t\tonDelete?: UpdateDeleteAction;\n\t\t} | undefined,\n\t) {\n\t\tthis.reference = () => {\n\t\t\tconst { name, columns, foreignColumns } = config();\n\t\t\treturn { name, columns, foreignTable: foreignColumns[0]!.table as PgTable, foreignColumns };\n\t\t};\n\t\tif (actions) {\n\t\t\tthis._onUpdate = actions.onUpdate;\n\t\t\tthis._onDelete = actions.onDelete;\n\t\t}\n\t}\n\n\tonUpdate(action: UpdateDeleteAction): this {\n\t\tthis._onUpdate = action === undefined ? 'no action' : action;\n\t\treturn this;\n\t}\n\n\tonDelete(action: UpdateDeleteAction): this {\n\t\tthis._onDelete = action === undefined ? 'no action' : action;\n\t\treturn this;\n\t}\n\n\t/** @internal */\n\tbuild(table: PgTable): ForeignKey {\n\t\treturn new ForeignKey(table, this);\n\t}\n}\n\nexport type AnyForeignKeyBuilder = ForeignKeyBuilder;\n\nexport class ForeignKey {\n\tstatic readonly [entityKind]: string = 'PgForeignKey';\n\n\treadonly reference: Reference;\n\treadonly onUpdate: UpdateDeleteAction | undefined;\n\treadonly onDelete: UpdateDeleteAction | undefined;\n\n\tconstructor(readonly table: PgTable, builder: ForeignKeyBuilder) {\n\t\tthis.reference = builder.reference;\n\t\tthis.onUpdate = builder._onUpdate;\n\t\tthis.onDelete = builder._onDelete;\n\t}\n\n\tgetName(): string {\n\t\tconst { name, columns, foreignColumns } = this.reference();\n\t\tconst columnNames = columns.map((column) => column.name);\n\t\tconst foreignColumnNames = foreignColumns.map((column) => column.name);\n\t\tconst chunks = [\n\t\t\tthis.table[PgTable.Symbol.Name],\n\t\t\t...columnNames,\n\t\t\tforeignColumns[0]!.table[PgTable.Symbol.Name],\n\t\t\t...foreignColumnNames,\n\t\t];\n\t\treturn name ?? `${chunks.join('_')}_fk`;\n\t}\n}\n\ntype ColumnsWithTable<\n\tTTableName extends string,\n\tTColumns extends PgColumn[],\n> = { [Key in keyof TColumns]: AnyPgColumn<{ tableName: TTableName }> };\n\nexport function foreignKey<\n\tTTableName extends string,\n\tTForeignTableName extends string,\n\tTColumns extends [AnyPgColumn<{ tableName: TTableName }>, ...AnyPgColumn<{ tableName: TTableName }>[]],\n>(\n\tconfig: {\n\t\tname?: string;\n\t\tcolumns: TColumns;\n\t\tforeignColumns: ColumnsWithTable<TForeignTableName, TColumns>;\n\t},\n): ForeignKeyBuilder {\n\tfunction mappedConfig() {\n\t\tconst { name, columns, foreignColumns } = config;\n\t\treturn {\n\t\t\tname,\n\t\t\tcolumns,\n\t\t\tforeignColumns,\n\t\t};\n\t}\n\n\treturn new ForeignKeyBuilder(mappedConfig);\n}\n","import { entityKind } from '~/entity.ts';\nimport type { PgColumn } from './columns/index.ts';\nimport { PgTable } from './table.ts';\n\nexport function unique(name?: string): UniqueOnConstraintBuilder {\n\treturn new UniqueOnConstraintBuilder(name);\n}\n\nexport function uniqueKeyName(table: PgTable, columns: string[]) {\n\treturn `${table[PgTable.Symbol.Name]}_${columns.join('_')}_unique`;\n}\n\nexport class UniqueConstraintBuilder {\n\tstatic readonly [entityKind]: string = 'PgUniqueConstraintBuilder';\n\n\t/** @internal */\n\tcolumns: PgColumn[];\n\t/** @internal */\n\tnullsNotDistinctConfig = false;\n\n\tconstructor(\n\t\tcolumns: PgColumn[],\n\t\tprivate name?: string,\n\t) {\n\t\tthis.columns = columns;\n\t}\n\n\tnullsNotDistinct() {\n\t\tthis.nullsNotDistinctConfig = true;\n\t\treturn this;\n\t}\n\n\t/** @internal */\n\tbuild(table: PgTable): UniqueConstraint {\n\t\treturn new UniqueConstraint(table, this.columns, this.nullsNotDistinctConfig, this.name);\n\t}\n}\n\nexport class UniqueOnConstraintBuilder {\n\tstatic readonly [entityKind]: string = 'PgUniqueOnConstraintBuilder';\n\n\t/** @internal */\n\tname?: string;\n\n\tconstructor(\n\t\tname?: string,\n\t) {\n\t\tthis.name = name;\n\t}\n\n\ton(...columns: [PgColumn, ...PgColumn[]]) {\n\t\treturn new UniqueConstraintBuilder(columns, this.name);\n\t}\n}\n\nexport class UniqueConstraint {\n\tstatic readonly [entityKind]: string = 'PgUniqueConstraint';\n\n\treadonly columns: PgColumn[];\n\treadonly name?: string;\n\treadonly nullsNotDistinct: boolean = false;\n\n\tconstructor(readonly table: PgTable, columns: PgColumn[], nullsNotDistinct: boolean, name?: string) {\n\t\tthis.columns = columns;\n\t\tthis.name = name ?? uniqueKeyName(this.table, this.columns.map((column) => column.name));\n\t\tthis.nullsNotDistinct = nullsNotDistinct;\n\t}\n\n\tgetName() {\n\t\treturn this.name;\n\t}\n}\n","function parsePgArrayValue(arrayString: string, startFrom: number, inQuotes: boolean): [string, number] {\n\tfor (let i = startFrom; i < arrayString.length; i++) {\n\t\tconst char = arrayString[i];\n\n\t\tif (char === '\\\\') {\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (char === '\"') {\n\t\t\treturn [arrayString.slice(startFrom, i).replace(/\\\\/g, ''), i + 1];\n\t\t}\n\n\t\tif (inQuotes) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (char === ',' || char === '}') {\n\t\t\treturn [arrayString.slice(startFrom, i).replace(/\\\\/g, ''), i];\n\t\t}\n\t}\n\n\treturn [arrayString.slice(startFrom).replace(/\\\\/g, ''), arrayString.length];\n}\n\nexport function parsePgNestedArray(arrayString: string, startFrom = 0): [any[], number] {\n\tconst result: any[] = [];\n\tlet i = startFrom;\n\tlet lastCharIsComma = false;\n\n\twhile (i < arrayString.length) {\n\t\tconst char = arrayString[i];\n\n\t\tif (char === ',') {\n\t\t\tif (lastCharIsComma || i === startFrom) {\n\t\t\t\tresult.push('');\n\t\t\t}\n\t\t\tlastCharIsComma = true;\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tlastCharIsComma = false;\n\n\t\tif (char === '\\\\') {\n\t\t\ti += 2;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (char === '\"') {\n\t\t\tconst [value, startFrom] = parsePgArrayValue(arrayString, i + 1, true);\n\t\t\tresult.push(value);\n\t\t\ti = startFrom;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (char === '}') {\n\t\t\treturn [result, i + 1];\n\t\t}\n\n\t\tif (char === '{') {\n\t\t\tconst [value, startFrom] = parsePgNestedArray(arrayString, i + 1);\n\t\t\tresult.push(value);\n\t\t\ti = startFrom;\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst [value, newStartFrom] = parsePgArrayValue(arrayString, i, false);\n\t\tresult.push(value);\n\t\ti = newStartFrom;\n\t}\n\n\treturn [result, i];\n}\n\nexport function parsePgArray(arrayString: string): any[] {\n\tconst [result] = parsePgNestedArray(arrayString, 1);\n\treturn result;\n}\n\nexport function makePgArray(array: any[]): string {\n\treturn `{${\n\t\tarray.map((item) => {\n\t\t\tif (Array.isArray(item)) {\n\t\t\t\treturn makePgArray(item);\n\t\t\t}\n\n\t\t\tif (typeof item === 'string') {\n\t\t\t\treturn `\"${item.replace(/\\\\/g, '\\\\\\\\').replace(/\"/g, '\\\\\"')}\"`;\n\t\t\t}\n\n\t\t\treturn `${item}`;\n\t\t}).join(',')\n\t}}`;\n}\n","import type {\n\tColumnBuilderBase,\n\tColumnBuilderBaseConfig,\n\tColumnBuilderExtraConfig,\n\tColumnBuilderRuntimeConfig,\n\tColumnDataType,\n\tMakeColumnConfig,\n} from '~/column-builder.ts';\nimport { ColumnBuilder } from '~/column-builder.ts';\nimport type { ColumnBaseConfig } from '~/column.ts';\nimport { Column } from '~/column.ts';\nimport { entityKind, is } from '~/entity.ts';\nimport type { Update } from '~/utils.ts';\n\nimport type { ForeignKey, UpdateDeleteAction } from '~/pg-core/foreign-keys.ts';\nimport { ForeignKeyBuilder } from '~/pg-core/foreign-keys.ts';\nimport type { AnyPgTable, PgTable } from '~/pg-core/table.ts';\nimport { uniqueKeyName } from '../unique-constraint.ts';\nimport { makePgArray, parsePgArray } from '../utils/array.ts';\nimport { iife } from '~/tracing-utils.ts';\n\nexport interface ReferenceConfig {\n\tref: () => PgColumn;\n\tactions: {\n\t\tonUpdate?: UpdateDeleteAction;\n\t\tonDelete?: UpdateDeleteAction;\n\t};\n}\n\nexport interface PgColumnBuilderBase<\n\tT extends ColumnBuilderBaseConfig<ColumnDataType, string> = ColumnBuilderBaseConfig<ColumnDataType, string>,\n\tTTypeConfig extends object = object,\n> extends ColumnBuilderBase<T, TTypeConfig & { dialect: 'pg' }> {}\n\nexport abstract class PgColumnBuilder<\n\tT extends ColumnBuilderBaseConfig<ColumnDataType, string> = ColumnBuilderBaseConfig<ColumnDataType, string>,\n\tTRuntimeConfig extends object = object,\n\tTTypeConfig extends object = object,\n\tTExtraConfig extends ColumnBuilderExtraConfig = ColumnBuilderExtraConfig,\n> extends ColumnBuilder<T, TRuntimeConfig, TTypeConfig & { dialect: 'pg' }, TExtraConfig>\n\timplements PgColumnBuilderBase<T, TTypeConfig>\n{\n\tprivate foreignKeyConfigs: ReferenceConfig[] = [];\n\n\tstatic readonly [entityKind]: string = 'PgColumnBuilder';\n\n\tarray(size?: number): PgArrayBuilder<\n\t\t& {\n\t\t\tname: T['name'];\n\t\t\tdataType: 'array';\n\t\t\tcolumnType: 'PgArray';\n\t\t\tdata: T['data'][];\n\t\t\tdriverParam: T['driverParam'][] | string;\n\t\t\tenumValues: T['enumValues'];\n\t\t}\n\t\t& (T extends { notNull: true } ? { notNull: true } : {})\n\t\t& (T extends { hasDefault: true } ? { hasDefault: true } : {}),\n\t\tT\n\t> {\n\t\treturn new PgArrayBuilder(this.config.name, this as PgColumnBuilder<any, any>, size);\n\t}\n\n\treferences(\n\t\tref: ReferenceConfig['ref'],\n\t\tactions: ReferenceConfig['actions'] = {},\n\t): this {\n\t\tthis.foreignKeyConfigs.push({ ref, actions });\n\t\treturn this;\n\t}\n\n\tunique(\n\t\tname?: string,\n\t\tconfig?: { nulls: 'distinct' | 'not distinct' },\n\t): this {\n\t\tthis.config.isUnique = true;\n\t\tthis.config.uniqueName = name;\n\t\tthis.config.uniqueType = config?.nulls;\n\t\treturn this;\n\t}\n\n\t/** @internal */\n\tbuildForeignKeys(column: PgColumn, table: PgTable): ForeignKey[] {\n\t\treturn this.foreignKeyConfigs.map(({ ref, actions }) => {\n\t\t\treturn iife(\n\t\t\t\t(ref, actions) => {\n\t\t\t\t\tconst builder = new ForeignKeyBuilder(() => {\n\t\t\t\t\t\tconst foreignColumn = ref();\n\t\t\t\t\t\treturn { columns: [column], foreignColumns: [foreignColumn] };\n\t\t\t\t\t});\n\t\t\t\t\tif (actions.onUpdate) {\n\t\t\t\t\t\tbuilder.onUpdate(actions.onUpdate);\n\t\t\t\t\t}\n\t\t\t\t\tif (actions.onDelete) {\n\t\t\t\t\t\tbuilder.onDelete(actions.onDelete);\n\t\t\t\t\t}\n\t\t\t\t\treturn builder.build(table);\n\t\t\t\t},\n\t\t\t\tref,\n\t\t\t\tactions,\n\t\t\t);\n\t\t});\n\t}\n\n\t/** @internal */\n\tabstract build<TTableName extends string>(\n\t\ttable: AnyPgTable<{ name: TTableName }>,\n\t): PgColumn<MakeColumnConfig<T, TTableName>>;\n}\n\n// To understand how to use `PgColumn` and `PgColumn`, see `Column` and `AnyColumn` documentation.\nexport abstract class PgColumn<\n\tT extends ColumnBaseConfig<ColumnDataType, string> = ColumnBaseConfig<ColumnDataType, string>,\n\tTRuntimeConfig extends object = {},\n\tTTypeConfig extends object = {},\n> extends Column<T, TRuntimeConfig, TTypeConfig & { dialect: 'pg' }> {\n\tstatic readonly [entityKind]: string = 'PgColumn';\n\n\tconstructor(\n\t\toverride readonly table: PgTable,\n\t\tconfig: ColumnBuilderRuntimeConfig<T['data'], TRuntimeConfig>,\n\t) {\n\t\tif (!config.uniqueName) {\n\t\t\tconfig.uniqueName = uniqueKeyName(table, [config.name]);\n\t\t}\n\t\tsuper(table, config);\n\t}\n}\n\nexport type AnyPgColumn<TPartial extends Partial<ColumnBaseConfig<ColumnDataType, string>> = {}> = PgColumn<\n\tRequired<Update<ColumnBaseConfig<ColumnDataType, string>, TPartial>>\n>;\n\nexport class PgArrayBuilder<\n\tT extends ColumnBuilderBaseConfig<'array', 'PgArray'>,\n\tTBase extends ColumnBuilderBaseConfig<ColumnDataType, string>,\n> extends PgColumnBuilder<\n\tT,\n\t{\n\t\tbaseBuilder: PgColumnBuilder<TBase>;\n\t\tsize: number | undefined;\n\t},\n\t{\n\t\tbaseBuilder: PgColumnBuilder<TBase>;\n\t}\n> {\n\tstatic override readonly [entityKind] = 'PgArrayBuilder';\n\n\tconstructor(\n\t\tname: string,\n\t\tbaseBuilder: PgArrayBuilder<T, TBase>['config']['baseBuilder'],\n\t\tsize: number | undefined,\n\t) {\n\t\tsuper(name, 'array', 'PgArray');\n\t\tthis.config.baseBuilder = baseBuilder;\n\t\tthis.config.size = size;\n\t}\n\n\t/** @internal */\n\toverride build<TTableName extends string>(\n\t\ttable: AnyPgTable<{ name: TTableName }>,\n\t): PgArray<MakeColumnConfig<T, TTableName>, TBase> {\n\t\tconst baseColumn = this.config.baseBuilder.build(table);\n\t\treturn new PgArray<MakeColumnConfig<T, TTableName>, TBase>(\n\t\t\ttable as AnyPgTable<{ name: MakeColumnConfig<T, TTableName>['tableName'] }>,\n\t\t\tthis.config as ColumnBuilderRuntimeConfig<any, any>,\n\t\t\tbaseColumn,\n\t\t);\n\t}\n}\n\nexport class PgArray<\n\tT extends ColumnBaseConfig<'array', 'PgArray'>,\n\tTBase extends ColumnBuilderBaseConfig<ColumnDataType, string>,\n> extends PgColumn<T> {\n\treadonly size: number | undefined;\n\n\tstatic readonly [entityKind]: string = 'PgArray';\n\n\tconstructor(\n\t\ttable: AnyPgTable<{ name: T['tableName'] }>,\n\t\tconfig: PgArrayBuilder<T, TBase>['config'],\n\t\treadonly baseColumn: PgColumn,\n\t\treadonly range?: [number | undefined, number | undefined],\n\t) {\n\t\tsuper(table, config);\n\t\tthis.size = config.size;\n\t}\n\n\tgetSQLType(): string {\n\t\treturn `${this.baseColumn.getSQLType()}[${typeof this.size === 'number' ? this.size : ''}]`;\n\t}\n\n\toverride mapFromDriverValue(value: unknown[] | string): T['data'] {\n\t\tif (typeof value === 'string') {\n\t\t\t// Thank you node-postgres for not parsing enum arrays\n\t\t\tvalue = parsePgArray(value);\n\t\t}\n\t\treturn value.map((v) => this.baseColumn.mapFromDriverValue(v));\n\t}\n\n\toverride mapToDriverValue(value: unknown[], isNestedArray = false): unknown[] | string {\n\t\tconst a = value.map((v) =>\n\t\t\tv === null\n\t\t\t\t? null\n\t\t\t\t: is(this.baseColumn, PgArray)\n\t\t\t\t? this.baseColumn.mapToDriverValue(v as unknown[], true)\n\t\t\t\t: this.baseColumn.mapToDriverValue(v)\n\t\t);\n\t\tif (isNestedArray) return a;\n\t\treturn makePgArray(a);\n\t}\n}\n","import type { ColumnBuilderBaseConfig, ColumnBuilderRuntimeConfig, MakeColumnConfig } from '~/column-builder.ts';\nimport type { ColumnBaseConfig } from '~/column.ts';\nimport { entityKind } from '~/entity.ts';\nimport type { AnyPgTable } from '~/pg-core/table.ts';\nimport { PgColumn, PgColumnBuilder } from './common.ts';\n\nexport type PgBooleanBuilderInitial<TName extends string> = PgBooleanBuilder<{\n\tname: TName;\n\tdataType: 'boolean';\n\tcolumnType: 'PgBoolean';\n\tdata: boolean;\n\tdriverParam: boolean;\n\tenumValues: undefined;\n}>;\n\nexport class PgBooleanBuilder<T extends ColumnBuilderBaseConfig<'boolean', 'PgBoolean'>> extends PgColumnBuilder<T> {\n\tstatic readonly [entityKind]: string = 'PgBooleanBuilder';\n\n\tconstructor(name: T['name']) {\n\t\tsuper(name, 'boolean', 'PgBoolean');\n\t}\n\n\t/** @internal */\n\toverride build<TTableName extends string>(\n\t\ttable: AnyPgTable<{ name: TTableName }>,\n\t): PgBoolean<MakeColumnConfig<T, TTableName>> {\n\t\treturn new PgBoolean<MakeColumnConfig<T, TTableName>>(table, this.config as ColumnBuilderRuntimeConfig<any, any>);\n\t}\n}\n\nexport class PgBoolean<T extends ColumnBaseConfig<'boolean', 'PgBoolean'>> extends PgColumn<T> {\n\tstatic readonly [entityKind]: string = 'PgBoolean';\n\n\tgetSQLType(): string {\n\t\treturn 'boolean';\n\t}\n}\n\nexport function boolean<TName extends string>(name: TName): PgBooleanBuilderInitial<TName> {\n\treturn new PgBooleanBuilder(name);\n}\n","import type { ColumnBuilderBaseConfig, ColumnDataType } from '~/column-builder.ts';\nimport { entityKind } from '~/entity.ts';\nimport { sql } from '~/sql/sql.ts';\nimport { PgColumnBuilder } from './common.ts';\n\nexport abstract class PgDateColumnBaseBuilder<\n\tT extends ColumnBuilderBaseConfig<ColumnDataType, string>,\n\tTRuntimeConfig extends object = object,\n> extends PgColumnBuilder<T, TRuntimeConfig> {\n\tstatic readonly [entityKind]: string = 'PgDateColumnBaseBuilder';\n\n\tdefaultNow() {\n\t\treturn this.default(sql`now()`);\n\t}\n}\n","import type { ColumnBuilderBaseConfig, ColumnBuilderRuntimeConfig, MakeColumnConfig } from '~/column-builder.ts';\nimport type { ColumnBaseConfig } from '~/column.ts';\nimport { entityKind } from '~/entity.ts';\nimport type { AnyPgTable } from '~/pg-core/table.ts';\nimport { PgColumn } from './common.ts';\nimport { PgDateColumnBaseBuilder } from './date.common.ts';\n\nexport type PgDateBuilderInitial<TName extends string> = PgDateBuilder<{\n\tname: TName;\n\tdataType: 'date';\n\tcolumnType: 'PgDate';\n\tdata: Date;\n\tdriverParam: string;\n\tenumValues: undefined;\n}>;\n\nexport class PgDateBuilder<T extends ColumnBuilderBaseConfig<'date', 'PgDate'>> extends PgDateColumnBaseBuilder<T> {\n\tstatic readonly [entityKind]: string = 'PgDateBuilder';\n\n\tconstructor(name: T['name']) {\n\t\tsuper(name, 'date', 'PgDate');\n\t}\n\n\t/** @internal */\n\toverride build<TTableName extends string>(\n\t\ttable: AnyPgTable<{ name: TTableName }>,\n\t): PgDate<MakeColumnConfig<T, TTableName>> {\n\t\treturn new PgDate<MakeColumnConfig<T, TTableName>>(table, this.config as ColumnBuilderRuntimeConfig<any, any>);\n\t}\n}\n\nexport class PgDate<T extends ColumnBaseConfig<'date', 'PgDate'>> extends PgColumn<T> {\n\tstatic readonly [entityKind]: string = 'PgDate';\n\n\tgetSQLType(): string {\n\t\treturn 'date';\n\t}\n\n\toverride mapFromDriverValue(value: string): Date {\n\t\treturn new Date(value);\n\t}\n\n\toverride mapToDriverValue(value: Date): string {\n\t\treturn value.toISOString();\n\t}\n}\n\nexport type PgDateStringBuilderInitial<TName extends string> = PgDateStringBuilder<{\n\tname: TName;\n\tdataType: 'string';\n\tcolumnType: 'PgDateString';\n\tdata: string;\n\tdriverParam: string;\n\tenumValues: undefined;\n}>;\n\nexport class PgDateStringBuilder<T extends ColumnBuilderBaseConfig<'string', 'PgDateString'>>\n\textends PgDateColumnBaseBuilder<T>\n{\n\tstatic readonly [entityKind]: string = 'PgDateStringBuilder';\n\n\tconstructor(name: T['name']) {\n\t\tsuper(name, 'string', 'PgDateString');\n\t}\n\n\t/** @internal */\n\toverride build<TTableName extends string>(\n\t\ttable: AnyPgTable<{ name: TTableName }>,\n\t): PgDateString<MakeColumnConfig<T, TTableName>> {\n\t\treturn new PgDateString<MakeColumnConfig<T, TTableName>>(\n\t\t\ttable,\n\t\t\tthis.config as ColumnBuilderRuntimeConfig<any, any>,\n\t\t);\n\t}\n}\n\nexport class PgDateString<T extends ColumnBaseConfig<'string', 'PgDateString'>> extends PgColumn<T> {\n\tstatic readonly [entityKind]: string = 'PgDateString';\n\n\tgetSQLType(): string {\n\t\treturn 'date';\n\t}\n}\n\nexport function date<TName extends string>(\n\tname: TName,\n\tconfig?: { mode: 'string' },\n): PgDateStringBuilderInitial<TName>;\nexport function date<TName extends string>(TName: TName, config?: { mode: 'date' }): PgDateBuilderInitial<TName>;\nexport function date<TName extends string>(name: TName, config?: { mode: 'date' | 'string' }) {\n\tif (config?.mode === 'date') {\n\t\treturn new PgDateBuilder(name);\n\t}\n\treturn new PgDateStringBuilder(name);\n}\n","import type { ColumnBuilderBaseConfig, ColumnBuilderRuntimeConfig, MakeColumnConfig } from '~/column-builder.ts';\nimport type { ColumnBaseConfig } from '~/column.ts';\nimport { entityKind } from '~/entity.ts';\nimport type { AnyPgTable } from '~/pg-core/table.ts';\nimport type { Writable } from '~/utils.ts';\nimport { PgColumn, PgColumnBuilder } from './common.ts';\n\nexport type PgEnumColumnBuilderInitial<TName extends string, TValues extends [string, ...string[]]> =\n\tPgEnumColumnBuilder<{\n\t\tname: TName;\n\t\tdataType: 'string';\n\t\tcolumnType: 'PgEnumColumn';\n\t\tdata: TValues[number];\n\t\tenumValues: TValues;\n\t\tdriverParam: string;\n\t}>;\n\nconst isPgEnumSym = Symbol.for('drizzle:isPgEnum');\nexport interface PgEnum<TValues extends [string, ...string[]]> {\n\t<TName extends string>(name: TName): PgEnumColumnBuilderInitial<TName, TValues>;\n\n\treadonly enumName: string;\n\treadonly enumValues: TValues;\n\t/** @internal */\n\t[isPgEnumSym]: true;\n}\n\nexport function isPgEnum(obj: unknown): obj is PgEnum<[string, ...string[]]> {\n\treturn !!obj && typeof obj === 'function' && isPgEnumSym in obj && obj[isPgEnumSym] === true;\n}\n\nexport class PgEnumColumnBuilder<\n\tT extends ColumnBuilderBaseConfig<'string', 'PgEnumColumn'> & { enumValues: [string, ...string[]] },\n> extends PgColumnBuilder<T, { enum: PgEnum<T['enumValues']> }> {\n\tstatic readonly [entityKind]: string = 'PgEnumColumnBuilder';\n\n\tconstructor(name: string, enumInstance: PgEnum<T['enumValues']>) {\n\t\tsuper(name, 'string', 'PgEnumColumn');\n\t\tthis.config.enum = enumInstance;\n\t}\n\n\t/** @internal */\n\toverride build<TTableName extends string>(\n\t\ttable: AnyPgTable<{ name: TTableName }>,\n\t): PgEnumColumn<MakeColumnConfig<T, TTableName>> {\n\t\treturn new PgEnumColumn<MakeColumnConfig<T, TTableName>>(\n\t\t\ttable,\n\t\t\tthis.config as ColumnBuilderRuntimeConfig<any, any>,\n\t\t);\n\t}\n}\n\nexport class PgEnumColumn<T extends ColumnBaseConfig<'string', 'PgEnumColumn'> & { enumValues: [string, ...string[]] }>\n\textends PgColumn<T, { enum: PgEnum<T['enumValues']> }>\n{\n\tstatic readonly [entityKind]: string = 'PgEnumColumn';\n\n\treadonly enum = this.config.enum;\n\toverride readonly enumValues = this.config.enum.enumValues;\n\n\tconstructor(\n\t\ttable: AnyPgTable<{ name: T['tableName'] }>,\n\t\tconfig: PgEnumColumnBuilder<T>['config'],\n\t) {\n\t\tsuper(table, config);\n\t\tthis.enum = config.enum;\n\t}\n\n\tgetSQLType(): string {\n\t\treturn this.enum.enumName;\n\t}\n}\n\n// Gratitude to zod for the enum function types\nexport function pgEnum<U extends string, T extends Readonly<[U, ...U[]]>>(\n\tenumName: string,\n\tvalues: T | Writable<T>,\n): PgEnum<Writable<T>> {\n\tconst enumInstance = Object.assign(\n\t\t<TName extends string>(name: TName): PgEnumColumnBuilderInitial<TName, Writable<T>> =>\n\t\t\tnew PgEnumColumnBuilder(name, enumInstance),\n\t\t{\n\t\t\tenumName,\n\t\t\tenumValues: values,\n\t\t\t[isPgEnumSym]: true,\n\t\t} as const,\n\t);\n\n\treturn enumInstance;\n}\n","import type { ColumnBuilderBaseConfig, ColumnBuilderRuntimeConfig, MakeColumnConfig } from '~/column-builder.ts';\nimport type { ColumnBaseConfig } from '~/column.ts';\nimport { entityKind } from '~/entity.ts';\nimport type { AnyPgTable } from '../table.ts';\nimport { PgColumn, PgColumnBuilder } from './common.ts';\n\ntype PgIntegerBuilderInitial<TName extends string> = PgIntegerBuilder<{\n\tname: TName;\n\tdataType: 'number';\n\tcolumnType: 'PgInteger';\n\tdata: number;\n\tdriverParam: number | string;\n\tenumValues: undefined;\n}>;\n\nexport class PgIntegerBuilder<T extends ColumnBuilderBaseConfig<'number', 'PgInteger'>> extends PgColumnBuilder<T> {\n\tstatic readonly [entityKind]: string = 'PgIntegerBuilder';\n\n\tconstructor(name: T['name']) {\n\t\tsuper(name, 'number', 'PgInteger');\n\t}\n\n\t/** @internal */\n\toverride build<TTableName extends string>(\n\t\ttable: AnyPgTable<{ name: TTableName }>,\n\t): PgInteger<MakeColumnConfig<T, TTableName>> {\n\t\treturn new PgInteger<MakeColumnConfig<T, TTableName>>(table, this.config as ColumnBuilderRuntimeConfig<any, any>);\n\t}\n}\n\nexport class PgInteger<T extends ColumnBaseConfig<'number', 'PgInteger'>> extends PgColumn<T> {\n\tstatic readonly [entityKind]: string = 'PgInteger';\n\n\tgetSQLType(): string {\n\t\treturn 'integer';\n\t}\n\n\toverride mapFromDriverValue(value: number | string): number {\n\t\tif (typeof value === 'string') {\n\t\t\treturn Number.parseInt(value);\n\t\t}\n\t\treturn value;\n\t}\n}\n\nexport function integer<TName extends string>(name: TName): PgIntegerBuilderInitial<TName> {\n\treturn new PgIntegerBuilder(name);\n}\n","import type { ColumnBuilderBaseConfig, ColumnBuilderRuntimeConfig, MakeColumnConfig } from '~/column-builder.ts';\nimport type { ColumnBaseConfig } from '~/column.ts';\nimport { entityKind } from '~/entity.ts';\nimport type { AnyPgTable } from '~/pg-core/table.ts';\nimport { PgColumn, PgColumnBuilder } from './common.ts';\n\nexport type PgJsonBuilderInitial<TName extends string> = PgJsonBuilder<{\n\tname: TName;\n\tdataType: 'json';\n\tcolumnType: 'PgJson';\n\tdata: unknown;\n\tdriverParam: unknown;\n\tenumValues: undefined;\n}>;\n\nexport class PgJsonBuilder<T extends ColumnBuilderBaseConfig<'json', 'PgJson'>> extends PgColumnBuilder<\n\tT\n> {\n\tstatic readonly [entityKind]: string = 'PgJsonBuilder';\n\n\tconstructor(name: T['name']) {\n\t\tsuper(name, 'json', 'PgJson');\n\t}\n\n\t/** @internal */\n\toverride build<TTableName extends string>(\n\t\ttable: AnyPgTable<{ name: TTableName }>,\n\t): PgJson<MakeColumnConfig<T, TTableName>> {\n\t\treturn new PgJson<MakeColumnConfig<T, TTableName>>(table, this.config as ColumnBuilderRuntimeConfig<any, any>);\n\t}\n}\n\nexport class PgJson<T extends ColumnBaseConfig<'json', 'PgJson'>> extends PgColumn<T> {\n\tstatic readonly [entityKind]: string = 'PgJson';\n\n\tconstructor(table: AnyPgTable<{ name: T['tableName'] }>, config: PgJsonBuilder<T>['config']) {\n\t\tsuper(table, config);\n\t}\n\n\tgetSQLType(): string {\n\t\treturn 'json';\n\t}\n\n\toverride mapToDriverValue(value: T['data']): string {\n\t\treturn JSON.stringify(value);\n\t}\n\n\toverride mapFromDriverValue(value: T['data'] | string): T['data'] {\n\t\tif (typeof value === 'string') {\n\t\t\ttry {\n\t\t\t\treturn JSON.parse(value);\n\t\t\t} catch {\n\t\t\t\treturn value as T['data'];\n\t\t\t}\n\t\t}\n\t\treturn value;\n\t}\n}\n\nexport function json<TName extends string>(name: TName): PgJsonBuilderInitial<TName> {\n\treturn new PgJsonBuilder(name);\n}\n","import type { ColumnBuilderBaseConfig, ColumnBuilderRuntimeConfig, MakeColumnConfig } from '~/column-builder.ts';\nimport type { ColumnBaseConfig } from '~/column.ts';\nimport { entityKind } from '~/entity.ts';\nimport type { AnyPgTable } from '~/pg-core/table.ts';\nimport { PgColumn, PgColumnBuilder } from './common.ts';\n\nexport type PgJsonbBuilderInitial<TName extends string> = PgJsonbBuilder<{\n\tname: TName;\n\tdataType: 'json';\n\tcolumnType: 'PgJsonb';\n\tdata: unknown;\n\tdriverParam: unknown;\n\tenumValues: undefined;\n}>;\n\nexport class PgJsonbBuilder<T extends ColumnBuilderBaseConfig<'json', 'PgJsonb'>> extends PgColumnBuilder<T> {\n\tstatic readonly [entityKind]: string = 'PgJsonbBuilder';\n\n\tconstructor(name: T['name']) {\n\t\tsuper(name, 'json', 'PgJsonb');\n\t}\n\n\t/** @internal */\n\toverride build<TTableName extends string>(\n\t\ttable: AnyPgTable<{ name: TTableName }>,\n\t): PgJsonb<MakeColumnConfig<T, TTableName>> {\n\t\treturn new PgJsonb<MakeColumnConfig<T, TTableName>>(table, this.config as ColumnBuilderRuntimeConfig<any, any>);\n\t}\n}\n\nexport class PgJsonb<T extends ColumnBaseConfig<'json', 'PgJsonb'>> extends PgColumn<T> {\n\tstatic readonly [entityKind]: string = 'PgJsonb';\n\n\tconstructor(table: AnyPgTable<{ name: T['tableName'] }>, config: PgJsonbBuilder<T>['config']) {\n\t\tsuper(table, config);\n\t}\n\n\tgetSQLType(): string {\n\t\treturn 'jsonb';\n\t}\n\n\toverride mapToDriverValue(value: T['data']): string {\n\t\treturn JSON.stringify(value);\n\t}\n\n\toverride mapFromDriverValue(value: T['data'] | string): T['data'] {\n\t\tif (typeof value === 'string') {\n\t\t\ttry {\n\t\t\t\treturn JSON.parse(value);\n\t\t\t} catch {\n\t\t\t\treturn value as T['data'];\n\t\t\t}\n\t\t}\n\t\treturn value;\n\t}\n}\n\nexport function jsonb<TName extends string>(name: TName): PgJsonbBuilderInitial<TName> {\n\treturn new PgJsonbBuilder(name);\n}\n","import type { ColumnBuilderBaseConfig, ColumnBuilderRuntimeConfig, MakeColumnConfig } from '~/column-builder.ts';\nimport type { ColumnBaseConfig } from '~/column.ts';\nimport { entityKind } from '~/entity.ts';\nimport type { AnyPgTable } from '~/pg-core/table.ts';\nimport { PgColumn, PgColumnBuilder } from './common.ts';\n\nexport type PgNumericBuilderInitial<TName extends string> = PgNumericBuilder<{\n\tname: TName;\n\tdataType: 'string';\n\tcolumnType: 'PgNumeric';\n\tdata: string;\n\tdriverParam: string;\n\tenumValues: undefined;\n}>;\n\nexport class PgNumericBuilder<T extends ColumnBuilderBaseConfig<'string', 'PgNumeric'>> extends PgColumnBuilder<\n\tT,\n\t{\n\t\tprecision: number | undefined;\n\t\tscale: number | undefined;\n\t}\n> {\n\tstatic readonly [entityKind]: string = 'PgNumericBuilder';\n\n\tconstructor(name: string, precision?: number, scale?: number) {\n\t\tsuper(name, 'string', 'PgNumeric');\n\t\tthis.config.precision = precision;\n\t\tthis.config.scale = scale;\n\t}\n\n\t/** @internal */\n\toverride build<TTableName extends string>(\n\t\ttable: AnyPgTable<{ name: TTableName }>,\n\t): PgNumeric<MakeColumnConfig<T, TTableName>> {\n\t\treturn new PgNumeric<MakeColumnConfig<T, TTableName>>(table, this.config as ColumnBuilderRuntimeConfig<any, any>);\n\t}\n}\n\nexport class PgNumeric<T extends ColumnBaseConfig<'string', 'PgNumeric'>> extends PgColumn<T> {\n\tstatic readonly [entityKind]: string = 'PgNumeric';\n\n\treadonly precision: number | undefined;\n\treadonly scale: number | undefined;\n\n\tconstructor(table: AnyPgTable<{ name: T['tableName'] }>, config: PgNumericBuilder<T>['config']) {\n\t\tsuper(table, config);\n\t\tthis.precision = config.precision;\n\t\tthis.scale = config.scale;\n\t}\n\n\tgetSQLType(): string {\n\t\tif (this.precision !== undefined && this.scale !== undefined) {\n\t\t\treturn `numeric(${this.precision}, ${this.scale})`;\n\t\t} else if (this.precision === undefined) {\n\t\t\treturn 'numeric';\n\t\t} else {\n\t\t\treturn `numeric(${this.precision})`;\n\t\t}\n\t}\n}\n\nexport function numeric<TName extends string>(\n\tname: TName,\n\tconfig?:\n\t\t| { precision: number; scale?: number }\n\t\t| { precision?: number; scale: number }\n\t\t| { precision: number; scale: number },\n): PgNumericBuilderInitial<TName> {\n\treturn new PgNumericBuilder(name, config?.precision, config?.scale);\n}\n\nexport const decimal = numeric;\n","import type {\n\tColumnBuilderBaseConfig,\n\tColumnBuilderRuntimeConfig,\n\tHasDefault,\n\tMakeColumnConfig,\n\tNotNull,\n} from '~/column-builder.ts';\nimport type { ColumnBaseConfig } from '~/column.ts';\nimport { entityKind } from '~/entity.ts';\nimport type { AnyPgTable } from '~/pg-core/table.ts';\nimport { PgColumn, PgColumnBuilder } from './common.ts';\n\nexport type PgSerialBuilderInitial<TName extends string> = NotNull<\n\tHasDefault<\n\t\tPgSerialBuilder<{\n\t\t\tname: TName;\n\t\t\tdataType: 'number';\n\t\t\tcolumnType: 'PgSerial';\n\t\t\tdata: number;\n\t\t\tdriverParam: number;\n\t\t\tenumValues: undefined;\n\t\t}>\n\t>\n>;\n\nexport class PgSerialBuilder<T extends ColumnBuilderBaseConfig<'number', 'PgSerial'>> extends PgColumnBuilder<T> {\n\tstatic readonly [entityKind]: string = 'PgSerialBuilder';\n\n\tconstructor(name: string) {\n\t\tsuper(name, 'number', 'PgSerial');\n\t\tthis.config.hasDefault = true;\n\t\tthis.config.notNull = true;\n\t}\n\n\t/** @internal */\n\toverride build<TTableName extends string>(\n\t\ttable: AnyPgTable<{ name: TTableName }>,\n\t): PgSerial<MakeColumnConfig<T, TTableName>> {\n\t\treturn new PgSerial<MakeColumnConfig<T, TTableName>>(table, this.config as ColumnBuilderRuntimeConfig<any, any>);\n\t}\n}\n\nexport class PgSerial<T extends ColumnBaseConfig<'number', 'PgSerial'>> extends PgColumn<T> {\n\tstatic readonly [entityKind]: string = 'PgSerial';\n\n\tgetSQLType(): string {\n\t\treturn 'serial';\n\t}\n}\n\nexport function serial<TName extends string>(name: TName): PgSerialBuilderInitial<TName> {\n\treturn new PgSerialBuilder(name) as PgSerialBuilderInitial<TName>;\n}\n","import type { ColumnBuilderBaseConfig, ColumnBuilderRuntimeConfig, MakeColumnConfig } from '~/column-builder.ts';\nimport type { ColumnBaseConfig } from '~/column.ts';\nimport { entityKind } from '~/entity.ts';\nimport type { AnyPgTable } from '~/pg-core/table.ts';\nimport type { Writable } from '~/utils.ts';\nimport { PgColumn, PgColumnBuilder } from './common.ts';\n\ntype PgTextBuilderInitial<TName extends string, TEnum extends [string, ...string[]]> = PgTextBuilder<{\n\tname: TName;\n\tdataType: 'string';\n\tcolumnType: 'PgText';\n\tdata: TEnum[number];\n\tenumValues: TEnum;\n\tdriverParam: string;\n}>;\n\nexport class PgTextBuilder<\n\tT extends ColumnBuilderBaseConfig<'string', 'PgText'>,\n> extends PgColumnBuilder<T, { enumValues: T['enumValues'] }> {\n\tstatic readonly [entityKind]: string = 'PgTextBuilder';\n\n\tconstructor(\n\t\tname: T['name'],\n\t\tconfig: PgTextConfig<T['enumValues']>,\n\t) {\n\t\tsuper(name, 'string', 'PgText');\n\t\tthis.config.enumValues = config.enum;\n\t}\n\n\t/** @internal */\n\toverride build<TTableName extends string>(\n\t\ttable: AnyPgTable<{ name: TTableName }>,\n\t): PgText<MakeColumnConfig<T, TTableName>> {\n\t\treturn new PgText<MakeColumnConfig<T, TTableName>>(table, this.config as ColumnBuilderRuntimeConfig<any, any>);\n\t}\n}\n\nexport class PgText<T extends ColumnBaseConfig<'string', 'PgText'>>\n\textends PgColumn<T, { enumValues: T['enumValues'] }>\n{\n\tstatic readonly [entityKind]: string = 'PgText';\n\n\toverride readonly enumValues = this.config.enumValues;\n\n\tgetSQLType(): string {\n\t\treturn 'text';\n\t}\n}\n\nexport interface PgTextConfig<TEnum extends readonly string[] | string[] | undefined> {\n\tenum?: TEnum;\n}\n\nexport function text<TName extends string, U extends string, T extends Readonly<[U, ...U[]]>>(\n\tname: TName,\n\tconfig: PgTextConfig<T | Writable<T>> = {},\n): PgTextBuilderInitial<TName, Writable<T>> {\n\treturn new PgTextBuilder(name, config);\n}\n","import type { ColumnBuilderBaseConfig, ColumnBuilderRuntimeConfig, MakeColumnConfig } from '~/column-builder.ts';\nimport type { ColumnBaseConfig } from '~/column.ts';\nimport { entityKind } from '~/entity.ts';\nimport type { AnyPgTable } from '~/pg-core/table.ts';\nimport { PgColumn } from './common.ts';\nimport { PgDateColumnBaseBuilder } from './date.common.ts';\nimport type { Precision } from './timestamp.ts';\n\nexport type PgTimeBuilderInitial<TName extends string> = PgTimeBuilder<{\n\tname: TName;\n\tdataType: 'string';\n\tcolumnType: 'PgTime';\n\tdata: string;\n\tdriverParam: string;\n\tenumValues: undefined;\n}>;\n\nexport class PgTimeBuilder<T extends ColumnBuilderBaseConfig<'string', 'PgTime'>> extends PgDateColumnBaseBuilder<\n\tT,\n\t{ withTimezone: boolean; precision: number | undefined }\n> {\n\tstatic readonly [entityKind]: string = 'PgTimeBuilder';\n\n\tconstructor(\n\t\tname: T['name'],\n\t\treadonly withTimezone: boolean,\n\t\treadonly precision: number | undefined,\n\t) {\n\t\tsuper(name, 'string', 'PgTime');\n\t\tthis.config.withTimezone = withTimezone;\n\t\tthis.config.precision = precision;\n\t}\n\n\t/** @internal */\n\toverride build<TTableName extends string>(\n\t\ttable: AnyPgTable<{ name: TTableName }>,\n\t): PgTime<MakeColumnConfig<T, TTableName>> {\n\t\treturn new PgTime<MakeColumnConfig<T, TTableName>>(table, this.config as ColumnBuilderRuntimeConfig<any, any>);\n\t}\n}\n\nexport class PgTime<T extends ColumnBaseConfig<'string', 'PgTime'>> extends PgColumn<T> {\n\tstatic readonly [entityKind]: string = 'PgTime';\n\n\treadonly withTimezone: boolean;\n\treadonly precision: number | undefined;\n\n\tconstructor(table: AnyPgTable<{ name: T['tableName'] }>, config: PgTimeBuilder<T>['config']) {\n\t\tsuper(table, config);\n\t\tthis.withTimezone = config.withTimezone;\n\t\tthis.precision = config.precision;\n\t}\n\n\tgetSQLType(): string {\n\t\tconst precision = this.precision === undefined ? '' : `(${this.precision})`;\n\t\treturn `time${precision}${this.withTimezone ? ' with time zone' : ''}`;\n\t}\n}\n\nexport interface TimeConfig {\n\tprecision?: Precision;\n\twithTimezone?: boolean;\n}\n\nexport function time<TName extends string>(name: TName, config: TimeConfig = {}): PgTimeBuilderInitial<TName> {\n\treturn new PgTimeBuilder(name, config.withTimezone ?? false, config.precision);\n}\n","import type { ColumnBuilderBaseConfig, ColumnBuilderRuntimeConfig, MakeColumnConfig } from '~/column-builder.ts';\nimport type { ColumnBaseConfig } from '~/column.ts';\nimport { entityKind } from '~/entity.ts';\nimport type { AnyPgTable } from '~/pg-core/table.ts';\nimport type { Equal } from '~/utils.ts';\nimport { PgColumn } from './common.ts';\nimport { PgDateColumnBaseBuilder } from './date.common.ts';\n\nexport type PgTimestampBuilderInitial<TName extends string> = PgTimestampBuilder<{\n\tname: TName;\n\tdataType: 'date';\n\tcolumnType: 'PgTimestamp';\n\tdata: Date;\n\tdriverParam: string;\n\tenumValues: undefined;\n}>;\n\nexport class PgTimestampBuilder<T extends ColumnBuilderBaseConfig<'date', 'PgTimestamp'>>\n\textends PgDateColumnBaseBuilder<\n\t\tT,\n\t\t{ withTimezone: boolean; precision: number | undefined }\n\t>\n{\n\tstatic readonly [entityKind]: string = 'PgTimestampBuilder';\n\n\tconstructor(\n\t\tname: string,\n\t\twithTimezone: boolean,\n\t\tprecision: number | undefined,\n\t) {\n\t\tsuper(name, 'date', 'PgTimestamp');\n\t\tthis.config.withTimezone = withTimezone;\n\t\tthis.config.precision = precision;\n\t}\n\n\t/** @internal */\n\toverride build<TTableName extends string>(\n\t\ttable: AnyPgTable<{ name: TTableName }>,\n\t): PgTimestamp<MakeColumnConfig<T, TTableName>> {\n\t\treturn new PgTimestamp<MakeColumnConfig<T, TTableName>>(table, this.config as ColumnBuilderRuntimeConfig<any, any>);\n\t}\n}\n\nexport class PgTimestamp<T extends ColumnBaseConfig<'date', 'PgTimestamp'>> extends PgColumn<T> {\n\tstatic readonly [entityKind]: string = 'PgTimestamp';\n\n\treadonly withTimezone: boolean;\n\treadonly precision: number | undefined;\n\n\tconstructor(table: AnyPgTable<{ name: T['tableName'] }>, config: PgTimestampBuilder<T>['config']) {\n\t\tsuper(table, config);\n\t\tthis.withTimezone = config.withTimezone;\n\t\tthis.precision = config.precision;\n\t}\n\n\tgetSQLType(): string {\n\t\tconst precision = this.precision === undefined ? '' : ` (${this.precision})`;\n\t\treturn `timestamp${precision}${this.withTimezone ? ' with time zone' : ''}`;\n\t}\n\n\toverride mapFromDriverValue = (value: string): Date => {\n\t\treturn new Date(this.withTimezone ? value : value + '+0000');\n\t};\n\n\toverride mapToDriverValue = (value: Date): string => {\n\t\treturn this.withTimezone ? value.toUTCString() : value.toISOString();\n\t};\n}\n\nexport type PgTimestampStringBuilderInitial<TName extends string> = PgTimestampStringBuilder<{\n\tname: TName;\n\tdataType: 'string';\n\tcolumnType: 'PgTimestampString';\n\tdata: string;\n\tdriverParam: string;\n\tenumValues: undefined;\n}>;\n\nexport class PgTimestampStringBuilder<T extends ColumnBuilderBaseConfig<'string', 'PgTimestampString'>>\n\textends PgDateColumnBaseBuilder<\n\t\tT,\n\t\t{ withTimezone: boolean; precision: number | undefined }\n\t>\n{\n\tstatic readonly [entityKind]: string = 'PgTimestampStringBuilder';\n\n\tconstructor(\n\t\tname: string,\n\t\twithTimezone: boolean,\n\t\tprecision: number | undefined,\n\t) {\n\t\tsuper(name, 'string', 'PgTimestampString');\n\t\tthis.config.withTimezone = withTimezone;\n\t\tthis.config.precision = precision;\n\t}\n\n\t/** @internal */\n\toverride build<TTableName extends string>(\n\t\ttable: AnyPgTable<{ name: TTableName }>,\n\t): PgTimestampString<MakeColumnConfig<T, TTableName>> {\n\t\treturn new PgTimestampString<MakeColumnConfig<T, TTableName>>(\n\t\t\ttable,\n\t\t\tthis.config as ColumnBuilderRuntimeConfig<any, any>,\n\t\t);\n\t}\n}\n\nexport class PgTimestampString<T extends ColumnBaseConfig<'string', 'PgTimestampString'>> extends PgColumn<T> {\n\tstatic readonly [entityKind]: string = 'PgTimestampString';\n\n\treadonly withTimezone: boolean;\n\treadonly precision: number | undefined;\n\n\tconstructor(table: AnyPgTable<{ name: T['tableName'] }>, config: PgTimestampStringBuilder<T>['config']) {\n\t\tsuper(table, config);\n\t\tthis.withTimezone = config.withTimezone;\n\t\tthis.precision = config.precision;\n\t}\n\n\tgetSQLType(): string {\n\t\tconst precision = this.precision === undefined ? '' : `(${this.precision})`;\n\t\treturn `timestamp${precision}${this.withTimezone ? ' with time zone' : ''}`;\n\t}\n}\n\nexport type Precision = 0 | 1 | 2 | 3 | 4 | 5 | 6;\n\nexport interface PgTimestampConfig<TMode extends 'date' | 'string' = 'date' | 'string'> {\n\tmode?: TMode;\n\tprecision?: Precision;\n\twithTimezone?: boolean;\n}\n\nexport function timestamp<TName extends string, TMode extends PgTimestampConfig['mode'] & {}>(\n\tname: TName,\n\tconfig?: PgTimestampConfig<TMode>,\n): Equal<TMode, 'string'> extends true ? PgTimestampStringBuilderInitial<TName> : PgTimestampBuilderInitial<TName>;\nexport function timestamp(\n\tname: string,\n\tconfig: PgTimestampConfig = {},\n) {\n\tif (config.mode === 'string') {\n\t\treturn new PgTimestampStringBuilder(name, config.withTimezone ?? false, config.precision);\n\t}\n\treturn new PgTimestampBuilder(name, config.withTimezone ?? false, config.precision);\n}\n","import type { ColumnBuilderBaseConfig, ColumnBuilderRuntimeConfig, MakeColumnConfig } from '~/column-builder.ts';\nimport type { ColumnBaseConfig } from '~/column.ts';\nimport { entityKind } from '~/entity.ts';\nimport type { AnyPgTable } from '~/pg-core/table.ts';\nimport { sql } from '~/sql/sql.ts';\nimport { PgColumn, PgColumnBuilder } from './common.ts';\n\nexport type PgUUIDBuilderInitial<TName extends string> = PgUUIDBuilder<{\n\tname: TName;\n\tdataType: 'string';\n\tcolumnType: 'PgUUID';\n\tdata: string;\n\tdriverParam: string;\n\tenumValues: undefined;\n}>;\n\nexport class PgUUIDBuilder<T extends ColumnBuilderBaseConfig<'string', 'PgUUID'>> extends PgColumnBuilder<T> {\n\tstatic readonly [entityKind]: string = 'PgUUIDBuilder';\n\n\tconstructor(name: T['name']) {\n\t\tsuper(name, 'string', 'PgUUID');\n\t}\n\n\t/**\n\t * Adds `default gen_random_uuid()` to the column definition.\n\t */\n\tdefaultRandom(): ReturnType<this['default']> {\n\t\treturn this.default(sql`gen_random_uuid()`) as ReturnType<this['default']>;\n\t}\n\n\t/** @internal */\n\toverride build<TTableName extends string>(\n\t\ttable: AnyPgTable<{ name: TTableName }>,\n\t): PgUUID<MakeColumnConfig<T, TTableName>> {\n\t\treturn new PgUUID<MakeColumnConfig<T, TTableName>>(table, this.config as ColumnBuilderRuntimeConfig<any, any>);\n\t}\n}\n\nexport class PgUUID<T extends ColumnBaseConfig<'string', 'PgUUID'>> extends PgColumn<T> {\n\tstatic readonly [entityKind]: string = 'PgUUID';\n\n\tgetSQLType(): string {\n\t\treturn 'uuid';\n\t}\n}\n\nexport function uuid<TName extends string>(name: TName): PgUUIDBuilderInitial<TName> {\n\treturn new PgUUIDBuilder(name);\n}\n","import type { ColumnBuilderBaseConfig, ColumnBuilderRuntimeConfig, MakeColumnConfig } from '~/column-builder.ts';\nimport type { ColumnBaseConfig } from '~/column.ts';\nimport { entityKind } from '~/entity.ts';\nimport type { AnyPgTable } from '~/pg-core/table.ts';\nimport type { Writable } from '~/utils.ts';\nimport { PgColumn, PgColumnBuilder } from './common.ts';\n\nexport type PgVarcharBuilderInitial<TName extends string, TEnum extends [string, ...string[]]> = PgVarcharBuilder<{\n\tname: TName;\n\tdataType: 'string';\n\tcolumnType: 'PgVarchar';\n\tdata: TEnum[number];\n\tdriverParam: string;\n\tenumValues: TEnum;\n}>;\n\nexport class PgVarcharBuilder<T extends ColumnBuilderBaseConfig<'string', 'PgVarchar'>> extends PgColumnBuilder<\n\tT,\n\t{ length: number | undefined; enumValues: T['enumValues'] }\n> {\n\tstatic readonly [entityKind]: string = 'PgVarcharBuilder';\n\n\tconstructor(name: string, config: PgVarcharConfig<T['enumValues']>) {\n\t\tsuper(name, 'string', 'PgVarchar');\n\t\tthis.config.length = config.length;\n\t\tthis.config.enumValues = config.enum;\n\t}\n\n\t/** @internal */\n\toverride build<TTableName extends string>(\n\t\ttable: AnyPgTable<{ name: TTableName }>,\n\t): PgVarchar<MakeColumnConfig<T, TTableName>> {\n\t\treturn new PgVarchar<MakeColumnConfig<T, TTableName>>(table, this.config as ColumnBuilderRuntimeConfig<any, any>);\n\t}\n}\n\nexport class PgVarchar<T extends ColumnBaseConfig<'string', 'PgVarchar'>>\n\textends PgColumn<T, { length: number | undefined; enumValues: T['enumValues'] }>\n{\n\tstatic readonly [entityKind]: string = 'PgVarchar';\n\n\treadonly length = this.config.length;\n\toverride readonly enumValues = this.config.enumValues;\n\n\tgetSQLType(): string {\n\t\treturn this.length === undefined ? `varchar` : `varchar(${this.length})`;\n\t}\n}\n\nexport interface PgVarcharConfig<TEnum extends readonly string[] | string[] | undefined> {\n\tlength?: number;\n\tenum?: TEnum;\n}\n\nexport function varchar<TName extends string, U extends string, T extends Readonly<[U, ...U[]]>>(\n\tname: TName,\n\tconfig: PgVarcharConfig<T | Writable<T>> = {},\n): PgVarcharBuilderInitial<TName, Writable<T>> {\n\treturn new PgVarcharBuilder(name, config);\n}\n","import { entityKind } from '~/entity.ts';\nimport type { AnyPgColumn, PgColumn } from './columns/index.ts';\nimport { PgTable } from './table.ts';\n\nexport function primaryKey<\n\tTTableName extends string,\n\tTColumn extends AnyPgColumn<{ tableName: TTableName }>,\n\tTColumns extends AnyPgColumn<{ tableName: TTableName }>[],\n>(config: { name?: string; columns: [TColumn, ...TColumns] }): PrimaryKeyBuilder;\n/**\n * @deprecated: Please use primaryKey({ columns: [] }) instead of this function\n * @param columns\n */\nexport function primaryKey<\n\tTTableName extends string,\n\tTColumns extends AnyPgColumn<{ tableName: TTableName }>[],\n>(...columns: TColumns): PrimaryKeyBuilder;\nexport function primaryKey(...config: any) {\n\tif (config[0].columns) {\n\t\treturn new PrimaryKeyBuilder(config[0].columns, config[0].name);\n\t}\n\treturn new PrimaryKeyBuilder(config);\n}\n\nexport class PrimaryKeyBuilder {\n\tstatic readonly [entityKind]: string = 'PgPrimaryKeyBuilder';\n\n\t/** @internal */\n\tcolumns: PgColumn[];\n\n\t/** @internal */\n\tname?: string;\n\n\tconstructor(\n\t\tcolumns: PgColumn[],\n\t\tname?: string,\n\t) {\n\t\tthis.columns = columns;\n\t\tthis.name = name;\n\t}\n\n\t/** @internal */\n\tbuild(table: PgTable): PrimaryKey {\n\t\treturn new PrimaryKey(table, this.columns, this.name);\n\t}\n}\n\nexport class PrimaryKey {\n\tstatic readonly [entityKind]: string = 'PgPrimaryKey';\n\n\treadonly columns: AnyPgColumn<{}>[];\n\treadonly name?: string;\n\n\tconstructor(readonly table: PgTable, columns: AnyPgColumn<{}>[], name?: string) {\n\t\tthis.columns = columns;\n\t\tthis.name = name;\n\t}\n\n\tgetName(): string {\n\t\treturn this.name ?? `${this.table[PgTable.Symbol.Name]}_${this.columns.map((column) => column.name).join('_')}_pk`;\n\t}\n}\n","import { type AnyColumn, Column, type GetColumnData } from '~/column.ts';\nimport { is } from '~/entity.ts';\nimport { Table } from '~/table.ts';\nimport {\n\tisDriverValueEncoder,\n\tisSQLWrapper,\n\tParam,\n\tPlaceholder,\n\tSQL,\n\tsql,\n\ttype SQLChunk,\n\ttype SQLWrapper,\n\tStringChunk,\n\tView,\n} from '../sql.ts';\n\nexport function bindIfParam(value: unknown, column: SQLWrapper): SQLChunk {\n\tif (\n\t\tisDriverValueEncoder(column)\n\t\t&& !isSQLWrapper(value)\n\t\t&& !is(value, Param)\n\t\t&& !is(value, Placeholder)\n\t\t&& !is(value, Column)\n\t\t&& !is(value, Table)\n\t\t&& !is(value, View)\n\t) {\n\t\treturn new Param(value, column);\n\t}\n\treturn value as SQLChunk;\n}\n\nexport interface BinaryOperator {\n\t<TColumn extends Column>(\n\t\tleft: TColumn,\n\t\tright: GetColumnData<TColumn, 'raw'> | SQLWrapper,\n\t): SQL;\n\t<T>(left: SQL.Aliased<T>, right: T | SQLWrapper): SQL;\n\t<T extends SQLWrapper>(\n\t\tleft: Exclude<T, SQL.Aliased | Column>,\n\t\tright: unknown,\n\t): SQL;\n}\n\n/**\n * Test that two values are equal.\n *\n * Remember that the SQL standard dictates that\n * two NULL values are not equal, so if you want to test\n * whether a value is null, you may want to use\n * `isNull` instead.\n *\n * ## Examples\n *\n * ```ts\n * // Select cars made by Ford\n * db.select().from(cars)\n *   .where(eq(cars.make, 'Ford'))\n * ```\n *\n * @see isNull for a way to test equality to NULL.\n */\nexport const eq: BinaryOperator = (left: SQLWrapper, right: unknown): SQL => {\n\treturn sql`${left} = ${bindIfParam(right, left)}`;\n};\n\n/**\n * Test that two values are not equal.\n *\n * Remember that the SQL standard dictates that\n * two NULL values are not equal, so if you want to test\n * whether a value is not null, you may want to use\n * `isNotNull` instead.\n *\n * ## Examples\n *\n * ```ts\n * // Select cars not made by Ford\n * db.select().from(cars)\n *   .where(ne(cars.make, 'Ford'))\n * ```\n *\n * @see isNotNull for a way to test whether a value is not null.\n */\nexport const ne: BinaryOperator = (left: SQLWrapper, right: unknown): SQL => {\n\treturn sql`${left} <> ${bindIfParam(right, left)}`;\n};\n\n/**\n * Combine a list of conditions with the `and` operator. Conditions\n * that are equal `undefined` are automatically ignored.\n *\n * ## Examples\n *\n * ```ts\n * db.select().from(cars)\n *   .where(\n *     and(\n *       eq(cars.make, 'Volvo'),\n *       eq(cars.year, 1950),\n *     )\n *   )\n * ```\n */\nexport function and(...conditions: (SQLWrapper | undefined)[]): SQL | undefined;\nexport function and(\n\t...unfilteredConditions: (SQLWrapper | undefined)[]\n): SQL | undefined {\n\tconst conditions = unfilteredConditions.filter(\n\t\t(c): c is Exclude<typeof c, undefined> => c !== undefined,\n\t);\n\n\tif (conditions.length === 0) {\n\t\treturn undefined;\n\t}\n\n\tif (conditions.length === 1) {\n\t\treturn new SQL(conditions);\n\t}\n\n\treturn new SQL([\n\t\tnew StringChunk('('),\n\t\tsql.join(conditions, new StringChunk(' and ')),\n\t\tnew StringChunk(')'),\n\t]);\n}\n\n/**\n * Combine a list of conditions with the `or` operator. Conditions\n * that are equal `undefined` are automatically ignored.\n *\n * ## Examples\n *\n * ```ts\n * db.select().from(cars)\n *   .where(\n *     or(\n *       eq(cars.make, 'GM'),\n *       eq(cars.make, 'Ford'),\n *     )\n *   )\n * ```\n */\nexport function or(...conditions: (SQLWrapper | undefined)[]): SQL | undefined;\nexport function or(\n\t...unfilteredConditions: (SQLWrapper | undefined)[]\n): SQL | undefined {\n\tconst conditions = unfilteredConditions.filter(\n\t\t(c): c is Exclude<typeof c, undefined> => c !== undefined,\n\t);\n\n\tif (conditions.length === 0) {\n\t\treturn undefined;\n\t}\n\n\tif (conditions.length === 1) {\n\t\treturn new SQL(conditions);\n\t}\n\n\treturn new SQL([\n\t\tnew StringChunk('('),\n\t\tsql.join(conditions, new StringChunk(' or ')),\n\t\tnew StringChunk(')'),\n\t]);\n}\n\n/**\n * Negate the meaning of an expression using the `not` keyword.\n *\n * ## Examples\n *\n * ```ts\n * // Select cars _not_ made by GM or Ford.\n * db.select().from(cars)\n *   .where(not(inArray(cars.make, ['GM', 'Ford'])))\n * ```\n */\nexport function not(condition: SQLWrapper): SQL {\n\treturn sql`not ${condition}`;\n}\n\n/**\n * Test that the first expression passed is greater than\n * the second expression.\n *\n * ## Examples\n *\n * ```ts\n * // Select cars made after 2000.\n * db.select().from(cars)\n *   .where(gt(cars.year, 2000))\n * ```\n *\n * @see gte for greater-than-or-equal\n */\nexport const gt: BinaryOperator = (left: SQLWrapper, right: unknown): SQL => {\n\treturn sql`${left} > ${bindIfParam(right, left)}`;\n};\n\n/**\n * Test that the first expression passed is greater than\n * or equal to the second expression. Use `gt` to\n * test whether an expression is strictly greater\n * than another.\n *\n * ## Examples\n *\n * ```ts\n * // Select cars made on or after 2000.\n * db.select().from(cars)\n *   .where(gte(cars.year, 2000))\n * ```\n *\n * @see gt for a strictly greater-than condition\n */\nexport const gte: BinaryOperator = (left: SQLWrapper, right: unknown): SQL => {\n\treturn sql`${left} >= ${bindIfParam(right, left)}`;\n};\n\n/**\n * Test that the first expression passed is less than\n * the second expression.\n *\n * ## Examples\n *\n * ```ts\n * // Select cars made before 2000.\n * db.select().from(cars)\n *   .where(lt(cars.year, 2000))\n * ```\n *\n * @see lte for greater-than-or-equal\n */\nexport const lt: BinaryOperator = (left: SQLWrapper, right: unknown): SQL => {\n\treturn sql`${left} < ${bindIfParam(right, left)}`;\n};\n\n/**\n * Test that the first expression passed is less than\n * or equal to the second expression.\n *\n * ## Examples\n *\n * ```ts\n * // Select cars made before 2000.\n * db.select().from(cars)\n *   .where(lte(cars.year, 2000))\n * ```\n *\n * @see lt for a strictly less-than condition\n */\nexport const lte: BinaryOperator = (left: SQLWrapper, right: unknown): SQL => {\n\treturn sql`${left} <= ${bindIfParam(right, left)}`;\n};\n\n/**\n * Test whether the first parameter, a column or expression,\n * has a value from a list passed as the second argument.\n *\n * ## Throws\n *\n * The argument passed in the second array can't be empty:\n * if an empty is provided, this method will throw.\n *\n * ## Examples\n *\n * ```ts\n * // Select cars made by Ford or GM.\n * db.select().from(cars)\n *   .where(inArray(cars.make, ['Ford', 'GM']))\n * ```\n *\n * @see notInArray for the inverse of this test\n */\nexport function inArray<T>(\n\tcolumn: SQL.Aliased<T>,\n\tvalues: (T | Placeholder)[] | SQLWrapper,\n): SQL;\nexport function inArray<TColumn extends Column>(\n\tcolumn: TColumn,\n\tvalues: (GetColumnData<TColumn, 'raw'> | Placeholder)[] | SQLWrapper,\n): SQL;\nexport function inArray<T extends SQLWrapper>(\n\tcolumn: Exclude<T, SQL.Aliased | Column>,\n\tvalues: (unknown | Placeholder)[] | SQLWrapper,\n): SQL;\nexport function inArray(\n\tcolumn: SQLWrapper,\n\tvalues: (unknown | Placeholder)[] | SQLWrapper,\n): SQL {\n\tif (Array.isArray(values)) {\n\t\tif (values.length === 0) {\n\t\t\tthrow new Error('inArray requires at least one value');\n\t\t}\n\t\treturn sql`${column} in ${values.map((v) => bindIfParam(v, column))}`;\n\t}\n\n\treturn sql`${column} in ${bindIfParam(values, column)}`;\n}\n\n/**\n * Test whether the first parameter, a column or expression,\n * has a value that is not present in a list passed as the\n * second argument.\n *\n * ## Throws\n *\n * The argument passed in the second array can't be empty:\n * if an empty is provided, this method will throw.\n *\n * ## Examples\n *\n * ```ts\n * // Select cars made by any company except Ford or GM.\n * db.select().from(cars)\n *   .where(notInArray(cars.make, ['Ford', 'GM']))\n * ```\n *\n * @see inArray for the inverse of this test\n */\nexport function notInArray<T>(\n\tcolumn: SQL.Aliased<T>,\n\tvalues: (T | Placeholder)[] | SQLWrapper,\n): SQL;\nexport function notInArray<TColumn extends Column>(\n\tcolumn: TColumn,\n\tvalues: (GetColumnData<TColumn, 'raw'> | Placeholder)[] | SQLWrapper,\n): SQL;\nexport function notInArray<T extends SQLWrapper>(\n\tcolumn: Exclude<T, SQL.Aliased | Column>,\n\tvalues: (unknown | Placeholder)[] | SQLWrapper,\n): SQL;\nexport function notInArray(\n\tcolumn: SQLWrapper,\n\tvalues: (unknown | Placeholder)[] | SQLWrapper,\n): SQL {\n\tif (Array.isArray(values)) {\n\t\tif (values.length === 0) {\n\t\t\tthrow new Error('notInArray requires at least one value');\n\t\t}\n\t\treturn sql`${column} not in ${values.map((v) => bindIfParam(v, column))}`;\n\t}\n\n\treturn sql`${column} not in ${bindIfParam(values, column)}`;\n}\n\n/**\n * Test whether an expression is NULL. By the SQL standard,\n * NULL is neither equal nor not equal to itself, so\n * it's recommended to use `isNull` and `notIsNull` for\n * comparisons to NULL.\n *\n * ## Examples\n *\n * ```ts\n * // Select cars that have no discontinuedAt date.\n * db.select().from(cars)\n *   .where(isNull(cars.discontinuedAt))\n * ```\n *\n * @see isNotNull for the inverse of this test\n */\nexport function isNull(value: SQLWrapper): SQL {\n\treturn sql`${value} is null`;\n}\n\n/**\n * Test whether an expression is not NULL. By the SQL standard,\n * NULL is neither equal nor not equal to itself, so\n * it's recommended to use `isNull` and `notIsNull` for\n * comparisons to NULL.\n *\n * ## Examples\n *\n * ```ts\n * // Select cars that have been discontinued.\n * db.select().from(cars)\n *   .where(isNotNull(cars.discontinuedAt))\n * ```\n *\n * @see isNull for the inverse of this test\n */\nexport function isNotNull(value: SQLWrapper): SQL {\n\treturn sql`${value} is not null`;\n}\n\n/**\n * Test whether a subquery evaluates to have any rows.\n *\n * ## Examples\n *\n * ```ts\n * // Users whose `homeCity` column has a match in a cities\n * // table.\n * db\n *   .select()\n *   .from(users)\n *   .where(\n *     exists(db.select()\n *       .from(cities)\n *       .where(eq(users.homeCity, cities.id))),\n *   );\n * ```\n *\n * @see notExists for the inverse of this test\n */\nexport function exists(subquery: SQLWrapper): SQL {\n\treturn sql`exists ${subquery}`;\n}\n\n/**\n * Test whether a subquery doesn't include any result\n * rows.\n *\n * ## Examples\n *\n * ```ts\n * // Users whose `homeCity` column doesn't match\n * // a row in the cities table.\n * db\n *   .select()\n *   .from(users)\n *   .where(\n *     notExists(db.select()\n *       .from(cities)\n *       .where(eq(users.homeCity, cities.id))),\n *   );\n * ```\n *\n * @see exists for the inverse of this test\n */\nexport function notExists(subquery: SQLWrapper): SQL {\n\treturn sql`not exists ${subquery}`;\n}\n\n/**\n * Test whether an expression is between two values. This\n * is an easier way to express range tests, which would be\n * expressed mathematically as `x <= a <= y` but in SQL\n * would have to be like `a >= x AND a <= y`.\n *\n * Between is inclusive of the endpoints: if `column`\n * is equal to `min` or `max`, it will be TRUE.\n *\n * ## Examples\n *\n * ```ts\n * // Select cars made between 1990 and 2000\n * db.select().from(cars)\n *   .where(between(cars.year, 1990, 2000))\n * ```\n *\n * @see notBetween for the inverse of this test\n */\nexport function between<T>(\n\tcolumn: SQL.Aliased,\n\tmin: T | SQLWrapper,\n\tmax: T | SQLWrapper,\n): SQL;\nexport function between<TColumn extends AnyColumn>(\n\tcolumn: TColumn,\n\tmin: GetColumnData<TColumn, 'raw'> | SQLWrapper,\n\tmax: GetColumnData<TColumn, 'raw'> | SQLWrapper,\n): SQL;\nexport function between<T extends SQLWrapper>(\n\tcolumn: Exclude<T, SQL.Aliased | Column>,\n\tmin: unknown,\n\tmax: unknown,\n): SQL;\nexport function between(column: SQLWrapper, min: unknown, max: unknown): SQL {\n\treturn sql`${column} between ${bindIfParam(min, column)} and ${\n\t\tbindIfParam(\n\t\t\tmax,\n\t\t\tcolumn,\n\t\t)\n\t}`;\n}\n\n/**\n * Test whether an expression is not between two values.\n *\n * This, like `between`, includes its endpoints, so if\n * the `column` is equal to `min` or `max`, in this case\n * it will evaluate to FALSE.\n *\n * ## Examples\n *\n * ```ts\n * // Exclude cars made in the 1970s\n * db.select().from(cars)\n *   .where(notBetween(cars.year, 1970, 1979))\n * ```\n *\n * @see between for the inverse of this test\n */\nexport function notBetween<T>(\n\tcolumn: SQL.Aliased,\n\tmin: T | SQLWrapper,\n\tmax: T | SQLWrapper,\n): SQL;\nexport function notBetween<TColumn extends AnyColumn>(\n\tcolumn: TColumn,\n\tmin: GetColumnData<TColumn, 'raw'> | SQLWrapper,\n\tmax: GetColumnData<TColumn, 'raw'> | SQLWrapper,\n): SQL;\nexport function notBetween<T extends SQLWrapper>(\n\tcolumn: Exclude<T, SQL.Aliased | Column>,\n\tmin: unknown,\n\tmax: unknown,\n): SQL;\nexport function notBetween(\n\tcolumn: SQLWrapper,\n\tmin: unknown,\n\tmax: unknown,\n): SQL {\n\treturn sql`${column} not between ${\n\t\tbindIfParam(\n\t\t\tmin,\n\t\t\tcolumn,\n\t\t)\n\t} and ${bindIfParam(max, column)}`;\n}\n\n/**\n * Compare a column to a pattern, which can include `%` and `_`\n * characters to match multiple variations. Including `%`\n * in the pattern matches zero or more characters, and including\n * `_` will match a single character.\n *\n * ## Examples\n *\n * ```ts\n * // Select all cars with 'Turbo' in their names.\n * db.select().from(cars)\n *   .where(like(cars.name, '%Turbo%'))\n * ```\n *\n * @see ilike for a case-insensitive version of this condition\n */\nexport function like(column: Column, value: string | SQLWrapper): SQL {\n\treturn sql`${column} like ${value}`;\n}\n\n/**\n * The inverse of like - this tests that a given column\n * does not match a pattern, which can include `%` and `_`\n * characters to match multiple variations. Including `%`\n * in the pattern matches zero or more characters, and including\n * `_` will match a single character.\n *\n * ## Examples\n *\n * ```ts\n * // Select all cars that don't have \"ROver\" in their name.\n * db.select().from(cars)\n *   .where(notLike(cars.name, '%Rover%'))\n * ```\n *\n * @see like for the inverse condition\n * @see notIlike for a case-insensitive version of this condition\n */\nexport function notLike(column: Column, value: string | SQLWrapper): SQL {\n\treturn sql`${column} not like ${value}`;\n}\n\n/**\n * Case-insensitively compare a column to a pattern,\n * which can include `%` and `_`\n * characters to match multiple variations. Including `%`\n * in the pattern matches zero or more characters, and including\n * `_` will match a single character.\n *\n * Unlike like, this performs a case-insensitive comparison.\n *\n * ## Examples\n *\n * ```ts\n * // Select all cars with 'Turbo' in their names.\n * db.select().from(cars)\n *   .where(ilike(cars.name, '%Turbo%'))\n * ```\n *\n * @see like for a case-sensitive version of this condition\n */\nexport function ilike(column: Column, value: string | SQLWrapper): SQL {\n\treturn sql`${column} ilike ${value}`;\n}\n\n/**\n * The inverse of ilike - this case-insensitively tests that a given column\n * does not match a pattern, which can include `%` and `_`\n * characters to match multiple variations. Including `%`\n * in the pattern matches zero or more characters, and including\n * `_` will match a single character.\n *\n * ## Examples\n *\n * ```ts\n * // Select all cars that don't have \"Rover\" in their name.\n * db.select().from(cars)\n *   .where(notLike(cars.name, '%Rover%'))\n * ```\n *\n * @see ilike for the inverse condition\n * @see notLike for a case-sensitive version of this condition\n */\nexport function notIlike(column: Column, value: string | SQLWrapper): SQL {\n\treturn sql`${column} not ilike ${value}`;\n}\n\n/**\n * Test that a column or expression contains all elements of\n * the list passed as the second argument.\n *\n * ## Throws\n *\n * The argument passed in the second array can't be empty:\n * if an empty is provided, this method will throw.\n *\n * ## Examples\n *\n * ```ts\n * // Select posts where its tags contain \"Typescript\" and \"ORM\".\n * db.select().from(posts)\n *   .where(arrayContains(posts.tags, ['Typescript', 'ORM']))\n * ```\n *\n * @see arrayContained to find if an array contains all elements of a column or expression\n * @see arrayOverlaps to find if a column or expression contains any elements of an array\n */\nexport function arrayContains<T>(\n\tcolumn: SQL.Aliased<T>,\n\tvalues: (T | Placeholder) | SQLWrapper,\n): SQL;\nexport function arrayContains<TColumn extends Column>(\n\tcolumn: TColumn,\n\tvalues: (GetColumnData<TColumn, 'raw'> | Placeholder) | SQLWrapper,\n): SQL;\nexport function arrayContains<T extends SQLWrapper>(\n\tcolumn: Exclude<T, SQL.Aliased | Column>,\n\tvalues: (unknown | Placeholder)[] | SQLWrapper,\n): SQL;\nexport function arrayContains(\n\tcolumn: SQLWrapper,\n\tvalues: (unknown | Placeholder)[] | SQLWrapper,\n): SQL {\n\tif (Array.isArray(values)) {\n\t\tif (values.length === 0) {\n\t\t\tthrow new Error('arrayContains requires at least one value');\n\t\t}\n\t\tconst array = sql`${bindIfParam(values, column)}`;\n\t\treturn sql`${column} @> ${array}`;\n\t}\n\n\treturn sql`${column} @> ${bindIfParam(values, column)}`;\n}\n\n/**\n * Test that the list passed as the second argument contains\n * all elements of a column or expression.\n *\n * ## Throws\n *\n * The argument passed in the second array can't be empty:\n * if an empty is provided, this method will throw.\n *\n * ## Examples\n *\n * ```ts\n * // Select posts where its tags contain \"Typescript\", \"ORM\" or both,\n * // but filtering posts that have additional tags.\n * db.select().from(posts)\n *   .where(arrayContained(posts.tags, ['Typescript', 'ORM']))\n * ```\n *\n * @see arrayContains to find if a column or expression contains all elements of an array\n * @see arrayOverlaps to find if a column or expression contains any elements of an array\n */\nexport function arrayContained<T>(\n\tcolumn: SQL.Aliased<T>,\n\tvalues: (T | Placeholder) | SQLWrapper,\n): SQL;\nexport function arrayContained<TColumn extends Column>(\n\tcolumn: TColumn,\n\tvalues: (GetColumnData<TColumn, 'raw'> | Placeholder) | SQLWrapper,\n): SQL;\nexport function arrayContained<T extends SQLWrapper>(\n\tcolumn: Exclude<T, SQL.Aliased | Column>,\n\tvalues: (unknown | Placeholder)[] | SQLWrapper,\n): SQL;\nexport function arrayContained(\n\tcolumn: SQLWrapper,\n\tvalues: (unknown | Placeholder)[] | SQLWrapper,\n): SQL {\n\tif (Array.isArray(values)) {\n\t\tif (values.length === 0) {\n\t\t\tthrow new Error('arrayContained requires at least one value');\n\t\t}\n\t\tconst array = sql`${bindIfParam(values, column)}`;\n\t\treturn sql`${column} <@ ${array}`;\n\t}\n\n\treturn sql`${column} <@ ${bindIfParam(values, column)}`;\n}\n\n/**\n * Test that a column or expression contains any elements of\n * the list passed as the second argument.\n *\n * ## Throws\n *\n * The argument passed in the second array can't be empty:\n * if an empty is provided, this method will throw.\n *\n * ## Examples\n *\n * ```ts\n * // Select posts where its tags contain \"Typescript\", \"ORM\" or both.\n * db.select().from(posts)\n *   .where(arrayOverlaps(posts.tags, ['Typescript', 'ORM']))\n * ```\n *\n * @see arrayContains to find if a column or expression contains all elements of an array\n * @see arrayContained to find if an array contains all elements of a column or expression\n */\nexport function arrayOverlaps<T>(\n\tcolumn: SQL.Aliased<T>,\n\tvalues: (T | Placeholder) | SQLWrapper,\n): SQL;\nexport function arrayOverlaps<TColumn extends Column>(\n\tcolumn: TColumn,\n\tvalues: (GetColumnData<TColumn, 'raw'> | Placeholder) | SQLWrapper,\n): SQL;\nexport function arrayOverlaps<T extends SQLWrapper>(\n\tcolumn: Exclude<T, SQL.Aliased | Column>,\n\tvalues: (unknown | Placeholder)[] | SQLWrapper,\n): SQL;\nexport function arrayOverlaps(\n\tcolumn: SQLWrapper,\n\tvalues: (unknown | Placeholder)[] | SQLWrapper,\n): SQL {\n\tif (Array.isArray(values)) {\n\t\tif (values.length === 0) {\n\t\t\tthrow new Error('arrayOverlaps requires at least one value');\n\t\t}\n\t\tconst array = sql`${bindIfParam(values, column)}`;\n\t\treturn sql`${column} && ${array}`;\n\t}\n\n\treturn sql`${column} && ${bindIfParam(values, column)}`;\n}\n","import type { AnyColumn } from '../../column.ts';\nimport type { SQL, SQLWrapper } from '../sql.ts';\nimport { sql } from '../sql.ts';\n\n/**\n * Used in sorting, this specifies that the given\n * column or expression should be sorted in ascending\n * order. By the SQL standard, ascending order is the\n * default, so it is not usually necessary to specify\n * ascending sort order.\n *\n * ## Examples\n *\n * ```ts\n * // Return cars, starting with the oldest models\n * // and going in ascending order to the newest.\n * db.select().from(cars)\n *   .orderBy(asc(cars.year));\n * ```\n *\n * @see desc to sort in descending order\n */\nexport function asc(column: AnyColumn | SQLWrapper): SQL {\n\treturn sql`${column} asc`;\n}\n\n/**\n * Used in sorting, this specifies that the given\n * column or expression should be sorted in descending\n * order.\n *\n * ## Examples\n *\n * ```ts\n * // Select users, with the most recently created\n * // records coming first.\n * db.select().from(users)\n *   .orderBy(desc(users.createdAt));\n * ```\n *\n * @see asc to sort in ascending order\n */\nexport function desc(column: AnyColumn | SQLWrapper): SQL {\n\treturn sql`${column} desc`;\n}\n","import { type AnyTable, type InferModelFromColumns, isTable, Table } from '~/table.ts';\nimport { type AnyColumn, Column } from './column.ts';\nimport { entityKind, is } from './entity.ts';\nimport { PrimaryKeyBuilder } from './pg-core/primary-keys.ts';\nimport {\n\tand,\n\tasc,\n\tbetween,\n\tdesc,\n\teq,\n\texists,\n\tgt,\n\tgte,\n\tilike,\n\tinArray,\n\tisNotNull,\n\tisNull,\n\tlike,\n\tlt,\n\tlte,\n\tne,\n\tnot,\n\tnotBetween,\n\tnotExists,\n\tnotIlike,\n\tnotInArray,\n\tnotLike,\n\tor,\n} from './sql/expressions/index.ts';\nimport { type Placeholder, SQL, sql } from './sql/sql.ts';\nimport type { Assume, ColumnsWithTable, Equal, Simplify, ValueOrArray } from './utils.ts';\n\nexport abstract class Relation<TTableName extends string = string> {\n\tstatic readonly [entityKind]: string = 'Relation';\n\n\tdeclare readonly $brand: 'Relation';\n\treadonly referencedTableName: TTableName;\n\tfieldName!: string;\n\n\tconstructor(\n\t\treadonly sourceTable: Table,\n\t\treadonly referencedTable: AnyTable<{ name: TTableName }>,\n\t\treadonly relationName: string | undefined,\n\t) {\n\t\tthis.referencedTableName = referencedTable[Table.Symbol.Name] as TTableName;\n\t}\n\n\tabstract withFieldName(fieldName: string): Relation<TTableName>;\n}\n\nexport class Relations<\n\tTTableName extends string = string,\n\tTConfig extends Record<string, Relation> = Record<string, Relation>,\n> {\n\tstatic readonly [entityKind]: string = 'Relations';\n\n\tdeclare readonly $brand: 'Relations';\n\n\tconstructor(\n\t\treadonly table: AnyTable<{ name: TTableName }>,\n\t\treadonly config: (helpers: TableRelationsHelpers<TTableName>) => TConfig,\n\t) {}\n}\n\nexport class One<\n\tTTableName extends string = string,\n\tTIsNullable extends boolean = boolean,\n> extends Relation<TTableName> {\n\tstatic readonly [entityKind]: string = 'One';\n\n\tdeclare protected $relationBrand: 'One';\n\n\tconstructor(\n\t\tsourceTable: Table,\n\t\treferencedTable: AnyTable<{ name: TTableName }>,\n\t\treadonly config:\n\t\t\t| RelationConfig<\n\t\t\t\tTTableName,\n\t\t\t\tstring,\n\t\t\t\tAnyColumn<{ tableName: TTableName }>[]\n\t\t\t>\n\t\t\t| undefined,\n\t\treadonly isNullable: TIsNullable,\n\t) {\n\t\tsuper(sourceTable, referencedTable, config?.relationName);\n\t}\n\n\twithFieldName(fieldName: string): One<TTableName> {\n\t\tconst relation = new One(\n\t\t\tthis.sourceTable,\n\t\t\tthis.referencedTable,\n\t\t\tthis.config,\n\t\t\tthis.isNullable,\n\t\t);\n\t\trelation.fieldName = fieldName;\n\t\treturn relation;\n\t}\n}\n\nexport class Many<TTableName extends string> extends Relation<TTableName> {\n\tstatic readonly [entityKind]: string = 'Many';\n\n\tdeclare protected $relationBrand: 'Many';\n\n\tconstructor(\n\t\tsourceTable: Table,\n\t\treferencedTable: AnyTable<{ name: TTableName }>,\n\t\treadonly config: { relationName: string } | undefined,\n\t) {\n\t\tsuper(sourceTable, referencedTable, config?.relationName);\n\t}\n\n\twithFieldName(fieldName: string): Many<TTableName> {\n\t\tconst relation = new Many(\n\t\t\tthis.sourceTable,\n\t\t\tthis.referencedTable,\n\t\t\tthis.config,\n\t\t);\n\t\trelation.fieldName = fieldName;\n\t\treturn relation;\n\t}\n}\n\nexport type TableRelationsKeysOnly<\n\tTSchema extends Record<string, unknown>,\n\tTTableName extends string,\n\tK extends keyof TSchema,\n> = TSchema[K] extends Relations<TTableName> ? K : never;\n\nexport type ExtractTableRelationsFromSchema<\n\tTSchema extends Record<string, unknown>,\n\tTTableName extends string,\n> = ExtractObjectValues<\n\t{\n\t\t[\n\t\t\tK in keyof TSchema as TableRelationsKeysOnly<\n\t\t\t\tTSchema,\n\t\t\t\tTTableName,\n\t\t\t\tK\n\t\t\t>\n\t\t]: TSchema[K] extends Relations<TTableName, infer TConfig> ? TConfig : never;\n\t}\n>;\n\nexport type ExtractObjectValues<T> = T[keyof T];\n\nexport type ExtractRelationsFromTableExtraConfigSchema<\n\tTConfig extends unknown[],\n> = ExtractObjectValues<\n\t{\n\t\t[\n\t\t\tK in keyof TConfig as TConfig[K] extends Relations<any> ? K\n\t\t\t\t: never\n\t\t]: TConfig[K] extends Relations<infer TRelationConfig> ? TRelationConfig\n\t\t\t: never;\n\t}\n>;\n\nexport function getOperators() {\n\treturn {\n\t\tand,\n\t\tbetween,\n\t\teq,\n\t\texists,\n\t\tgt,\n\t\tgte,\n\t\tilike,\n\t\tinArray,\n\t\tisNull,\n\t\tisNotNull,\n\t\tlike,\n\t\tlt,\n\t\tlte,\n\t\tne,\n\t\tnot,\n\t\tnotBetween,\n\t\tnotExists,\n\t\tnotLike,\n\t\tnotIlike,\n\t\tnotInArray,\n\t\tor,\n\t\tsql,\n\t};\n}\n\nexport type Operators = ReturnType<typeof getOperators>;\n\nexport function getOrderByOperators() {\n\treturn {\n\t\tsql,\n\t\tasc,\n\t\tdesc,\n\t};\n}\n\nexport type OrderByOperators = ReturnType<typeof getOrderByOperators>;\n\nexport type FindTableByDBName<\n\tTSchema extends TablesRelationalConfig,\n\tTTableName extends string,\n> = ExtractObjectValues<\n\t{\n\t\t[\n\t\t\tK in keyof TSchema as TSchema[K]['dbName'] extends TTableName ? K\n\t\t\t\t: never\n\t\t]: TSchema[K];\n\t}\n>;\n\nexport type DBQueryConfig<\n\tTRelationType extends 'one' | 'many' = 'one' | 'many',\n\tTIsRoot extends boolean = boolean,\n\tTSchema extends TablesRelationalConfig = TablesRelationalConfig,\n\tTTableConfig extends TableRelationalConfig = TableRelationalConfig,\n> =\n\t& {\n\t\tcolumns?: {\n\t\t\t[K in keyof TTableConfig['columns']]?: boolean;\n\t\t};\n\t\twith?: {\n\t\t\t[K in keyof TTableConfig['relations']]?:\n\t\t\t\t| true\n\t\t\t\t| DBQueryConfig<\n\t\t\t\t\tTTableConfig['relations'][K] extends One ? 'one' : 'many',\n\t\t\t\t\tfalse,\n\t\t\t\t\tTSchema,\n\t\t\t\t\tFindTableByDBName<\n\t\t\t\t\t\tTSchema,\n\t\t\t\t\t\tTTableConfig['relations'][K]['referencedTableName']\n\t\t\t\t\t>\n\t\t\t\t>;\n\t\t};\n\t\textras?:\n\t\t\t| Record<string, SQL.Aliased>\n\t\t\t| ((\n\t\t\t\tfields: Simplify<\n\t\t\t\t\t[TTableConfig['columns']] extends [never] ? {}\n\t\t\t\t\t\t: TTableConfig['columns']\n\t\t\t\t>,\n\t\t\t\toperators: { sql: Operators['sql'] },\n\t\t\t) => Record<string, SQL.Aliased>);\n\t}\n\t& (TRelationType extends 'many' ? \n\t\t\t& {\n\t\t\t\twhere?:\n\t\t\t\t\t| SQL\n\t\t\t\t\t| undefined\n\t\t\t\t\t| ((\n\t\t\t\t\t\tfields: Simplify<\n\t\t\t\t\t\t\t[TTableConfig['columns']] extends [never] ? {}\n\t\t\t\t\t\t\t\t: TTableConfig['columns']\n\t\t\t\t\t\t>,\n\t\t\t\t\t\toperators: Operators,\n\t\t\t\t\t) => SQL | undefined);\n\t\t\t\torderBy?:\n\t\t\t\t\t| ValueOrArray<AnyColumn | SQL>\n\t\t\t\t\t| ((\n\t\t\t\t\t\tfields: Simplify<\n\t\t\t\t\t\t\t[TTableConfig['columns']] extends [never] ? {}\n\t\t\t\t\t\t\t\t: TTableConfig['columns']\n\t\t\t\t\t\t>,\n\t\t\t\t\t\toperators: OrderByOperators,\n\t\t\t\t\t) => ValueOrArray<AnyColumn | SQL>);\n\t\t\t\tlimit?: number | Placeholder;\n\t\t\t}\n\t\t\t& (TIsRoot extends true ? {\n\t\t\t\t\toffset?: number | Placeholder;\n\t\t\t\t}\n\t\t\t\t: {})\n\t\t: {});\n\nexport interface TableRelationalConfig {\n\ttsName: string;\n\tdbName: string;\n\tcolumns: Record<string, Column>;\n\trelations: Record<string, Relation>;\n\tprimaryKey: AnyColumn[];\n\tschema?: string;\n}\n\nexport type TablesRelationalConfig = Record<string, TableRelationalConfig>;\n\nexport interface RelationalSchemaConfig<\n\tTSchema extends TablesRelationalConfig,\n> {\n\tfullSchema: Record<string, unknown>;\n\tschema: TSchema;\n\ttableNamesMap: Record<string, string>;\n}\n\nexport type ExtractTablesWithRelations<\n\tTSchema extends Record<string, unknown>,\n> = {\n\t[\n\t\tK in keyof TSchema as TSchema[K] extends Table ? K\n\t\t\t: never\n\t]: TSchema[K] extends Table ? {\n\t\t\ttsName: K & string;\n\t\t\tdbName: TSchema[K]['_']['name'];\n\t\t\tcolumns: TSchema[K]['_']['columns'];\n\t\t\trelations: ExtractTableRelationsFromSchema<\n\t\t\t\tTSchema,\n\t\t\t\tTSchema[K]['_']['name']\n\t\t\t>;\n\t\t\tprimaryKey: AnyColumn[];\n\t\t}\n\t\t: never;\n};\n\nexport type ReturnTypeOrValue<T> = T extends (...args: any[]) => infer R ? R\n\t: T;\n\nexport type BuildRelationResult<\n\tTSchema extends TablesRelationalConfig,\n\tTInclude,\n\tTRelations extends Record<string, Relation>,\n> = {\n\t[\n\t\tK in\n\t\t\t& NonUndefinedKeysOnly<TInclude>\n\t\t\t& keyof TRelations\n\t]: TRelations[K] extends infer TRel extends Relation ? BuildQueryResult<\n\t\t\tTSchema,\n\t\t\tFindTableByDBName<TSchema, TRel['referencedTableName']>,\n\t\t\tAssume<TInclude[K], true | Record<string, unknown>>\n\t\t> extends infer TResult ? TRel extends One ? \n\t\t\t\t\t| TResult\n\t\t\t\t\t| (Equal<TRel['isNullable'], false> extends true ? null : never)\n\t\t\t: TResult[]\n\t\t: never\n\t\t: never;\n};\n\nexport type NonUndefinedKeysOnly<T> =\n\t& ExtractObjectValues<\n\t\t{\n\t\t\t[K in keyof T as T[K] extends undefined ? never : K]: K;\n\t\t}\n\t>\n\t& keyof T;\n\nexport type BuildQueryResult<\n\tTSchema extends TablesRelationalConfig,\n\tTTableConfig extends TableRelationalConfig,\n\tTFullSelection extends true | Record<string, unknown>,\n> = Equal<TFullSelection, true> extends true ? InferModelFromColumns<TTableConfig['columns']>\n\t: TFullSelection extends Record<string, unknown> ? Simplify<\n\t\t\t& (TFullSelection['columns'] extends Record<string, unknown> ? InferModelFromColumns<\n\t\t\t\t\t{\n\t\t\t\t\t\t[\n\t\t\t\t\t\t\tK in Equal<\n\t\t\t\t\t\t\t\tExclude<\n\t\t\t\t\t\t\t\t\tTFullSelection['columns'][\n\t\t\t\t\t\t\t\t\t\t& keyof TFullSelection['columns']\n\t\t\t\t\t\t\t\t\t\t& keyof TTableConfig['columns']\n\t\t\t\t\t\t\t\t\t],\n\t\t\t\t\t\t\t\t\tundefined\n\t\t\t\t\t\t\t\t>,\n\t\t\t\t\t\t\t\tfalse\n\t\t\t\t\t\t\t> extends true ? Exclude<\n\t\t\t\t\t\t\t\t\tkeyof TTableConfig['columns'],\n\t\t\t\t\t\t\t\t\tNonUndefinedKeysOnly<TFullSelection['columns']>\n\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t: \n\t\t\t\t\t\t\t\t\t& {\n\t\t\t\t\t\t\t\t\t\t[K in keyof TFullSelection['columns']]: Equal<\n\t\t\t\t\t\t\t\t\t\t\tTFullSelection['columns'][K],\n\t\t\t\t\t\t\t\t\t\t\ttrue\n\t\t\t\t\t\t\t\t\t\t> extends true ? K\n\t\t\t\t\t\t\t\t\t\t\t: never;\n\t\t\t\t\t\t\t\t\t}[keyof TFullSelection['columns']]\n\t\t\t\t\t\t\t\t\t& keyof TTableConfig['columns']\n\t\t\t\t\t\t]: TTableConfig['columns'][K];\n\t\t\t\t\t}\n\t\t\t\t>\n\t\t\t\t: InferModelFromColumns<TTableConfig['columns']>)\n\t\t\t& (TFullSelection['extras'] extends\n\t\t\t\t| Record<string, unknown>\n\t\t\t\t| ((...args: any[]) => Record<string, unknown>) ? {\n\t\t\t\t\t[\n\t\t\t\t\t\tK in NonUndefinedKeysOnly<\n\t\t\t\t\t\t\tReturnTypeOrValue<TFullSelection['extras']>\n\t\t\t\t\t\t>\n\t\t\t\t\t]: Assume<\n\t\t\t\t\t\tReturnTypeOrValue<TFullSelection['extras']>[K],\n\t\t\t\t\t\tSQL.Aliased\n\t\t\t\t\t>['_']['type'];\n\t\t\t\t}\n\t\t\t\t: {})\n\t\t\t& (TFullSelection['with'] extends Record<string, unknown> ? BuildRelationResult<\n\t\t\t\t\tTSchema,\n\t\t\t\t\tTFullSelection['with'],\n\t\t\t\t\tTTableConfig['relations']\n\t\t\t\t>\n\t\t\t\t: {})\n\t\t>\n\t: never;\n\nexport interface RelationConfig<\n\tTTableName extends string,\n\tTForeignTableName extends string,\n\tTColumns extends AnyColumn<{ tableName: TTableName }>[],\n> {\n\trelationName?: string;\n\tfields: TColumns;\n\treferences: ColumnsWithTable<TTableName, TForeignTableName, TColumns>;\n}\n\nexport function extractTablesRelationalConfig<\n\tTTables extends TablesRelationalConfig,\n>(\n\tschema: Record<string, unknown>,\n\tconfigHelpers: (table: Table) => any,\n): { tables: TTables; tableNamesMap: Record<string, string> } {\n\tif (\n\t\tObject.keys(schema).length === 1\n\t\t&& 'default' in schema\n\t\t&& !is(schema['default'], Table)\n\t) {\n\t\tschema = schema['default'] as Record<string, unknown>;\n\t}\n\n\t// table DB name -> schema table key\n\tconst tableNamesMap: Record<string, string> = {};\n\t// Table relations found before their tables - need to buffer them until we know the schema table key\n\tconst relationsBuffer: Record<\n\t\tstring,\n\t\t{ relations: Record<string, Relation>; primaryKey?: AnyColumn[] }\n\t> = {};\n\tconst tablesConfig: TablesRelationalConfig = {};\n\tfor (const [key, value] of Object.entries(schema)) {\n\t\tif (isTable(value)) {\n\t\t\tconst dbName = value[Table.Symbol.Name];\n\t\t\tconst bufferedRelations = relationsBuffer[dbName];\n\t\t\ttableNamesMap[dbName] = key;\n\t\t\ttablesConfig[key] = {\n\t\t\t\ttsName: key,\n\t\t\t\tdbName: value[Table.Symbol.Name],\n\t\t\t\tschema: value[Table.Symbol.Schema],\n\t\t\t\tcolumns: value[Table.Symbol.Columns],\n\t\t\t\trelations: bufferedRelations?.relations ?? {},\n\t\t\t\tprimaryKey: bufferedRelations?.primaryKey ?? [],\n\t\t\t};\n\n\t\t\t// Fill in primary keys\n\t\t\tfor (\n\t\t\t\tconst column of Object.values(\n\t\t\t\t\t(value as Table)[Table.Symbol.Columns],\n\t\t\t\t)\n\t\t\t) {\n\t\t\t\tif (column.primary) {\n\t\t\t\t\ttablesConfig[key]!.primaryKey.push(column);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst extraConfig = value[Table.Symbol.ExtraConfigBuilder]?.(value);\n\t\t\tif (extraConfig) {\n\t\t\t\tfor (const configEntry of Object.values(extraConfig)) {\n\t\t\t\t\tif (is(configEntry, PrimaryKeyBuilder)) {\n\t\t\t\t\t\ttablesConfig[key]!.primaryKey.push(...configEntry.columns);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (is(value, Relations)) {\n\t\t\tconst dbName: string = value.table[Table.Symbol.Name];\n\t\t\tconst tableName = tableNamesMap[dbName];\n\t\t\tconst relations: Record<string, Relation> = value.config(\n\t\t\t\tconfigHelpers(value.table),\n\t\t\t);\n\t\t\tlet primaryKey: AnyColumn[] | undefined;\n\n\t\t\tfor (const [relationName, relation] of Object.entries(relations)) {\n\t\t\t\tif (tableName) {\n\t\t\t\t\tconst tableConfig = tablesConfig[tableName]!;\n\t\t\t\t\ttableConfig.relations[relationName] = relation;\n\t\t\t\t\tif (primaryKey) {\n\t\t\t\t\t\ttableConfig.primaryKey.push(...primaryKey);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (!(dbName in relationsBuffer)) {\n\t\t\t\t\t\trelationsBuffer[dbName] = {\n\t\t\t\t\t\t\trelations: {},\n\t\t\t\t\t\t\tprimaryKey,\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t\trelationsBuffer[dbName]!.relations[relationName] = relation;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn { tables: tablesConfig as TTables, tableNamesMap };\n}\n\nexport function relations<\n\tTTableName extends string,\n\tTRelations extends Record<string, Relation<any>>,\n>(\n\ttable: AnyTable<{ name: TTableName }>,\n\trelations: (helpers: TableRelationsHelpers<TTableName>) => TRelations,\n): Relations<TTableName, TRelations> {\n\treturn new Relations<TTableName, TRelations>(\n\t\ttable,\n\t\t(helpers: TableRelationsHelpers<TTableName>) =>\n\t\t\tObject.fromEntries(\n\t\t\t\tObject.entries(relations(helpers)).map(([key, value]) => [\n\t\t\t\t\tkey,\n\t\t\t\t\tvalue.withFieldName(key),\n\t\t\t\t]),\n\t\t\t) as TRelations,\n\t);\n}\n\nexport function createOne<TTableName extends string>(sourceTable: Table) {\n\treturn function one<\n\t\tTForeignTable extends Table,\n\t\tTColumns extends [\n\t\t\tAnyColumn<{ tableName: TTableName }>,\n\t\t\t...AnyColumn<{ tableName: TTableName }>[],\n\t\t],\n\t>(\n\t\ttable: TForeignTable,\n\t\tconfig?: RelationConfig<TTableName, TForeignTable['_']['name'], TColumns>,\n\t): One<\n\t\tTForeignTable['_']['name'],\n\t\tEqual<TColumns[number]['_']['notNull'], true>\n\t> {\n\t\treturn new One(\n\t\t\tsourceTable,\n\t\t\ttable,\n\t\t\tconfig,\n\t\t\t(config?.fields.reduce<boolean>((res, f) => res && f.notNull, true)\n\t\t\t\t?? false) as Equal<TColumns[number]['_']['notNull'], true>,\n\t\t);\n\t};\n}\n\nexport function createMany(sourceTable: Table) {\n\treturn function many<TForeignTable extends Table>(\n\t\treferencedTable: TForeignTable,\n\t\tconfig?: { relationName: string },\n\t): Many<TForeignTable['_']['name']> {\n\t\treturn new Many(sourceTable, referencedTable, config);\n\t};\n}\n\nexport interface NormalizedRelation {\n\tfields: AnyColumn[];\n\treferences: AnyColumn[];\n}\n\nexport function normalizeRelation(\n\tschema: TablesRelationalConfig,\n\ttableNamesMap: Record<string, string>,\n\trelation: Relation,\n): NormalizedRelation {\n\tif (is(relation, One) && relation.config) {\n\t\treturn {\n\t\t\tfields: relation.config.fields,\n\t\t\treferences: relation.config.references,\n\t\t};\n\t}\n\n\tconst referencedTableTsName = tableNamesMap[relation.referencedTable[Table.Symbol.Name]];\n\tif (!referencedTableTsName) {\n\t\tthrow new Error(\n\t\t\t`Table \"${relation.referencedTable[Table.Symbol.Name]}\" not found in schema`,\n\t\t);\n\t}\n\n\tconst referencedTableConfig = schema[referencedTableTsName];\n\tif (!referencedTableConfig) {\n\t\tthrow new Error(`Table \"${referencedTableTsName}\" not found in schema`);\n\t}\n\n\tconst sourceTable = relation.sourceTable;\n\tconst sourceTableTsName = tableNamesMap[sourceTable[Table.Symbol.Name]];\n\tif (!sourceTableTsName) {\n\t\tthrow new Error(\n\t\t\t`Table \"${sourceTable[Table.Symbol.Name]}\" not found in schema`,\n\t\t);\n\t}\n\n\tconst reverseRelations: Relation[] = [];\n\tfor (\n\t\tconst referencedTableRelation of Object.values(\n\t\t\treferencedTableConfig.relations,\n\t\t)\n\t) {\n\t\tif (\n\t\t\t(relation.relationName\n\t\t\t\t&& relation !== referencedTableRelation\n\t\t\t\t&& referencedTableRelation.relationName === relation.relationName)\n\t\t\t|| (!relation.relationName\n\t\t\t\t&& referencedTableRelation.referencedTable === relation.sourceTable)\n\t\t) {\n\t\t\treverseRelations.push(referencedTableRelation);\n\t\t}\n\t}\n\n\tif (reverseRelations.length > 1) {\n\t\tthrow relation.relationName\n\t\t\t? new Error(\n\t\t\t\t`There are multiple relations with name \"${relation.relationName}\" in table \"${referencedTableTsName}\"`,\n\t\t\t)\n\t\t\t: new Error(\n\t\t\t\t`There are multiple relations between \"${referencedTableTsName}\" and \"${\n\t\t\t\t\trelation.sourceTable[Table.Symbol.Name]\n\t\t\t\t}\". Please specify relation name`,\n\t\t\t);\n\t}\n\n\tif (\n\t\treverseRelations[0]\n\t\t&& is(reverseRelations[0], One)\n\t\t&& reverseRelations[0].config\n\t) {\n\t\treturn {\n\t\t\tfields: reverseRelations[0].config.references,\n\t\t\treferences: reverseRelations[0].config.fields,\n\t\t};\n\t}\n\n\tthrow new Error(\n\t\t`There is not enough information to infer relation \"${sourceTableTsName}.${relation.fieldName}\"`,\n\t);\n}\n\nexport function createTableRelationsHelpers<TTableName extends string>(\n\tsourceTable: AnyTable<{ name: TTableName }>,\n) {\n\treturn {\n\t\tone: createOne<TTableName>(sourceTable),\n\t\tmany: createMany(sourceTable),\n\t};\n}\n\nexport type TableRelationsHelpers<TTableName extends string> = ReturnType<\n\ttypeof createTableRelationsHelpers<TTableName>\n>;\n\nexport interface BuildRelationalQueryResult<\n\tTTable extends Table = Table,\n\tTColumn extends Column = Column,\n> {\n\ttableTsKey: string;\n\tselection: {\n\t\tdbKey: string;\n\t\ttsKey: string;\n\t\tfield: TColumn | SQL | SQL.Aliased;\n\t\trelationTableTsKey: string | undefined;\n\t\tisJson: boolean;\n\t\tisExtra?: boolean;\n\t\tselection: BuildRelationalQueryResult<TTable>['selection'];\n\t}[];\n\tsql: TTable | SQL;\n}\n\nexport function mapRelationalRow(\n\ttablesConfig: TablesRelationalConfig,\n\ttableConfig: TableRelationalConfig,\n\trow: unknown[],\n\tbuildQueryResultSelection: BuildRelationalQueryResult['selection'],\n\tmapColumnValue: (value: unknown) => unknown = (value) => value,\n): Record<string, unknown> {\n\tconst result: Record<string, unknown> = {};\n\n\tfor (\n\t\tconst [\n\t\t\tselectionItemIndex,\n\t\t\tselectionItem,\n\t\t] of buildQueryResultSelection.entries()\n\t) {\n\t\tif (selectionItem.isJson) {\n\t\t\tconst relation = tableConfig.relations[selectionItem.tsKey]!;\n\t\t\tconst rawSubRows = row[selectionItemIndex] as\n\t\t\t\t| unknown[]\n\t\t\t\t| null\n\t\t\t\t| [null]\n\t\t\t\t| string;\n\t\t\tconst subRows = typeof rawSubRows === 'string'\n\t\t\t\t? (JSON.parse(rawSubRows) as unknown[])\n\t\t\t\t: rawSubRows;\n\t\t\tresult[selectionItem.tsKey] = is(relation, One)\n\t\t\t\t? subRows\n\t\t\t\t\t&& mapRelationalRow(\n\t\t\t\t\t\ttablesConfig,\n\t\t\t\t\t\ttablesConfig[selectionItem.relationTableTsKey!]!,\n\t\t\t\t\t\tsubRows,\n\t\t\t\t\t\tselectionItem.selection,\n\t\t\t\t\t\tmapColumnValue,\n\t\t\t\t\t)\n\t\t\t\t: (subRows as unknown[][]).map((subRow) =>\n\t\t\t\t\tmapRelationalRow(\n\t\t\t\t\t\ttablesConfig,\n\t\t\t\t\t\ttablesConfig[selectionItem.relationTableTsKey!]!,\n\t\t\t\t\t\tsubRow,\n\t\t\t\t\t\tselectionItem.selection,\n\t\t\t\t\t\tmapColumnValue,\n\t\t\t\t\t)\n\t\t\t\t);\n\t\t} else {\n\t\t\tconst value = mapColumnValue(row[selectionItemIndex]);\n\t\t\tconst field = selectionItem.field!;\n\t\t\tlet decoder;\n\t\t\tif (is(field, Column)) {\n\t\t\t\tdecoder = field;\n\t\t\t} else if (is(field, SQL)) {\n\t\t\t\tdecoder = field.decoder;\n\t\t\t} else {\n\t\t\t\tdecoder = field.sql.decoder;\n\t\t\t}\n\t\t\tresult[selectionItem.tsKey] = value === null ? null : decoder.mapFromDriverValue(value);\n\t\t}\n\t}\n\n\treturn result;\n}\n","import { entityKind } from '~/entity.ts';\nimport { type ColumnsSelection, View } from '~/sql/sql.ts';\n\nexport abstract class PgViewBase<\n\tTName extends string = string,\n\tTExisting extends boolean = boolean,\n\tTSelectedFields extends ColumnsSelection = ColumnsSelection,\n> extends View<TName, TExisting, TSelectedFields> {\n\tstatic readonly [entityKind]: string = 'PgViewBase';\n\n\tdeclare readonly _: View<TName, TExisting, TSelectedFields>['_'] & {\n\t\treadonly viewBrand: 'PgViewBase';\n\t};\n}\n","import { aliasedTable, aliasedTableColumn, mapColumnsInAliasedSQLToAlias, mapColumnsInSQLToAlias } from '~/alias.ts';\nimport { Column } from '~/column.ts';\nimport { entityKind, is } from '~/entity.ts';\nimport { DrizzleError } from '~/errors.ts';\nimport type { MigrationConfig, MigrationMeta } from '~/migrator.ts';\nimport { PgColumn, PgDate, PgJson, PgJsonb, PgNumeric, PgTime, PgTimestamp, PgUUID } from '~/pg-core/columns/index.ts';\nimport type {\n\tPgDeleteConfig,\n\tPgInsertConfig,\n\tPgSelectJoinConfig,\n\tPgUpdateConfig,\n} from '~/pg-core/query-builders/index.ts';\nimport type { PgSelectConfig, SelectedFieldsOrdered } from '~/pg-core/query-builders/select.types.ts';\nimport { PgTable } from '~/pg-core/table.ts';\nimport {\n\ttype BuildRelationalQueryResult,\n\ttype DBQueryConfig,\n\tgetOperators,\n\tgetOrderByOperators,\n\tMany,\n\tnormalizeRelation,\n\tOne,\n\ttype Relation,\n\ttype TableRelationalConfig,\n\ttype TablesRelationalConfig,\n} from '~/relations.ts';\nimport { and, eq, View } from '~/sql/index.ts';\nimport {\n\ttype DriverValueEncoder,\n\ttype Name,\n\tParam,\n\ttype QueryTypingsValue,\n\ttype QueryWithTypings,\n\tSQL,\n\tsql,\n\ttype SQLChunk,\n} from '~/sql/sql.ts';\nimport { Subquery, SubqueryConfig } from '~/subquery.ts';\nimport { getTableName, Table } from '~/table.ts';\nimport { orderSelectedFields, type UpdateSet } from '~/utils.ts';\nimport { ViewBaseConfig } from '~/view-common.ts';\nimport type { PgSession } from './session.ts';\nimport { PgViewBase } from './view-base.ts';\nimport type { PgMaterializedView } from './view.ts';\n\nexport class PgDialect {\n\tstatic readonly [entityKind]: string = 'PgDialect';\n\n\tasync migrate(migrations: MigrationMeta[], session: PgSession, config: string | MigrationConfig): Promise<void> {\n\t\tconst migrationsTable = typeof config === 'string'\n\t\t\t? '__drizzle_migrations'\n\t\t\t: config.migrationsTable ?? '__drizzle_migrations';\n\t\tconst migrationsSchema = typeof config === 'string' ? 'drizzle' : config.migrationsSchema ?? 'drizzle';\n\t\tconst migrationTableCreate = sql`\n\t\t\tCREATE TABLE IF NOT EXISTS ${sql.identifier(migrationsSchema)}.${sql.identifier(migrationsTable)} (\n\t\t\t\tid SERIAL PRIMARY KEY,\n\t\t\t\thash text NOT NULL,\n\t\t\t\tcreated_at bigint\n\t\t\t)\n\t\t`;\n\t\tawait session.execute(sql`CREATE SCHEMA IF NOT EXISTS ${sql.identifier(migrationsSchema)}`);\n\t\tawait session.execute(migrationTableCreate);\n\n\t\tconst dbMigrations = await session.all<{ id: number; hash: string; created_at: string }>(\n\t\t\tsql`select id, hash, created_at from ${sql.identifier(migrationsSchema)}.${\n\t\t\t\tsql.identifier(migrationsTable)\n\t\t\t} order by created_at desc limit 1`,\n\t\t);\n\n\t\tconst lastDbMigration = dbMigrations[0];\n\t\tawait session.transaction(async (tx) => {\n\t\t\tfor await (const migration of migrations) {\n\t\t\t\tif (\n\t\t\t\t\t!lastDbMigration\n\t\t\t\t\t|| Number(lastDbMigration.created_at) < migration.folderMillis\n\t\t\t\t) {\n\t\t\t\t\tfor (const stmt of migration.sql) {\n\t\t\t\t\t\tawait tx.execute(sql.raw(stmt));\n\t\t\t\t\t}\n\t\t\t\t\tawait tx.execute(\n\t\t\t\t\t\tsql`insert into ${sql.identifier(migrationsSchema)}.${\n\t\t\t\t\t\t\tsql.identifier(migrationsTable)\n\t\t\t\t\t\t} (\"hash\", \"created_at\") values(${migration.hash}, ${migration.folderMillis})`,\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\tescapeName(name: string): string {\n\t\treturn `\"${name}\"`;\n\t}\n\n\tescapeParam(num: number): string {\n\t\treturn `$${num + 1}`;\n\t}\n\n\tescapeString(str: string): string {\n\t\treturn `'${str.replace(/'/g, \"''\")}'`;\n\t}\n\n\tprivate buildWithCTE(queries: Subquery[] | undefined): SQL | undefined {\n\t\tif (!queries?.length) return undefined;\n\n\t\tconst withSqlChunks = [sql`with `];\n\t\tfor (const [i, w] of queries.entries()) {\n\t\t\twithSqlChunks.push(sql`${sql.identifier(w[SubqueryConfig].alias)} as (${w[SubqueryConfig].sql})`);\n\t\t\tif (i < queries.length - 1) {\n\t\t\t\twithSqlChunks.push(sql`, `);\n\t\t\t}\n\t\t}\n\t\twithSqlChunks.push(sql` `);\n\t\treturn sql.join(withSqlChunks);\n\t}\n\n\tbuildDeleteQuery({ table, where, returning, withList }: PgDeleteConfig): SQL {\n\t\tconst withSql = this.buildWithCTE(withList);\n\n\t\tconst returningSql = returning\n\t\t\t? sql` returning ${this.buildSelection(returning, { isSingleTable: true })}`\n\t\t\t: undefined;\n\n\t\tconst whereSql = where ? sql` where ${where}` : undefined;\n\n\t\treturn sql`${withSql}delete from ${table}${whereSql}${returningSql}`;\n\t}\n\n\tbuildUpdateSet(table: PgTable, set: UpdateSet): SQL {\n\t\tconst setEntries = Object.entries(set);\n\n\t\tconst setSize = setEntries.length;\n\t\treturn sql.join(\n\t\t\tsetEntries\n\t\t\t\t.flatMap(([colName, value], i): SQL[] => {\n\t\t\t\t\tconst col: PgColumn = table[Table.Symbol.Columns][colName]!;\n\t\t\t\t\tconst res = sql`${sql.identifier(col.name)} = ${value}`;\n\t\t\t\t\tif (i < setSize - 1) {\n\t\t\t\t\t\treturn [res, sql.raw(', ')];\n\t\t\t\t\t}\n\t\t\t\t\treturn [res];\n\t\t\t\t}),\n\t\t);\n\t}\n\n\tbuildUpdateQuery({ table, set, where, returning, withList }: PgUpdateConfig): SQL {\n\t\tconst withSql = this.buildWithCTE(withList);\n\n\t\tconst setSql = this.buildUpdateSet(table, set);\n\n\t\tconst returningSql = returning\n\t\t\t? sql` returning ${this.buildSelection(returning, { isSingleTable: true })}`\n\t\t\t: undefined;\n\n\t\tconst whereSql = where ? sql` where ${where}` : undefined;\n\n\t\treturn sql`${withSql}update ${table} set ${setSql}${whereSql}${returningSql}`;\n\t}\n\n\t/**\n\t * Builds selection SQL with provided fields/expressions\n\t *\n\t * Examples:\n\t *\n\t * `select <selection> from`\n\t *\n\t * `insert ... returning <selection>`\n\t *\n\t * If `isSingleTable` is true, then columns won't be prefixed with table name\n\t */\n\tprivate buildSelection(\n\t\tfields: SelectedFieldsOrdered,\n\t\t{ isSingleTable = false }: { isSingleTable?: boolean } = {},\n\t): SQL {\n\t\tconst columnsLen = fields.length;\n\n\t\tconst chunks = fields\n\t\t\t.flatMap(({ field }, i) => {\n\t\t\t\tconst chunk: SQLChunk[] = [];\n\n\t\t\t\tif (is(field, SQL.Aliased) && field.isSelectionField) {\n\t\t\t\t\tchunk.push(sql.identifier(field.fieldAlias));\n\t\t\t\t} else if (is(field, SQL.Aliased) || is(field, SQL)) {\n\t\t\t\t\tconst query = is(field, SQL.Aliased) ? field.sql : field;\n\n\t\t\t\t\tif (isSingleTable) {\n\t\t\t\t\t\tchunk.push(\n\t\t\t\t\t\t\tnew SQL(\n\t\t\t\t\t\t\t\tquery.queryChunks.map((c) => {\n\t\t\t\t\t\t\t\t\tif (is(c, PgColumn)) {\n\t\t\t\t\t\t\t\t\t\treturn sql.identifier(c.name);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\treturn c;\n\t\t\t\t\t\t\t\t}),\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tchunk.push(query);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (is(field, SQL.Aliased)) {\n\t\t\t\t\t\tchunk.push(sql` as ${sql.identifier(field.fieldAlias)}`);\n\t\t\t\t\t}\n\t\t\t\t} else if (is(field, Column)) {\n\t\t\t\t\tif (isSingleTable) {\n\t\t\t\t\t\tchunk.push(sql.identifier(field.name));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tchunk.push(field);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (i < columnsLen - 1) {\n\t\t\t\t\tchunk.push(sql`, `);\n\t\t\t\t}\n\n\t\t\t\treturn chunk;\n\t\t\t});\n\n\t\treturn sql.join(chunks);\n\t}\n\n\tbuildSelectQuery(\n\t\t{\n\t\t\twithList,\n\t\t\tfields,\n\t\t\tfieldsFlat,\n\t\t\twhere,\n\t\t\thaving,\n\t\t\ttable,\n\t\t\tjoins,\n\t\t\torderBy,\n\t\t\tgroupBy,\n\t\t\tlimit,\n\t\t\toffset,\n\t\t\tlockingClause,\n\t\t\tdistinct,\n\t\t\tsetOperators,\n\t\t}: PgSelectConfig,\n\t): SQL {\n\t\tconst fieldsList = fieldsFlat ?? orderSelectedFields<PgColumn>(fields);\n\t\tfor (const f of fieldsList) {\n\t\t\tif (\n\t\t\t\tis(f.field, Column)\n\t\t\t\t&& getTableName(f.field.table)\n\t\t\t\t\t!== (is(table, Subquery)\n\t\t\t\t\t\t? table[SubqueryConfig].alias\n\t\t\t\t\t\t: is(table, PgViewBase)\n\t\t\t\t\t\t? table[ViewBaseConfig].name\n\t\t\t\t\t\t: is(table, SQL)\n\t\t\t\t\t\t? undefined\n\t\t\t\t\t\t: getTableName(table))\n\t\t\t\t&& !((table) =>\n\t\t\t\t\tjoins?.some(({ alias }) =>\n\t\t\t\t\t\talias === (table[Table.Symbol.IsAlias] ? getTableName(table) : table[Table.Symbol.BaseName])\n\t\t\t\t\t))(f.field.table)\n\t\t\t) {\n\t\t\t\tconst tableName = getTableName(f.field.table);\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`Your \"${\n\t\t\t\t\t\tf.path.join('->')\n\t\t\t\t\t}\" field references a column \"${tableName}\".\"${f.field.name}\", but the table \"${tableName}\" is not part of the query! Did you forget to join it?`,\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\tconst isSingleTable = !joins || joins.length === 0;\n\n\t\tconst withSql = this.buildWithCTE(withList);\n\n\t\tlet distinctSql: SQL | undefined;\n\t\tif (distinct) {\n\t\t\tdistinctSql = distinct === true ? sql` distinct` : sql` distinct on (${sql.join(distinct.on, sql`, `)})`;\n\t\t}\n\n\t\tconst selection = this.buildSelection(fieldsList, { isSingleTable });\n\n\t\tconst tableSql = (() => {\n\t\t\tif (is(table, Table) && table[Table.Symbol.OriginalName] !== table[Table.Symbol.Name]) {\n\t\t\t\tlet fullName = sql`${sql.identifier(table[Table.Symbol.OriginalName])}`;\n\t\t\t\tif (table[Table.Symbol.Schema]) {\n\t\t\t\t\tfullName = sql`${sql.identifier(table[Table.Symbol.Schema]!)}.${fullName}`;\n\t\t\t\t}\n\t\t\t\treturn sql`${fullName} ${sql.identifier(table[Table.Symbol.Name])}`;\n\t\t\t}\n\n\t\t\treturn table;\n\t\t})();\n\n\t\tconst joinsArray: SQL[] = [];\n\n\t\tif (joins) {\n\t\t\tfor (const [index, joinMeta] of joins.entries()) {\n\t\t\t\tif (index === 0) {\n\t\t\t\t\tjoinsArray.push(sql` `);\n\t\t\t\t}\n\t\t\t\tconst table = joinMeta.table;\n\t\t\t\tconst lateralSql = joinMeta.lateral ? sql` lateral` : undefined;\n\n\t\t\t\tif (is(table, PgTable)) {\n\t\t\t\t\tconst tableName = table[PgTable.Symbol.Name];\n\t\t\t\t\tconst tableSchema = table[PgTable.Symbol.Schema];\n\t\t\t\t\tconst origTableName = table[PgTable.Symbol.OriginalName];\n\t\t\t\t\tconst alias = tableName === origTableName ? undefined : joinMeta.alias;\n\t\t\t\t\tjoinsArray.push(\n\t\t\t\t\t\tsql`${sql.raw(joinMeta.joinType)} join${lateralSql} ${\n\t\t\t\t\t\t\ttableSchema ? sql`${sql.identifier(tableSchema)}.` : undefined\n\t\t\t\t\t\t}${sql.identifier(origTableName)}${alias && sql` ${sql.identifier(alias)}`} on ${joinMeta.on}`,\n\t\t\t\t\t);\n\t\t\t\t} else if (is(table, View)) {\n\t\t\t\t\tconst viewName = table[ViewBaseConfig].name;\n\t\t\t\t\tconst viewSchema = table[ViewBaseConfig].schema;\n\t\t\t\t\tconst origViewName = table[ViewBaseConfig].originalName;\n\t\t\t\t\tconst alias = viewName === origViewName ? undefined : joinMeta.alias;\n\t\t\t\t\tjoinsArray.push(\n\t\t\t\t\t\tsql`${sql.raw(joinMeta.joinType)} join${lateralSql} ${\n\t\t\t\t\t\t\tviewSchema ? sql`${sql.identifier(viewSchema)}.` : undefined\n\t\t\t\t\t\t}${sql.identifier(origViewName)}${alias && sql` ${sql.identifier(alias)}`} on ${joinMeta.on}`,\n\t\t\t\t\t);\n\t\t\t\t} else {\n\t\t\t\t\tjoinsArray.push(\n\t\t\t\t\t\tsql`${sql.raw(joinMeta.joinType)} join${lateralSql} ${table} on ${joinMeta.on}`,\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tif (index < joins.length - 1) {\n\t\t\t\t\tjoinsArray.push(sql` `);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst joinsSql = sql.join(joinsArray);\n\n\t\tconst whereSql = where ? sql` where ${where}` : undefined;\n\n\t\tconst havingSql = having ? sql` having ${having}` : undefined;\n\n\t\tlet orderBySql;\n\t\tif (orderBy && orderBy.length > 0) {\n\t\t\torderBySql = sql` order by ${sql.join(orderBy, sql`, `)}`;\n\t\t}\n\n\t\tlet groupBySql;\n\t\tif (groupBy && groupBy.length > 0) {\n\t\t\tgroupBySql = sql` group by ${sql.join(groupBy, sql`, `)}`;\n\t\t}\n\n\t\tconst limitSql = limit ? sql` limit ${limit}` : undefined;\n\n\t\tconst offsetSql = offset ? sql` offset ${offset}` : undefined;\n\n\t\tconst lockingClauseSql = sql.empty();\n\t\tif (lockingClause) {\n\t\t\tconst clauseSql = sql` for ${sql.raw(lockingClause.strength)}`;\n\t\t\tif (lockingClause.config.of) {\n\t\t\t\tclauseSql.append(\n\t\t\t\t\tsql` of ${\n\t\t\t\t\t\tsql.join(\n\t\t\t\t\t\t\tArray.isArray(lockingClause.config.of) ? lockingClause.config.of : [lockingClause.config.of],\n\t\t\t\t\t\t\tsql`, `,\n\t\t\t\t\t\t)\n\t\t\t\t\t}`,\n\t\t\t\t);\n\t\t\t}\n\t\t\tif (lockingClause.config.noWait) {\n\t\t\t\tclauseSql.append(sql` no wait`);\n\t\t\t} else if (lockingClause.config.skipLocked) {\n\t\t\t\tclauseSql.append(sql` skip locked`);\n\t\t\t}\n\t\t\tlockingClauseSql.append(clauseSql);\n\t\t}\n\t\tconst finalQuery =\n\t\t\tsql`${withSql}select${distinctSql} ${selection} from ${tableSql}${joinsSql}${whereSql}${groupBySql}${havingSql}${orderBySql}${limitSql}${offsetSql}${lockingClauseSql}`;\n\n\t\tif (setOperators.length > 0) {\n\t\t\treturn this.buildSetOperations(finalQuery, setOperators);\n\t\t}\n\n\t\treturn finalQuery;\n\t}\n\n\tbuildSetOperations(leftSelect: SQL, setOperators: PgSelectConfig['setOperators']): SQL {\n\t\tconst [setOperator, ...rest] = setOperators;\n\n\t\tif (!setOperator) {\n\t\t\tthrow new Error('Cannot pass undefined values to any set operator');\n\t\t}\n\n\t\tif (rest.length === 0) {\n\t\t\treturn this.buildSetOperationQuery({ leftSelect, setOperator });\n\t\t}\n\n\t\t// Some recursive magic here\n\t\treturn this.buildSetOperations(\n\t\t\tthis.buildSetOperationQuery({ leftSelect, setOperator }),\n\t\t\trest,\n\t\t);\n\t}\n\n\tbuildSetOperationQuery({\n\t\tleftSelect,\n\t\tsetOperator: { type, isAll, rightSelect, limit, orderBy, offset },\n\t}: { leftSelect: SQL; setOperator: PgSelectConfig['setOperators'][number] }): SQL {\n\t\tconst leftChunk = sql`(${leftSelect.getSQL()}) `;\n\t\tconst rightChunk = sql`(${rightSelect.getSQL()})`;\n\n\t\tlet orderBySql;\n\t\tif (orderBy && orderBy.length > 0) {\n\t\t\tconst orderByValues: (SQL<unknown> | Name)[] = [];\n\n\t\t\t// The next bit is necessary because the sql operator replaces ${table.column} with `table`.`column`\n\t\t\t// which is invalid Sql syntax, Table from one of the SELECTs cannot be used in global ORDER clause\n\t\t\tfor (const singleOrderBy of orderBy) {\n\t\t\t\tif (is(singleOrderBy, PgColumn)) {\n\t\t\t\t\torderByValues.push(sql.identifier(singleOrderBy.name));\n\t\t\t\t} else if (is(singleOrderBy, SQL)) {\n\t\t\t\t\tfor (let i = 0; i < singleOrderBy.queryChunks.length; i++) {\n\t\t\t\t\t\tconst chunk = singleOrderBy.queryChunks[i];\n\n\t\t\t\t\t\tif (is(chunk, PgColumn)) {\n\t\t\t\t\t\t\tsingleOrderBy.queryChunks[i] = sql.identifier(chunk.name);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\torderByValues.push(sql`${singleOrderBy}`);\n\t\t\t\t} else {\n\t\t\t\t\torderByValues.push(sql`${singleOrderBy}`);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\torderBySql = sql` order by ${sql.join(orderByValues, sql`, `)} `;\n\t\t}\n\n\t\tconst limitSql = limit ? sql` limit ${limit}` : undefined;\n\n\t\tconst operatorChunk = sql.raw(`${type} ${isAll ? 'all ' : ''}`);\n\n\t\tconst offsetSql = offset ? sql` offset ${offset}` : undefined;\n\n\t\treturn sql`${leftChunk}${operatorChunk}${rightChunk}${orderBySql}${limitSql}${offsetSql}`;\n\t}\n\n\tbuildInsertQuery({ table, values, onConflict, returning, withList }: PgInsertConfig): SQL {\n\t\tconst valuesSqlList: ((SQLChunk | SQL)[] | SQL)[] = [];\n\t\tconst columns: Record<string, PgColumn> = table[Table.Symbol.Columns];\n\n\t\tconst colEntries: [string, PgColumn][] = Object.entries(columns);\n\n\t\tconst insertOrder = colEntries.map(([, column]) => sql.identifier(column.name));\n\n\t\tfor (const [valueIndex, value] of values.entries()) {\n\t\t\tconst valueList: (SQLChunk | SQL)[] = [];\n\t\t\tfor (const [fieldName, col] of colEntries) {\n\t\t\t\tconst colValue = value[fieldName];\n\t\t\t\tif (colValue === undefined || (is(colValue, Param) && colValue.value === undefined)) {\n\t\t\t\t\t// eslint-disable-next-line unicorn/no-negated-condition\n\t\t\t\t\tif (col.defaultFn !== undefined) {\n\t\t\t\t\t\tconst defaultFnResult = col.defaultFn();\n\t\t\t\t\t\tconst defaultValue = is(defaultFnResult, SQL) ? defaultFnResult : sql.param(defaultFnResult, col);\n\t\t\t\t\t\tvalueList.push(defaultValue);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvalueList.push(sql`default`);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tvalueList.push(colValue);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvaluesSqlList.push(valueList);\n\t\t\tif (valueIndex < values.length - 1) {\n\t\t\t\tvaluesSqlList.push(sql`, `);\n\t\t\t}\n\t\t}\n\n\t\tconst withSql = this.buildWithCTE(withList);\n\n\t\tconst valuesSql = sql.join(valuesSqlList);\n\n\t\tconst returningSql = returning\n\t\t\t? sql` returning ${this.buildSelection(returning, { isSingleTable: true })}`\n\t\t\t: undefined;\n\n\t\tconst onConflictSql = onConflict ? sql` on conflict ${onConflict}` : undefined;\n\n\t\treturn sql`${withSql}insert into ${table} ${insertOrder} values ${valuesSql}${onConflictSql}${returningSql}`;\n\t}\n\n\tbuildRefreshMaterializedViewQuery(\n\t\t{ view, concurrently, withNoData }: { view: PgMaterializedView; concurrently?: boolean; withNoData?: boolean },\n\t): SQL {\n\t\tconst concurrentlySql = concurrently ? sql` concurrently` : undefined;\n\t\tconst withNoDataSql = withNoData ? sql` with no data` : undefined;\n\n\t\treturn sql`refresh materialized view${concurrentlySql} ${view}${withNoDataSql}`;\n\t}\n\n\tprepareTyping(encoder: DriverValueEncoder<unknown, unknown>): QueryTypingsValue {\n\t\tif (\n\t\t\tis(encoder, PgJsonb) || is(encoder, PgJson)\n\t\t) {\n\t\t\treturn 'json';\n\t\t} else if (is(encoder, PgNumeric)) {\n\t\t\treturn 'decimal';\n\t\t} else if (is(encoder, PgTime)) {\n\t\t\treturn 'time';\n\t\t} else if (is(encoder, PgTimestamp)) {\n\t\t\treturn 'timestamp';\n\t\t} else if (is(encoder, PgDate)) {\n\t\t\treturn 'date';\n\t\t} else if (is(encoder, PgUUID)) {\n\t\t\treturn 'uuid';\n\t\t} else {\n\t\t\treturn 'none';\n\t\t}\n\t}\n\n\tsqlToQuery(sql: SQL): QueryWithTypings {\n\t\treturn sql.toQuery({\n\t\t\tescapeName: this.escapeName,\n\t\t\tescapeParam: this.escapeParam,\n\t\t\tescapeString: this.escapeString,\n\t\t\tprepareTyping: this.prepareTyping,\n\t\t});\n\t}\n\n\t// buildRelationalQueryWithPK({\n\t// \tfullSchema,\n\t// \tschema,\n\t// \ttableNamesMap,\n\t// \ttable,\n\t// \ttableConfig,\n\t// \tqueryConfig: config,\n\t// \ttableAlias,\n\t// \tisRoot = false,\n\t// \tjoinOn,\n\t// }: {\n\t// \tfullSchema: Record<string, unknown>;\n\t// \tschema: TablesRelationalConfig;\n\t// \ttableNamesMap: Record<string, string>;\n\t// \ttable: PgTable;\n\t// \ttableConfig: TableRelationalConfig;\n\t// \tqueryConfig: true | DBQueryConfig<'many', true>;\n\t// \ttableAlias: string;\n\t// \tisRoot?: boolean;\n\t// \tjoinOn?: SQL;\n\t// }): BuildRelationalQueryResult<PgTable, PgColumn> {\n\t// \t// For { \"<relation>\": true }, return a table with selection of all columns\n\t// \tif (config === true) {\n\t// \t\tconst selectionEntries = Object.entries(tableConfig.columns);\n\t// \t\tconst selection: BuildRelationalQueryResult<PgTable, PgColumn>['selection'] = selectionEntries.map((\n\t// \t\t\t[key, value],\n\t// \t\t) => ({\n\t// \t\t\tdbKey: value.name,\n\t// \t\t\ttsKey: key,\n\t// \t\t\tfield: value as PgColumn,\n\t// \t\t\trelationTableTsKey: undefined,\n\t// \t\t\tisJson: false,\n\t// \t\t\tselection: [],\n\t// \t\t}));\n\n\t// \t\treturn {\n\t// \t\t\ttableTsKey: tableConfig.tsName,\n\t// \t\t\tsql: table,\n\t// \t\t\tselection,\n\t// \t\t};\n\t// \t}\n\n\t// \t// let selection: BuildRelationalQueryResult<PgTable, PgColumn>['selection'] = [];\n\t// \t// let selectionForBuild = selection;\n\n\t// \tconst aliasedColumns = Object.fromEntries(\n\t// \t\tObject.entries(tableConfig.columns).map(([key, value]) => [key, aliasedTableColumn(value, tableAlias)]),\n\t// \t);\n\n\t// \tconst aliasedRelations = Object.fromEntries(\n\t// \t\tObject.entries(tableConfig.relations).map(([key, value]) => [key, aliasedRelation(value, tableAlias)]),\n\t// \t);\n\n\t// \tconst aliasedFields = Object.assign({}, aliasedColumns, aliasedRelations);\n\n\t// \tlet where, hasUserDefinedWhere;\n\t// \tif (config.where) {\n\t// \t\tconst whereSql = typeof config.where === 'function' ? config.where(aliasedFields, operators) : config.where;\n\t// \t\twhere = whereSql && mapColumnsInSQLToAlias(whereSql, tableAlias);\n\t// \t\thasUserDefinedWhere = !!where;\n\t// \t}\n\t// \twhere = and(joinOn, where);\n\n\t// \t// const fieldsSelection: { tsKey: string; value: PgColumn | SQL.Aliased; isExtra?: boolean }[] = [];\n\t// \tlet joins: Join[] = [];\n\t// \tlet selectedColumns: string[] = [];\n\n\t// \t// Figure out which columns to select\n\t// \tif (config.columns) {\n\t// \t\tlet isIncludeMode = false;\n\n\t// \t\tfor (const [field, value] of Object.entries(config.columns)) {\n\t// \t\t\tif (value === undefined) {\n\t// \t\t\t\tcontinue;\n\t// \t\t\t}\n\n\t// \t\t\tif (field in tableConfig.columns) {\n\t// \t\t\t\tif (!isIncludeMode && value === true) {\n\t// \t\t\t\t\tisIncludeMode = true;\n\t// \t\t\t\t}\n\t// \t\t\t\tselectedColumns.push(field);\n\t// \t\t\t}\n\t// \t\t}\n\n\t// \t\tif (selectedColumns.length > 0) {\n\t// \t\t\tselectedColumns = isIncludeMode\n\t// \t\t\t\t? selectedColumns.filter((c) => config.columns?.[c] === true)\n\t// \t\t\t\t: Object.keys(tableConfig.columns).filter((key) => !selectedColumns.includes(key));\n\t// \t\t}\n\t// \t} else {\n\t// \t\t// Select all columns if selection is not specified\n\t// \t\tselectedColumns = Object.keys(tableConfig.columns);\n\t// \t}\n\n\t// \t// for (const field of selectedColumns) {\n\t// \t// \tconst column = tableConfig.columns[field]! as PgColumn;\n\t// \t// \tfieldsSelection.push({ tsKey: field, value: column });\n\t// \t// }\n\n\t// \tlet initiallySelectedRelations: {\n\t// \t\ttsKey: string;\n\t// \t\tqueryConfig: true | DBQueryConfig<'many', false>;\n\t// \t\trelation: Relation;\n\t// \t}[] = [];\n\n\t// \t// let selectedRelations: BuildRelationalQueryResult<PgTable, PgColumn>['selection'] = [];\n\n\t// \t// Figure out which relations to select\n\t// \tif (config.with) {\n\t// \t\tinitiallySelectedRelations = Object.entries(config.with)\n\t// \t\t\t.filter((entry): entry is [typeof entry[0], NonNullable<typeof entry[1]>] => !!entry[1])\n\t// \t\t\t.map(([tsKey, queryConfig]) => ({ tsKey, queryConfig, relation: tableConfig.relations[tsKey]! }));\n\t// \t}\n\n\t// \tconst manyRelations = initiallySelectedRelations.filter((r) =>\n\t// \t\tis(r.relation, Many)\n\t// \t\t&& (schema[tableNamesMap[r.relation.referencedTable[Table.Symbol.Name]]!]?.primaryKey.length ?? 0) > 0\n\t// \t);\n\t// \t// If this is the last Many relation (or there are no Many relations), we are on the innermost subquery level\n\t// \tconst isInnermostQuery = manyRelations.length < 2;\n\n\t// \tconst selectedExtras: {\n\t// \t\ttsKey: string;\n\t// \t\tvalue: SQL.Aliased;\n\t// \t}[] = [];\n\n\t// \t// Figure out which extras to select\n\t// \tif (isInnermostQuery && config.extras) {\n\t// \t\tconst extras = typeof config.extras === 'function'\n\t// \t\t\t? config.extras(aliasedFields, { sql })\n\t// \t\t\t: config.extras;\n\t// \t\tfor (const [tsKey, value] of Object.entries(extras)) {\n\t// \t\t\tselectedExtras.push({\n\t// \t\t\t\ttsKey,\n\t// \t\t\t\tvalue: mapColumnsInAliasedSQLToAlias(value, tableAlias),\n\t// \t\t\t});\n\t// \t\t}\n\t// \t}\n\n\t// \t// Transform `fieldsSelection` into `selection`\n\t// \t// `fieldsSelection` shouldn't be used after this point\n\t// \t// for (const { tsKey, value, isExtra } of fieldsSelection) {\n\t// \t// \tselection.push({\n\t// \t// \t\tdbKey: is(value, SQL.Aliased) ? value.fieldAlias : tableConfig.columns[tsKey]!.name,\n\t// \t// \t\ttsKey,\n\t// \t// \t\tfield: is(value, Column) ? aliasedTableColumn(value, tableAlias) : value,\n\t// \t// \t\trelationTableTsKey: undefined,\n\t// \t// \t\tisJson: false,\n\t// \t// \t\tisExtra,\n\t// \t// \t\tselection: [],\n\t// \t// \t});\n\t// \t// }\n\n\t// \tlet orderByOrig = typeof config.orderBy === 'function'\n\t// \t\t? config.orderBy(aliasedFields, orderByOperators)\n\t// \t\t: config.orderBy ?? [];\n\t// \tif (!Array.isArray(orderByOrig)) {\n\t// \t\torderByOrig = [orderByOrig];\n\t// \t}\n\t// \tconst orderBy = orderByOrig.map((orderByValue) => {\n\t// \t\tif (is(orderByValue, Column)) {\n\t// \t\t\treturn aliasedTableColumn(orderByValue, tableAlias) as PgColumn;\n\t// \t\t}\n\t// \t\treturn mapColumnsInSQLToAlias(orderByValue, tableAlias);\n\t// \t});\n\n\t// \tconst limit = isInnermostQuery ? config.limit : undefined;\n\t// \tconst offset = isInnermostQuery ? config.offset : undefined;\n\n\t// \t// For non-root queries without additional config except columns, return a table with selection\n\t// \tif (\n\t// \t\t!isRoot\n\t// \t\t&& initiallySelectedRelations.length === 0\n\t// \t\t&& selectedExtras.length === 0\n\t// \t\t&& !where\n\t// \t\t&& orderBy.length === 0\n\t// \t\t&& limit === undefined\n\t// \t\t&& offset === undefined\n\t// \t) {\n\t// \t\treturn {\n\t// \t\t\ttableTsKey: tableConfig.tsName,\n\t// \t\t\tsql: table,\n\t// \t\t\tselection: selectedColumns.map((key) => ({\n\t// \t\t\t\tdbKey: tableConfig.columns[key]!.name,\n\t// \t\t\t\ttsKey: key,\n\t// \t\t\t\tfield: tableConfig.columns[key] as PgColumn,\n\t// \t\t\t\trelationTableTsKey: undefined,\n\t// \t\t\t\tisJson: false,\n\t// \t\t\t\tselection: [],\n\t// \t\t\t})),\n\t// \t\t};\n\t// \t}\n\n\t// \tconst selectedRelationsWithoutPK:\n\n\t// \t// Process all relations without primary keys, because they need to be joined differently and will all be on the same query level\n\t// \tfor (\n\t// \t\tconst {\n\t// \t\t\ttsKey: selectedRelationTsKey,\n\t// \t\t\tqueryConfig: selectedRelationConfigValue,\n\t// \t\t\trelation,\n\t// \t\t} of initiallySelectedRelations\n\t// \t) {\n\t// \t\tconst normalizedRelation = normalizeRelation(schema, tableNamesMap, relation);\n\t// \t\tconst relationTableName = relation.referencedTable[Table.Symbol.Name];\n\t// \t\tconst relationTableTsName = tableNamesMap[relationTableName]!;\n\t// \t\tconst relationTable = schema[relationTableTsName]!;\n\n\t// \t\tif (relationTable.primaryKey.length > 0) {\n\t// \t\t\tcontinue;\n\t// \t\t}\n\n\t// \t\tconst relationTableAlias = `${tableAlias}_${selectedRelationTsKey}`;\n\t// \t\tconst joinOn = and(\n\t// \t\t\t...normalizedRelation.fields.map((field, i) =>\n\t// \t\t\t\teq(\n\t// \t\t\t\t\taliasedTableColumn(normalizedRelation.references[i]!, relationTableAlias),\n\t// \t\t\t\t\taliasedTableColumn(field, tableAlias),\n\t// \t\t\t\t)\n\t// \t\t\t),\n\t// \t\t);\n\t// \t\tconst builtRelation = this.buildRelationalQueryWithoutPK({\n\t// \t\t\tfullSchema,\n\t// \t\t\tschema,\n\t// \t\t\ttableNamesMap,\n\t// \t\t\ttable: fullSchema[relationTableTsName] as PgTable,\n\t// \t\t\ttableConfig: schema[relationTableTsName]!,\n\t// \t\t\tqueryConfig: selectedRelationConfigValue,\n\t// \t\t\ttableAlias: relationTableAlias,\n\t// \t\t\tjoinOn,\n\t// \t\t\tnestedQueryRelation: relation,\n\t// \t\t});\n\t// \t\tconst field = sql`${sql.identifier(relationTableAlias)}.${sql.identifier('data')}`.as(selectedRelationTsKey);\n\t// \t\tjoins.push({\n\t// \t\t\ton: sql`true`,\n\t// \t\t\ttable: new Subquery(builtRelation.sql as SQL, {}, relationTableAlias),\n\t// \t\t\talias: relationTableAlias,\n\t// \t\t\tjoinType: 'left',\n\t// \t\t\tlateral: true,\n\t// \t\t});\n\t// \t\tselectedRelations.push({\n\t// \t\t\tdbKey: selectedRelationTsKey,\n\t// \t\t\ttsKey: selectedRelationTsKey,\n\t// \t\t\tfield,\n\t// \t\t\trelationTableTsKey: relationTableTsName,\n\t// \t\t\tisJson: true,\n\t// \t\t\tselection: builtRelation.selection,\n\t// \t\t});\n\t// \t}\n\n\t// \tconst oneRelations = initiallySelectedRelations.filter((r): r is typeof r & { relation: One } =>\n\t// \t\tis(r.relation, One)\n\t// \t);\n\n\t// \t// Process all One relations with PKs, because they can all be joined on the same level\n\t// \tfor (\n\t// \t\tconst {\n\t// \t\t\ttsKey: selectedRelationTsKey,\n\t// \t\t\tqueryConfig: selectedRelationConfigValue,\n\t// \t\t\trelation,\n\t// \t\t} of oneRelations\n\t// \t) {\n\t// \t\tconst normalizedRelation = normalizeRelation(schema, tableNamesMap, relation);\n\t// \t\tconst relationTableName = relation.referencedTable[Table.Symbol.Name];\n\t// \t\tconst relationTableTsName = tableNamesMap[relationTableName]!;\n\t// \t\tconst relationTableAlias = `${tableAlias}_${selectedRelationTsKey}`;\n\t// \t\tconst relationTable = schema[relationTableTsName]!;\n\n\t// \t\tif (relationTable.primaryKey.length === 0) {\n\t// \t\t\tcontinue;\n\t// \t\t}\n\n\t// \t\tconst joinOn = and(\n\t// \t\t\t...normalizedRelation.fields.map((field, i) =>\n\t// \t\t\t\teq(\n\t// \t\t\t\t\taliasedTableColumn(normalizedRelation.references[i]!, relationTableAlias),\n\t// \t\t\t\t\taliasedTableColumn(field, tableAlias),\n\t// \t\t\t\t)\n\t// \t\t\t),\n\t// \t\t);\n\t// \t\tconst builtRelation = this.buildRelationalQueryWithPK({\n\t// \t\t\tfullSchema,\n\t// \t\t\tschema,\n\t// \t\t\ttableNamesMap,\n\t// \t\t\ttable: fullSchema[relationTableTsName] as PgTable,\n\t// \t\t\ttableConfig: schema[relationTableTsName]!,\n\t// \t\t\tqueryConfig: selectedRelationConfigValue,\n\t// \t\t\ttableAlias: relationTableAlias,\n\t// \t\t\tjoinOn,\n\t// \t\t});\n\t// \t\tconst field = sql`case when ${sql.identifier(relationTableAlias)} is null then null else json_build_array(${\n\t// \t\t\tsql.join(\n\t// \t\t\t\tbuiltRelation.selection.map(({ field }) =>\n\t// \t\t\t\t\tis(field, SQL.Aliased)\n\t// \t\t\t\t\t\t? sql`${sql.identifier(relationTableAlias)}.${sql.identifier(field.fieldAlias)}`\n\t// \t\t\t\t\t\t: is(field, Column)\n\t// \t\t\t\t\t\t? aliasedTableColumn(field, relationTableAlias)\n\t// \t\t\t\t\t\t: field\n\t// \t\t\t\t),\n\t// \t\t\t\tsql`, `,\n\t// \t\t\t)\n\t// \t\t}) end`.as(selectedRelationTsKey);\n\t// \t\tconst isLateralJoin = is(builtRelation.sql, SQL);\n\t// \t\tjoins.push({\n\t// \t\t\ton: isLateralJoin ? sql`true` : joinOn,\n\t// \t\t\ttable: is(builtRelation.sql, SQL)\n\t// \t\t\t\t? new Subquery(builtRelation.sql, {}, relationTableAlias)\n\t// \t\t\t\t: aliasedTable(builtRelation.sql, relationTableAlias),\n\t// \t\t\talias: relationTableAlias,\n\t// \t\t\tjoinType: 'left',\n\t// \t\t\tlateral: is(builtRelation.sql, SQL),\n\t// \t\t});\n\t// \t\tselectedRelations.push({\n\t// \t\t\tdbKey: selectedRelationTsKey,\n\t// \t\t\ttsKey: selectedRelationTsKey,\n\t// \t\t\tfield,\n\t// \t\t\trelationTableTsKey: relationTableTsName,\n\t// \t\t\tisJson: true,\n\t// \t\t\tselection: builtRelation.selection,\n\t// \t\t});\n\t// \t}\n\n\t// \tlet distinct: PgSelectConfig['distinct'];\n\t// \tlet tableFrom: PgTable | Subquery = table;\n\n\t// \t// Process first Many relation - each one requires a nested subquery\n\t// \tconst manyRelation = manyRelations[0];\n\t// \tif (manyRelation) {\n\t// \t\tconst {\n\t// \t\t\ttsKey: selectedRelationTsKey,\n\t// \t\t\tqueryConfig: selectedRelationQueryConfig,\n\t// \t\t\trelation,\n\t// \t\t} = manyRelation;\n\n\t// \t\tdistinct = {\n\t// \t\t\ton: tableConfig.primaryKey.map((c) => aliasedTableColumn(c as PgColumn, tableAlias)),\n\t// \t\t};\n\n\t// \t\tconst normalizedRelation = normalizeRelation(schema, tableNamesMap, relation);\n\t// \t\tconst relationTableName = relation.referencedTable[Table.Symbol.Name];\n\t// \t\tconst relationTableTsName = tableNamesMap[relationTableName]!;\n\t// \t\tconst relationTableAlias = `${tableAlias}_${selectedRelationTsKey}`;\n\t// \t\tconst joinOn = and(\n\t// \t\t\t...normalizedRelation.fields.map((field, i) =>\n\t// \t\t\t\teq(\n\t// \t\t\t\t\taliasedTableColumn(normalizedRelation.references[i]!, relationTableAlias),\n\t// \t\t\t\t\taliasedTableColumn(field, tableAlias),\n\t// \t\t\t\t)\n\t// \t\t\t),\n\t// \t\t);\n\n\t// \t\tconst builtRelationJoin = this.buildRelationalQueryWithPK({\n\t// \t\t\tfullSchema,\n\t// \t\t\tschema,\n\t// \t\t\ttableNamesMap,\n\t// \t\t\ttable: fullSchema[relationTableTsName] as PgTable,\n\t// \t\t\ttableConfig: schema[relationTableTsName]!,\n\t// \t\t\tqueryConfig: selectedRelationQueryConfig,\n\t// \t\t\ttableAlias: relationTableAlias,\n\t// \t\t\tjoinOn,\n\t// \t\t});\n\n\t// \t\tconst builtRelationSelectionField = sql`case when ${\n\t// \t\t\tsql.identifier(relationTableAlias)\n\t// \t\t} is null then '[]' else json_agg(json_build_array(${\n\t// \t\t\tsql.join(\n\t// \t\t\t\tbuiltRelationJoin.selection.map(({ field }) =>\n\t// \t\t\t\t\tis(field, SQL.Aliased)\n\t// \t\t\t\t\t\t? sql`${sql.identifier(relationTableAlias)}.${sql.identifier(field.fieldAlias)}`\n\t// \t\t\t\t\t\t: is(field, Column)\n\t// \t\t\t\t\t\t? aliasedTableColumn(field, relationTableAlias)\n\t// \t\t\t\t\t\t: field\n\t// \t\t\t\t),\n\t// \t\t\t\tsql`, `,\n\t// \t\t\t)\n\t// \t\t})) over (partition by ${sql.join(distinct.on, sql`, `)}) end`.as(selectedRelationTsKey);\n\t// \t\tconst isLateralJoin = is(builtRelationJoin.sql, SQL);\n\t// \t\tjoins.push({\n\t// \t\t\ton: isLateralJoin ? sql`true` : joinOn,\n\t// \t\t\ttable: isLateralJoin\n\t// \t\t\t\t? new Subquery(builtRelationJoin.sql as SQL, {}, relationTableAlias)\n\t// \t\t\t\t: aliasedTable(builtRelationJoin.sql as PgTable, relationTableAlias),\n\t// \t\t\talias: relationTableAlias,\n\t// \t\t\tjoinType: 'left',\n\t// \t\t\tlateral: isLateralJoin,\n\t// \t\t});\n\n\t// \t\t// Build the \"from\" subquery with the remaining Many relations\n\t// \t\tconst builtTableFrom = this.buildRelationalQueryWithPK({\n\t// \t\t\tfullSchema,\n\t// \t\t\tschema,\n\t// \t\t\ttableNamesMap,\n\t// \t\t\ttable,\n\t// \t\t\ttableConfig,\n\t// \t\t\tqueryConfig: {\n\t// \t\t\t\t...config,\n\t// \t\t\t\twhere: undefined,\n\t// \t\t\t\torderBy: undefined,\n\t// \t\t\t\tlimit: undefined,\n\t// \t\t\t\toffset: undefined,\n\t// \t\t\t\twith: manyRelations.slice(1).reduce<NonNullable<typeof config['with']>>(\n\t// \t\t\t\t\t(result, { tsKey, queryConfig: configValue }) => {\n\t// \t\t\t\t\t\tresult[tsKey] = configValue;\n\t// \t\t\t\t\t\treturn result;\n\t// \t\t\t\t\t},\n\t// \t\t\t\t\t{},\n\t// \t\t\t\t),\n\t// \t\t\t},\n\t// \t\t\ttableAlias,\n\t// \t\t});\n\n\t// \t\tselectedRelations.push({\n\t// \t\t\tdbKey: selectedRelationTsKey,\n\t// \t\t\ttsKey: selectedRelationTsKey,\n\t// \t\t\tfield: builtRelationSelectionField,\n\t// \t\t\trelationTableTsKey: relationTableTsName,\n\t// \t\t\tisJson: true,\n\t// \t\t\tselection: builtRelationJoin.selection,\n\t// \t\t});\n\n\t// \t\t// selection = builtTableFrom.selection.map((item) =>\n\t// \t\t// \tis(item.field, SQL.Aliased)\n\t// \t\t// \t\t? { ...item, field: sql`${sql.identifier(tableAlias)}.${sql.identifier(item.field.fieldAlias)}` }\n\t// \t\t// \t\t: item\n\t// \t\t// );\n\t// \t\t// selectionForBuild = [{\n\t// \t\t// \tdbKey: '*',\n\t// \t\t// \ttsKey: '*',\n\t// \t\t// \tfield: sql`${sql.identifier(tableAlias)}.*`,\n\t// \t\t// \tselection: [],\n\t// \t\t// \tisJson: false,\n\t// \t\t// \trelationTableTsKey: undefined,\n\t// \t\t// }];\n\t// \t\t// const newSelectionItem: (typeof selection)[number] = {\n\t// \t\t// \tdbKey: selectedRelationTsKey,\n\t// \t\t// \ttsKey: selectedRelationTsKey,\n\t// \t\t// \tfield,\n\t// \t\t// \trelationTableTsKey: relationTableTsName,\n\t// \t\t// \tisJson: true,\n\t// \t\t// \tselection: builtRelationJoin.selection,\n\t// \t\t// };\n\t// \t\t// selection.push(newSelectionItem);\n\t// \t\t// selectionForBuild.push(newSelectionItem);\n\n\t// \t\ttableFrom = is(builtTableFrom.sql, PgTable)\n\t// \t\t\t? builtTableFrom.sql\n\t// \t\t\t: new Subquery(builtTableFrom.sql, {}, tableAlias);\n\t// \t}\n\n\t// \tif (selectedColumns.length === 0 && selectedRelations.length === 0 && selectedExtras.length === 0) {\n\t// \t\tthrow new DrizzleError(`No fields selected for table \"${tableConfig.tsName}\" (\"${tableAlias}\")`);\n\t// \t}\n\n\t// \tlet selection: BuildRelationalQueryResult<PgTable, PgColumn>['selection'];\n\n\t// \tfunction prepareSelectedColumns() {\n\t// \t\treturn selectedColumns.map((key) => ({\n\t// \t\t\tdbKey: tableConfig.columns[key]!.name,\n\t// \t\t\ttsKey: key,\n\t// \t\t\tfield: tableConfig.columns[key] as PgColumn,\n\t// \t\t\trelationTableTsKey: undefined,\n\t// \t\t\tisJson: false,\n\t// \t\t\tselection: [],\n\t// \t\t}));\n\t// \t}\n\n\t// \tfunction prepareSelectedExtras() {\n\t// \t\treturn selectedExtras.map((item) => ({\n\t// \t\t\tdbKey: item.value.fieldAlias,\n\t// \t\t\ttsKey: item.tsKey,\n\t// \t\t\tfield: item.value,\n\t// \t\t\trelationTableTsKey: undefined,\n\t// \t\t\tisJson: false,\n\t// \t\t\tselection: [],\n\t// \t\t}));\n\t// \t}\n\n\t// \tif (isRoot) {\n\t// \t\tselection = [\n\t// \t\t\t...prepareSelectedColumns(),\n\t// \t\t\t...prepareSelectedExtras(),\n\t// \t\t];\n\t// \t}\n\n\t// \tif (hasUserDefinedWhere || orderBy.length > 0) {\n\t// \t\ttableFrom = new Subquery(\n\t// \t\t\tthis.buildSelectQuery({\n\t// \t\t\t\ttable: is(tableFrom, PgTable) ? aliasedTable(tableFrom, tableAlias) : tableFrom,\n\t// \t\t\t\tfields: {},\n\t// \t\t\t\tfieldsFlat: selectionForBuild.map(({ field }) => ({\n\t// \t\t\t\t\tpath: [],\n\t// \t\t\t\t\tfield: is(field, Column) ? aliasedTableColumn(field, tableAlias) : field,\n\t// \t\t\t\t})),\n\t// \t\t\t\tjoins,\n\t// \t\t\t\tdistinct,\n\t// \t\t\t}),\n\t// \t\t\t{},\n\t// \t\t\ttableAlias,\n\t// \t\t);\n\t// \t\tselectionForBuild = selection.map((item) =>\n\t// \t\t\tis(item.field, SQL.Aliased)\n\t// \t\t\t\t? { ...item, field: sql`${sql.identifier(tableAlias)}.${sql.identifier(item.field.fieldAlias)}` }\n\t// \t\t\t\t: item\n\t// \t\t);\n\t// \t\tjoins = [];\n\t// \t\tdistinct = undefined;\n\t// \t}\n\n\t// \tconst result = this.buildSelectQuery({\n\t// \t\ttable: is(tableFrom, PgTable) ? aliasedTable(tableFrom, tableAlias) : tableFrom,\n\t// \t\tfields: {},\n\t// \t\tfieldsFlat: selectionForBuild.map(({ field }) => ({\n\t// \t\t\tpath: [],\n\t// \t\t\tfield: is(field, Column) ? aliasedTableColumn(field, tableAlias) : field,\n\t// \t\t})),\n\t// \t\twhere,\n\t// \t\tlimit,\n\t// \t\toffset,\n\t// \t\tjoins,\n\t// \t\torderBy,\n\t// \t\tdistinct,\n\t// \t});\n\n\t// \treturn {\n\t// \t\ttableTsKey: tableConfig.tsName,\n\t// \t\tsql: result,\n\t// \t\tselection,\n\t// \t};\n\t// }\n\n\tbuildRelationalQueryWithoutPK({\n\t\tfullSchema,\n\t\tschema,\n\t\ttableNamesMap,\n\t\ttable,\n\t\ttableConfig,\n\t\tqueryConfig: config,\n\t\ttableAlias,\n\t\tnestedQueryRelation,\n\t\tjoinOn,\n\t}: {\n\t\tfullSchema: Record<string, unknown>;\n\t\tschema: TablesRelationalConfig;\n\t\ttableNamesMap: Record<string, string>;\n\t\ttable: PgTable;\n\t\ttableConfig: TableRelationalConfig;\n\t\tqueryConfig: true | DBQueryConfig<'many', true>;\n\t\ttableAlias: string;\n\t\tnestedQueryRelation?: Relation;\n\t\tjoinOn?: SQL;\n\t}): BuildRelationalQueryResult<PgTable, PgColumn> {\n\t\tlet selection: BuildRelationalQueryResult<PgTable, PgColumn>['selection'] = [];\n\t\tlet limit, offset, orderBy: NonNullable<PgSelectConfig['orderBy']> = [], where;\n\t\tconst joins: PgSelectJoinConfig[] = [];\n\n\t\tif (config === true) {\n\t\t\tconst selectionEntries = Object.entries(tableConfig.columns);\n\t\t\tselection = selectionEntries.map((\n\t\t\t\t[key, value],\n\t\t\t) => ({\n\t\t\t\tdbKey: value.name,\n\t\t\t\ttsKey: key,\n\t\t\t\tfield: aliasedTableColumn(value as PgColumn, tableAlias),\n\t\t\t\trelationTableTsKey: undefined,\n\t\t\t\tisJson: false,\n\t\t\t\tselection: [],\n\t\t\t}));\n\t\t} else {\n\t\t\tconst aliasedColumns = Object.fromEntries(\n\t\t\t\tObject.entries(tableConfig.columns).map(([key, value]) => [key, aliasedTableColumn(value, tableAlias)]),\n\t\t\t);\n\n\t\t\tif (config.where) {\n\t\t\t\tconst whereSql = typeof config.where === 'function'\n\t\t\t\t\t? config.where(aliasedColumns, getOperators())\n\t\t\t\t\t: config.where;\n\t\t\t\twhere = whereSql && mapColumnsInSQLToAlias(whereSql, tableAlias);\n\t\t\t}\n\n\t\t\tconst fieldsSelection: { tsKey: string; value: PgColumn | SQL.Aliased }[] = [];\n\t\t\tlet selectedColumns: string[] = [];\n\n\t\t\t// Figure out which columns to select\n\t\t\tif (config.columns) {\n\t\t\t\tlet isIncludeMode = false;\n\n\t\t\t\tfor (const [field, value] of Object.entries(config.columns)) {\n\t\t\t\t\tif (value === undefined) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (field in tableConfig.columns) {\n\t\t\t\t\t\tif (!isIncludeMode && value === true) {\n\t\t\t\t\t\t\tisIncludeMode = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tselectedColumns.push(field);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (selectedColumns.length > 0) {\n\t\t\t\t\tselectedColumns = isIncludeMode\n\t\t\t\t\t\t? selectedColumns.filter((c) => config.columns?.[c] === true)\n\t\t\t\t\t\t: Object.keys(tableConfig.columns).filter((key) => !selectedColumns.includes(key));\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Select all columns if selection is not specified\n\t\t\t\tselectedColumns = Object.keys(tableConfig.columns);\n\t\t\t}\n\n\t\t\tfor (const field of selectedColumns) {\n\t\t\t\tconst column = tableConfig.columns[field]! as PgColumn;\n\t\t\t\tfieldsSelection.push({ tsKey: field, value: column });\n\t\t\t}\n\n\t\t\tlet selectedRelations: {\n\t\t\t\ttsKey: string;\n\t\t\t\tqueryConfig: true | DBQueryConfig<'many', false>;\n\t\t\t\trelation: Relation;\n\t\t\t}[] = [];\n\n\t\t\t// Figure out which relations to select\n\t\t\tif (config.with) {\n\t\t\t\tselectedRelations = Object.entries(config.with)\n\t\t\t\t\t.filter((entry): entry is [typeof entry[0], NonNullable<typeof entry[1]>] => !!entry[1])\n\t\t\t\t\t.map(([tsKey, queryConfig]) => ({ tsKey, queryConfig, relation: tableConfig.relations[tsKey]! }));\n\t\t\t}\n\n\t\t\tlet extras;\n\n\t\t\t// Figure out which extras to select\n\t\t\tif (config.extras) {\n\t\t\t\textras = typeof config.extras === 'function'\n\t\t\t\t\t? config.extras(aliasedColumns, { sql })\n\t\t\t\t\t: config.extras;\n\t\t\t\tfor (const [tsKey, value] of Object.entries(extras)) {\n\t\t\t\t\tfieldsSelection.push({\n\t\t\t\t\t\ttsKey,\n\t\t\t\t\t\tvalue: mapColumnsInAliasedSQLToAlias(value, tableAlias),\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Transform `fieldsSelection` into `selection`\n\t\t\t// `fieldsSelection` shouldn't be used after this point\n\t\t\tfor (const { tsKey, value } of fieldsSelection) {\n\t\t\t\tselection.push({\n\t\t\t\t\tdbKey: is(value, SQL.Aliased) ? value.fieldAlias : tableConfig.columns[tsKey]!.name,\n\t\t\t\t\ttsKey,\n\t\t\t\t\tfield: is(value, Column) ? aliasedTableColumn(value, tableAlias) : value,\n\t\t\t\t\trelationTableTsKey: undefined,\n\t\t\t\t\tisJson: false,\n\t\t\t\t\tselection: [],\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tlet orderByOrig = typeof config.orderBy === 'function'\n\t\t\t\t? config.orderBy(aliasedColumns, getOrderByOperators())\n\t\t\t\t: config.orderBy ?? [];\n\t\t\tif (!Array.isArray(orderByOrig)) {\n\t\t\t\torderByOrig = [orderByOrig];\n\t\t\t}\n\t\t\torderBy = orderByOrig.map((orderByValue) => {\n\t\t\t\tif (is(orderByValue, Column)) {\n\t\t\t\t\treturn aliasedTableColumn(orderByValue, tableAlias) as PgColumn;\n\t\t\t\t}\n\t\t\t\treturn mapColumnsInSQLToAlias(orderByValue, tableAlias);\n\t\t\t});\n\n\t\t\tlimit = config.limit;\n\t\t\toffset = config.offset;\n\n\t\t\t// Process all relations\n\t\t\tfor (\n\t\t\t\tconst {\n\t\t\t\t\ttsKey: selectedRelationTsKey,\n\t\t\t\t\tqueryConfig: selectedRelationConfigValue,\n\t\t\t\t\trelation,\n\t\t\t\t} of selectedRelations\n\t\t\t) {\n\t\t\t\tconst normalizedRelation = normalizeRelation(schema, tableNamesMap, relation);\n\t\t\t\tconst relationTableName = relation.referencedTable[Table.Symbol.Name];\n\t\t\t\tconst relationTableTsName = tableNamesMap[relationTableName]!;\n\t\t\t\tconst relationTableAlias = `${tableAlias}_${selectedRelationTsKey}`;\n\t\t\t\tconst joinOn = and(\n\t\t\t\t\t...normalizedRelation.fields.map((field, i) =>\n\t\t\t\t\t\teq(\n\t\t\t\t\t\t\taliasedTableColumn(normalizedRelation.references[i]!, relationTableAlias),\n\t\t\t\t\t\t\taliasedTableColumn(field, tableAlias),\n\t\t\t\t\t\t)\n\t\t\t\t\t),\n\t\t\t\t);\n\t\t\t\tconst builtRelation = this.buildRelationalQueryWithoutPK({\n\t\t\t\t\tfullSchema,\n\t\t\t\t\tschema,\n\t\t\t\t\ttableNamesMap,\n\t\t\t\t\ttable: fullSchema[relationTableTsName] as PgTable,\n\t\t\t\t\ttableConfig: schema[relationTableTsName]!,\n\t\t\t\t\tqueryConfig: is(relation, One)\n\t\t\t\t\t\t? (selectedRelationConfigValue === true\n\t\t\t\t\t\t\t? { limit: 1 }\n\t\t\t\t\t\t\t: { ...selectedRelationConfigValue, limit: 1 })\n\t\t\t\t\t\t: selectedRelationConfigValue,\n\t\t\t\t\ttableAlias: relationTableAlias,\n\t\t\t\t\tjoinOn,\n\t\t\t\t\tnestedQueryRelation: relation,\n\t\t\t\t});\n\t\t\t\tconst field = sql`${sql.identifier(relationTableAlias)}.${sql.identifier('data')}`.as(selectedRelationTsKey);\n\t\t\t\tjoins.push({\n\t\t\t\t\ton: sql`true`,\n\t\t\t\t\ttable: new Subquery(builtRelation.sql as SQL, {}, relationTableAlias),\n\t\t\t\t\talias: relationTableAlias,\n\t\t\t\t\tjoinType: 'left',\n\t\t\t\t\tlateral: true,\n\t\t\t\t});\n\t\t\t\tselection.push({\n\t\t\t\t\tdbKey: selectedRelationTsKey,\n\t\t\t\t\ttsKey: selectedRelationTsKey,\n\t\t\t\t\tfield,\n\t\t\t\t\trelationTableTsKey: relationTableTsName,\n\t\t\t\t\tisJson: true,\n\t\t\t\t\tselection: builtRelation.selection,\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\tif (selection.length === 0) {\n\t\t\tthrow new DrizzleError({ message: `No fields selected for table \"${tableConfig.tsName}\" (\"${tableAlias}\")` });\n\t\t}\n\n\t\tlet result;\n\n\t\twhere = and(joinOn, where);\n\n\t\tif (nestedQueryRelation) {\n\t\t\tlet field = sql`json_build_array(${\n\t\t\t\tsql.join(\n\t\t\t\t\tselection.map(({ field, tsKey, isJson }) =>\n\t\t\t\t\t\tisJson\n\t\t\t\t\t\t\t? sql`${sql.identifier(`${tableAlias}_${tsKey}`)}.${sql.identifier('data')}`\n\t\t\t\t\t\t\t: is(field, SQL.Aliased)\n\t\t\t\t\t\t\t? field.sql\n\t\t\t\t\t\t\t: field\n\t\t\t\t\t),\n\t\t\t\t\tsql`, `,\n\t\t\t\t)\n\t\t\t})`;\n\t\t\tif (is(nestedQueryRelation, Many)) {\n\t\t\t\tfield = sql`coalesce(json_agg(${field}${\n\t\t\t\t\torderBy.length > 0 ? sql` order by ${sql.join(orderBy, sql`, `)}` : undefined\n\t\t\t\t}), '[]'::json)`;\n\t\t\t\t// orderBy = [];\n\t\t\t}\n\t\t\tconst nestedSelection = [{\n\t\t\t\tdbKey: 'data',\n\t\t\t\ttsKey: 'data',\n\t\t\t\tfield: field.as('data'),\n\t\t\t\tisJson: true,\n\t\t\t\trelationTableTsKey: tableConfig.tsName,\n\t\t\t\tselection,\n\t\t\t}];\n\n\t\t\tconst needsSubquery = limit !== undefined || offset !== undefined || orderBy.length > 0;\n\n\t\t\tif (needsSubquery) {\n\t\t\t\tresult = this.buildSelectQuery({\n\t\t\t\t\ttable: aliasedTable(table, tableAlias),\n\t\t\t\t\tfields: {},\n\t\t\t\t\tfieldsFlat: [{\n\t\t\t\t\t\tpath: [],\n\t\t\t\t\t\tfield: sql.raw('*'),\n\t\t\t\t\t}],\n\t\t\t\t\twhere,\n\t\t\t\t\tlimit,\n\t\t\t\t\toffset,\n\t\t\t\t\torderBy,\n\t\t\t\t\tsetOperators: [],\n\t\t\t\t});\n\n\t\t\t\twhere = undefined;\n\t\t\t\tlimit = undefined;\n\t\t\t\toffset = undefined;\n\t\t\t\torderBy = [];\n\t\t\t} else {\n\t\t\t\tresult = aliasedTable(table, tableAlias);\n\t\t\t}\n\n\t\t\tresult = this.buildSelectQuery({\n\t\t\t\ttable: is(result, PgTable) ? result : new Subquery(result, {}, tableAlias),\n\t\t\t\tfields: {},\n\t\t\t\tfieldsFlat: nestedSelection.map(({ field }) => ({\n\t\t\t\t\tpath: [],\n\t\t\t\t\tfield: is(field, Column) ? aliasedTableColumn(field, tableAlias) : field,\n\t\t\t\t})),\n\t\t\t\tjoins,\n\t\t\t\twhere,\n\t\t\t\tlimit,\n\t\t\t\toffset,\n\t\t\t\torderBy,\n\t\t\t\tsetOperators: [],\n\t\t\t});\n\t\t} else {\n\t\t\tresult = this.buildSelectQuery({\n\t\t\t\ttable: aliasedTable(table, tableAlias),\n\t\t\t\tfields: {},\n\t\t\t\tfieldsFlat: selection.map(({ field }) => ({\n\t\t\t\t\tpath: [],\n\t\t\t\t\tfield: is(field, Column) ? aliasedTableColumn(field, tableAlias) : field,\n\t\t\t\t})),\n\t\t\t\tjoins,\n\t\t\t\twhere,\n\t\t\t\tlimit,\n\t\t\t\toffset,\n\t\t\t\torderBy,\n\t\t\t\tsetOperators: [],\n\t\t\t});\n\t\t}\n\n\t\treturn {\n\t\t\ttableTsKey: tableConfig.tsName,\n\t\t\tsql: result,\n\t\t\tselection,\n\t\t};\n\t}\n}\n","import { entityKind } from '~/entity.ts';\nimport type { SQL, SQLWrapper } from '~/sql/index.ts';\n\nexport abstract class TypedQueryBuilder<TSelection, TResult = unknown> implements SQLWrapper {\n\tstatic readonly [entityKind]: string = 'TypedQueryBuilder';\n\n\tdeclare _: {\n\t\tselectedFields: TSelection;\n\t\tresult: TResult;\n\t};\n\n\t/** @internal */\n\tgetSelectedFields(): TSelection {\n\t\treturn this._.selectedFields;\n\t}\n\n\tabstract getSQL(): SQL;\n}\n","import { ColumnAliasProxyHandler, TableAliasProxyHandler } from './alias.ts';\nimport { Column } from './column.ts';\nimport { entityKind, is } from './entity.ts';\nimport { SQL, View } from './sql/sql.ts';\nimport { Subquery, SubqueryConfig } from './subquery.ts';\nimport { ViewBaseConfig } from './view-common.ts';\n\nexport class SelectionProxyHandler<T extends Subquery | Record<string, unknown> | View>\n\timplements ProxyHandler<Subquery | Record<string, unknown> | View>\n{\n\tstatic readonly [entityKind]: string = 'SelectionProxyHandler';\n\n\tprivate config: {\n\t\t/**\n\t\t * Table alias for the columns\n\t\t */\n\t\talias?: string;\n\t\t/**\n\t\t * What to do when a field is an instance of `SQL.Aliased` and it's not a selection field (from a subquery)\n\t\t *\n\t\t * `sql` - return the underlying SQL expression\n\t\t *\n\t\t * `alias` - return the field alias\n\t\t */\n\t\tsqlAliasedBehavior: 'sql' | 'alias';\n\t\t/**\n\t\t * What to do when a field is an instance of `SQL` and it doesn't have an alias declared\n\t\t *\n\t\t * `sql` - return the underlying SQL expression\n\t\t *\n\t\t * `error` - return a DrizzleTypeError on type level and throw an error on runtime\n\t\t */\n\t\tsqlBehavior: 'sql' | 'error';\n\n\t\t/**\n\t\t * Whether to replace the original name of the column with the alias\n\t\t * Should be set to `true` for views creation\n\t\t * @default false\n\t\t */\n\t\treplaceOriginalName?: boolean;\n\t};\n\n\tconstructor(config: SelectionProxyHandler<T>['config']) {\n\t\tthis.config = { ...config };\n\t}\n\n\tget(subquery: T, prop: string | symbol): any {\n\t\tif (prop === SubqueryConfig) {\n\t\t\treturn {\n\t\t\t\t...subquery[SubqueryConfig as keyof typeof subquery],\n\t\t\t\tselection: new Proxy(\n\t\t\t\t\t(subquery as Subquery)[SubqueryConfig].selection,\n\t\t\t\t\tthis as ProxyHandler<Record<string, unknown>>,\n\t\t\t\t),\n\t\t\t};\n\t\t}\n\n\t\tif (prop === ViewBaseConfig) {\n\t\t\treturn {\n\t\t\t\t...subquery[ViewBaseConfig as keyof typeof subquery],\n\t\t\t\tselectedFields: new Proxy(\n\t\t\t\t\t(subquery as View)[ViewBaseConfig].selectedFields,\n\t\t\t\t\tthis as ProxyHandler<Record<string, unknown>>,\n\t\t\t\t),\n\t\t\t};\n\t\t}\n\n\t\tif (typeof prop === 'symbol') {\n\t\t\treturn subquery[prop as keyof typeof subquery];\n\t\t}\n\n\t\tconst columns = is(subquery, Subquery)\n\t\t\t? subquery[SubqueryConfig].selection\n\t\t\t: is(subquery, View)\n\t\t\t? subquery[ViewBaseConfig].selectedFields\n\t\t\t: subquery;\n\t\tconst value: unknown = columns[prop as keyof typeof columns];\n\n\t\tif (is(value, SQL.Aliased)) {\n\t\t\t// Never return the underlying SQL expression for a field previously selected in a subquery\n\t\t\tif (this.config.sqlAliasedBehavior === 'sql' && !value.isSelectionField) {\n\t\t\t\treturn value.sql;\n\t\t\t}\n\n\t\t\tconst newValue = value.clone();\n\t\t\tnewValue.isSelectionField = true;\n\t\t\treturn newValue;\n\t\t}\n\n\t\tif (is(value, SQL)) {\n\t\t\tif (this.config.sqlBehavior === 'sql') {\n\t\t\t\treturn value;\n\t\t\t}\n\n\t\t\tthrow new Error(\n\t\t\t\t`You tried to reference \"${prop}\" field from a subquery, which is a raw SQL field, but it doesn't have an alias declared. Please add an alias to the field using \".as('alias')\" method.`,\n\t\t\t);\n\t\t}\n\n\t\tif (is(value, Column)) {\n\t\t\tif (this.config.alias) {\n\t\t\t\treturn new Proxy(\n\t\t\t\t\tvalue,\n\t\t\t\t\tnew ColumnAliasProxyHandler(\n\t\t\t\t\t\tnew Proxy(\n\t\t\t\t\t\t\tvalue.table,\n\t\t\t\t\t\t\tnew TableAliasProxyHandler(this.config.alias, this.config.replaceOriginalName ?? false),\n\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t\t);\n\t\t\t}\n\t\t\treturn value;\n\t\t}\n\n\t\tif (typeof value !== 'object' || value === null) {\n\t\t\treturn value;\n\t\t}\n\n\t\treturn new Proxy(value, new SelectionProxyHandler(this.config));\n\t}\n}\n","import { entityKind, is } from '~/entity.ts';\nimport type { PgColumn } from '~/pg-core/columns/index.ts';\nimport type { PgDialect } from '~/pg-core/dialect.ts';\nimport type { PgSession, PreparedQueryConfig } from '~/pg-core/session.ts';\nimport type { SubqueryWithSelection } from '~/pg-core/subquery.ts';\nimport type { PgTable } from '~/pg-core/table.ts';\nimport { PgViewBase } from '~/pg-core/view-base.ts';\nimport { TypedQueryBuilder } from '~/query-builders/query-builder.ts';\nimport type {\n\tBuildSubquerySelection,\n\tGetSelectTableName,\n\tGetSelectTableSelection,\n\tJoinNullability,\n\tJoinType,\n\tSelectMode,\n\tSelectResult,\n\tSetOperator,\n} from '~/query-builders/select.types.ts';\nimport { QueryPromise } from '~/query-promise.ts';\nimport type { RunnableQuery } from '~/runnable-query.ts';\nimport { SelectionProxyHandler } from '~/selection-proxy.ts';\nimport { SQL, View } from '~/sql/sql.ts';\nimport type { ColumnsSelection, Placeholder, Query, SQLWrapper } from '~/sql/sql.ts';\nimport { Subquery, SubqueryConfig } from '~/subquery.ts';\nimport { Table } from '~/table.ts';\nimport { tracer } from '~/tracing.ts';\nimport { applyMixins, getTableColumns, getTableLikeName, haveSameKeys, type ValueOrArray } from '~/utils.ts';\nimport { orderSelectedFields } from '~/utils.ts';\nimport { ViewBaseConfig } from '~/view-common.ts';\nimport type {\n\tAnyPgSelect,\n\tCreatePgSelectFromBuilderMode,\n\tGetPgSetOperators,\n\tLockConfig,\n\tLockStrength,\n\tPgCreateSetOperatorFn,\n\tPgJoinFn,\n\tPgSelectConfig,\n\tPgSelectDynamic,\n\tPgSelectHKT,\n\tPgSelectHKTBase,\n\tPgSelectPrepare,\n\tPgSelectWithout,\n\tPgSetOperatorExcludedMethods,\n\tPgSetOperatorWithResult,\n\tSelectedFields,\n\tSetOperatorRightSelect,\n} from './select.types.ts';\n\nexport class PgSelectBuilder<\n\tTSelection extends SelectedFields | undefined,\n\tTBuilderMode extends 'db' | 'qb' = 'db',\n> {\n\tstatic readonly [entityKind]: string = 'PgSelectBuilder';\n\n\tprivate fields: TSelection;\n\tprivate session: PgSession | undefined;\n\tprivate dialect: PgDialect;\n\tprivate withList: Subquery[] = [];\n\tprivate distinct: boolean | {\n\t\ton: (PgColumn | SQLWrapper)[];\n\t} | undefined;\n\n\tconstructor(\n\t\tconfig: {\n\t\t\tfields: TSelection;\n\t\t\tsession: PgSession | undefined;\n\t\t\tdialect: PgDialect;\n\t\t\twithList?: Subquery[];\n\t\t\tdistinct?: boolean | {\n\t\t\t\ton: (PgColumn | SQLWrapper)[];\n\t\t\t};\n\t\t},\n\t) {\n\t\tthis.fields = config.fields;\n\t\tthis.session = config.session;\n\t\tthis.dialect = config.dialect;\n\t\tif (config.withList) {\n\t\t\tthis.withList = config.withList;\n\t\t}\n\t\tthis.distinct = config.distinct;\n\t}\n\n\t/**\n\t * Specify the table, subquery, or other target that you're\n\t * building a select query against.\n\t *\n\t * {@link https://www.postgresql.org/docs/current/sql-select.html#SQL-FROM | Postgres from documentation}\n\t */\n\tfrom<TFrom extends PgTable | Subquery | PgViewBase | SQL>(\n\t\tsource: TFrom,\n\t): CreatePgSelectFromBuilderMode<\n\t\tTBuilderMode,\n\t\tGetSelectTableName<TFrom>,\n\t\tTSelection extends undefined ? GetSelectTableSelection<TFrom> : TSelection,\n\t\tTSelection extends undefined ? 'single' : 'partial'\n\t> {\n\t\tconst isPartialSelect = !!this.fields;\n\n\t\tlet fields: SelectedFields;\n\t\tif (this.fields) {\n\t\t\tfields = this.fields;\n\t\t} else if (is(source, Subquery)) {\n\t\t\t// This is required to use the proxy handler to get the correct field values from the subquery\n\t\t\tfields = Object.fromEntries(\n\t\t\t\tObject.keys(source[SubqueryConfig].selection).map((\n\t\t\t\t\tkey,\n\t\t\t\t) => [key, source[key as unknown as keyof typeof source] as unknown as SelectedFields[string]]),\n\t\t\t);\n\t\t} else if (is(source, PgViewBase)) {\n\t\t\tfields = source[ViewBaseConfig].selectedFields as SelectedFields;\n\t\t} else if (is(source, SQL)) {\n\t\t\tfields = {};\n\t\t} else {\n\t\t\tfields = getTableColumns<PgTable>(source);\n\t\t}\n\n\t\treturn new PgSelectBase({\n\t\t\ttable: source,\n\t\t\tfields,\n\t\t\tisPartialSelect,\n\t\t\tsession: this.session,\n\t\t\tdialect: this.dialect,\n\t\t\twithList: this.withList,\n\t\t\tdistinct: this.distinct,\n\t\t}) as any;\n\t}\n}\n\nexport abstract class PgSelectQueryBuilderBase<\n\tTHKT extends PgSelectHKTBase,\n\tTTableName extends string | undefined,\n\tTSelection extends ColumnsSelection,\n\tTSelectMode extends SelectMode,\n\tTNullabilityMap extends Record<string, JoinNullability> = TTableName extends string ? Record<TTableName, 'not-null'>\n\t\t: {},\n\tTDynamic extends boolean = false,\n\tTExcludedMethods extends string = never,\n\tTResult extends any[] = SelectResult<TSelection, TSelectMode, TNullabilityMap>[],\n\tTSelectedFields extends ColumnsSelection = BuildSubquerySelection<TSelection, TNullabilityMap>,\n> extends TypedQueryBuilder<TSelectedFields, TResult> {\n\tstatic readonly [entityKind]: string = 'PgSelectQueryBuilder';\n\n\toverride readonly _: {\n\t\treadonly dialect: 'pg';\n\t\treadonly hkt: THKT;\n\t\treadonly tableName: TTableName;\n\t\treadonly selection: TSelection;\n\t\treadonly selectMode: TSelectMode;\n\t\treadonly nullabilityMap: TNullabilityMap;\n\t\treadonly dynamic: TDynamic;\n\t\treadonly excludedMethods: TExcludedMethods;\n\t\treadonly result: TResult;\n\t\treadonly selectedFields: TSelectedFields;\n\t};\n\n\tprotected config: PgSelectConfig;\n\tprotected joinsNotNullableMap: Record<string, boolean>;\n\tprivate tableName: string | undefined;\n\tprivate isPartialSelect: boolean;\n\tprotected session: PgSession | undefined;\n\tprotected dialect: PgDialect;\n\n\tconstructor(\n\t\t{ table, fields, isPartialSelect, session, dialect, withList, distinct }: {\n\t\t\ttable: PgSelectConfig['table'];\n\t\t\tfields: PgSelectConfig['fields'];\n\t\t\tisPartialSelect: boolean;\n\t\t\tsession: PgSession | undefined;\n\t\t\tdialect: PgDialect;\n\t\t\twithList: Subquery[];\n\t\t\tdistinct: boolean | {\n\t\t\t\ton: (PgColumn | SQLWrapper)[];\n\t\t\t} | undefined;\n\t\t},\n\t) {\n\t\tsuper();\n\t\tthis.config = {\n\t\t\twithList,\n\t\t\ttable,\n\t\t\tfields: { ...fields },\n\t\t\tdistinct,\n\t\t\tsetOperators: [],\n\t\t};\n\t\tthis.isPartialSelect = isPartialSelect;\n\t\tthis.session = session;\n\t\tthis.dialect = dialect;\n\t\tthis._ = {\n\t\t\tselectedFields: fields as TSelectedFields,\n\t\t} as this['_'];\n\t\tthis.tableName = getTableLikeName(table);\n\t\tthis.joinsNotNullableMap = typeof this.tableName === 'string' ? { [this.tableName]: true } : {};\n\t}\n\n\tprivate createJoin<TJoinType extends JoinType>(\n\t\tjoinType: TJoinType,\n\t): PgJoinFn<this, TDynamic, TJoinType> {\n\t\treturn (\n\t\t\ttable: PgTable | Subquery | PgViewBase | SQL,\n\t\t\ton: ((aliases: TSelection) => SQL | undefined) | SQL | undefined,\n\t\t) => {\n\t\t\tconst baseTableName = this.tableName;\n\t\t\tconst tableName = getTableLikeName(table);\n\n\t\t\tif (typeof tableName === 'string' && this.config.joins?.some((join) => join.alias === tableName)) {\n\t\t\t\tthrow new Error(`Alias \"${tableName}\" is already used in this query`);\n\t\t\t}\n\n\t\t\tif (!this.isPartialSelect) {\n\t\t\t\t// If this is the first join and this is not a partial select and we're not selecting from raw SQL, \"move\" the fields from the main table to the nested object\n\t\t\t\tif (Object.keys(this.joinsNotNullableMap).length === 1 && typeof baseTableName === 'string') {\n\t\t\t\t\tthis.config.fields = {\n\t\t\t\t\t\t[baseTableName]: this.config.fields,\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tif (typeof tableName === 'string' && !is(table, SQL)) {\n\t\t\t\t\tconst selection = is(table, Subquery)\n\t\t\t\t\t\t? table[SubqueryConfig].selection\n\t\t\t\t\t\t: is(table, View)\n\t\t\t\t\t\t? table[ViewBaseConfig].selectedFields\n\t\t\t\t\t\t: table[Table.Symbol.Columns];\n\t\t\t\t\tthis.config.fields[tableName] = selection;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (typeof on === 'function') {\n\t\t\t\ton = on(\n\t\t\t\t\tnew Proxy(\n\t\t\t\t\t\tthis.config.fields,\n\t\t\t\t\t\tnew SelectionProxyHandler({ sqlAliasedBehavior: 'sql', sqlBehavior: 'sql' }),\n\t\t\t\t\t) as TSelection,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tif (!this.config.joins) {\n\t\t\t\tthis.config.joins = [];\n\t\t\t}\n\n\t\t\tthis.config.joins.push({ on, table, joinType, alias: tableName });\n\n\t\t\tif (typeof tableName === 'string') {\n\t\t\t\tswitch (joinType) {\n\t\t\t\t\tcase 'left': {\n\t\t\t\t\t\tthis.joinsNotNullableMap[tableName] = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcase 'right': {\n\t\t\t\t\t\tthis.joinsNotNullableMap = Object.fromEntries(\n\t\t\t\t\t\t\tObject.entries(this.joinsNotNullableMap).map(([key]) => [key, false]),\n\t\t\t\t\t\t);\n\t\t\t\t\t\tthis.joinsNotNullableMap[tableName] = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcase 'inner': {\n\t\t\t\t\t\tthis.joinsNotNullableMap[tableName] = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcase 'full': {\n\t\t\t\t\t\tthis.joinsNotNullableMap = Object.fromEntries(\n\t\t\t\t\t\t\tObject.entries(this.joinsNotNullableMap).map(([key]) => [key, false]),\n\t\t\t\t\t\t);\n\t\t\t\t\t\tthis.joinsNotNullableMap[tableName] = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn this as any;\n\t\t};\n\t}\n\n\t/**\n\t * Executes a `left join` operation by adding another table to the current query.\n\t *\n\t * Calling this method associates each row of the table with the corresponding row from the joined table, if a match is found. If no matching row exists, it sets all columns of the joined table to null.\n\t *\n\t * See docs: {@link https://orm.drizzle.team/docs/joins#left-join}\n\t *\n\t * @param table the table to join.\n\t * @param on the `on` clause.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * // Select all users and their pets\n\t * const usersWithPets: { user: User; pets: Pet | null }[] = await db.select()\n\t *   .from(users)\n\t *   .leftJoin(pets, eq(users.id, pets.ownerId))\n\t *\n\t * // Select userId and petId\n\t * const usersIdsAndPetIds: { userId: number; petId: number | null }[] = await db.select({\n\t *   userId: users.id,\n\t *   petId: pets.id,\n\t * })\n\t *   .from(users)\n\t *   .leftJoin(pets, eq(users.id, pets.ownerId))\n\t * ```\n\t */\n\tleftJoin = this.createJoin('left');\n\n\t/**\n\t * Executes a `right join` operation by adding another table to the current query.\n\t *\n\t * Calling this method associates each row of the joined table with the corresponding row from the main table, if a match is found. If no matching row exists, it sets all columns of the main table to null.\n\t *\n\t * See docs: {@link https://orm.drizzle.team/docs/joins#right-join}\n\t *\n\t * @param table the table to join.\n\t * @param on the `on` clause.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * // Select all users and their pets\n\t * const usersWithPets: { user: User | null; pets: Pet }[] = await db.select()\n\t *   .from(users)\n\t *   .rightJoin(pets, eq(users.id, pets.ownerId))\n\t *\n\t * // Select userId and petId\n\t * const usersIdsAndPetIds: { userId: number | null; petId: number }[] = await db.select({\n\t *   userId: users.id,\n\t *   petId: pets.id,\n\t * })\n\t *   .from(users)\n\t *   .rightJoin(pets, eq(users.id, pets.ownerId))\n\t * ```\n\t */\n\trightJoin = this.createJoin('right');\n\n\t/**\n\t * Executes an `inner join` operation, creating a new table by combining rows from two tables that have matching values.\n\t *\n\t * Calling this method retrieves rows that have corresponding entries in both joined tables. Rows without matching entries in either table are excluded, resulting in a table that includes only matching pairs.\n\t *\n\t * See docs: {@link https://orm.drizzle.team/docs/joins#inner-join}\n\t *\n\t * @param table the table to join.\n\t * @param on the `on` clause.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * // Select all users and their pets\n\t * const usersWithPets: { user: User; pets: Pet }[] = await db.select()\n\t *   .from(users)\n\t *   .innerJoin(pets, eq(users.id, pets.ownerId))\n\t *\n\t * // Select userId and petId\n\t * const usersIdsAndPetIds: { userId: number; petId: number }[] = await db.select({\n\t *   userId: users.id,\n\t *   petId: pets.id,\n\t * })\n\t *   .from(users)\n\t *   .innerJoin(pets, eq(users.id, pets.ownerId))\n\t * ```\n\t */\n\tinnerJoin = this.createJoin('inner');\n\n\t/**\n\t * Executes a `full join` operation by combining rows from two tables into a new table.\n\t *\n\t * Calling this method retrieves all rows from both main and joined tables, merging rows with matching values and filling in `null` for non-matching columns.\n\t *\n\t * See docs: {@link https://orm.drizzle.team/docs/joins#full-join}\n\t *\n\t * @param table the table to join.\n\t * @param on the `on` clause.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * // Select all users and their pets\n\t * const usersWithPets: { user: User | null; pets: Pet | null }[] = await db.select()\n\t *   .from(users)\n\t *   .fullJoin(pets, eq(users.id, pets.ownerId))\n\t *\n\t * // Select userId and petId\n\t * const usersIdsAndPetIds: { userId: number | null; petId: number | null }[] = await db.select({\n\t *   userId: users.id,\n\t *   petId: pets.id,\n\t * })\n\t *   .from(users)\n\t *   .fullJoin(pets, eq(users.id, pets.ownerId))\n\t * ```\n\t */\n\tfullJoin = this.createJoin('full');\n\n\tprivate createSetOperator(\n\t\ttype: SetOperator,\n\t\tisAll: boolean,\n\t): <TValue extends PgSetOperatorWithResult<TResult>>(\n\t\trightSelection:\n\t\t\t| ((setOperators: GetPgSetOperators) => SetOperatorRightSelect<TValue, TResult>)\n\t\t\t| SetOperatorRightSelect<TValue, TResult>,\n\t) => PgSelectWithout<\n\t\tthis,\n\t\tTDynamic,\n\t\tPgSetOperatorExcludedMethods,\n\t\ttrue\n\t> {\n\t\treturn (rightSelection) => {\n\t\t\tconst rightSelect = (typeof rightSelection === 'function'\n\t\t\t\t? rightSelection(getPgSetOperators())\n\t\t\t\t: rightSelection) as TypedQueryBuilder<\n\t\t\t\t\tany,\n\t\t\t\t\tTResult\n\t\t\t\t>;\n\n\t\t\tif (!haveSameKeys(this.getSelectedFields(), rightSelect.getSelectedFields())) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t'Set operator error (union / intersect / except): selected fields are not the same or are in a different order',\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tthis.config.setOperators.push({ type, isAll, rightSelect });\n\t\t\treturn this as any;\n\t\t};\n\t}\n\n\t/**\n\t * Adds `union` set operator to the query.\n\t *\n\t * Calling this method will combine the result sets of the `select` statements and remove any duplicate rows that appear across them.\n\t *\n\t * See docs: {@link https://orm.drizzle.team/docs/set-operations#union}\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * // Select all unique names from customers and users tables\n\t * await db.select({ name: users.name })\n\t *   .from(users)\n\t *   .union(\n\t *     db.select({ name: customers.name }).from(customers)\n\t *   );\n\t * // or\n\t * import { union } from 'drizzle-orm/pg-core'\n\t *\n\t * await union(\n\t *   db.select({ name: users.name }).from(users),\n\t *   db.select({ name: customers.name }).from(customers)\n\t * );\n\t * ```\n\t */\n\tunion = this.createSetOperator('union', false);\n\n\t/**\n\t * Adds `union all` set operator to the query.\n\t *\n\t * Calling this method will combine the result-set of the `select` statements and keep all duplicate rows that appear across them.\n\t *\n\t * See docs: {@link https://orm.drizzle.team/docs/set-operations#union-all}\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * // Select all transaction ids from both online and in-store sales\n\t * await db.select({ transaction: onlineSales.transactionId })\n\t *   .from(onlineSales)\n\t *   .unionAll(\n\t *     db.select({ transaction: inStoreSales.transactionId }).from(inStoreSales)\n\t *   );\n\t * // or\n\t * import { unionAll } from 'drizzle-orm/pg-core'\n\t *\n\t * await unionAll(\n\t *   db.select({ transaction: onlineSales.transactionId }).from(onlineSales),\n\t *   db.select({ transaction: inStoreSales.transactionId }).from(inStoreSales)\n\t * );\n\t * ```\n\t */\n\tunionAll = this.createSetOperator('union', true);\n\n\t/**\n\t * Adds `intersect` set operator to the query.\n\t *\n\t * Calling this method will retain only the rows that are present in both result sets and eliminate duplicates.\n\t *\n\t * See docs: {@link https://orm.drizzle.team/docs/set-operations#intersect}\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * // Select course names that are offered in both departments A and B\n\t * await db.select({ courseName: depA.courseName })\n\t *   .from(depA)\n\t *   .intersect(\n\t *     db.select({ courseName: depB.courseName }).from(depB)\n\t *   );\n\t * // or\n\t * import { intersect } from 'drizzle-orm/pg-core'\n\t *\n\t * await intersect(\n\t *   db.select({ courseName: depA.courseName }).from(depA),\n\t *   db.select({ courseName: depB.courseName }).from(depB)\n\t * );\n\t * ```\n\t */\n\tintersect = this.createSetOperator('intersect', false);\n\n\t/**\n\t * Adds `intersect all` set operator to the query.\n\t *\n\t * Calling this method will retain only the rows that are present in both result sets including all duplicates.\n\t *\n\t * See docs: {@link https://orm.drizzle.team/docs/set-operations#intersect-all}\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * // Select all products and quantities that are ordered by both regular and VIP customers\n\t * await db.select({\n\t *   productId: regularCustomerOrders.productId,\n\t *   quantityOrdered: regularCustomerOrders.quantityOrdered\n\t * })\n\t * .from(regularCustomerOrders)\n\t * .intersectAll(\n\t *   db.select({\n\t *     productId: vipCustomerOrders.productId,\n\t *     quantityOrdered: vipCustomerOrders.quantityOrdered\n\t *   })\n\t *   .from(vipCustomerOrders)\n\t * );\n\t * // or\n\t * import { intersectAll } from 'drizzle-orm/pg-core'\n\t *\n\t * await intersectAll(\n\t *   db.select({\n\t *     productId: regularCustomerOrders.productId,\n\t *     quantityOrdered: regularCustomerOrders.quantityOrdered\n\t *   })\n\t *   .from(regularCustomerOrders),\n\t *   db.select({\n\t *     productId: vipCustomerOrders.productId,\n\t *     quantityOrdered: vipCustomerOrders.quantityOrdered\n\t *   })\n\t *   .from(vipCustomerOrders)\n\t * );\n\t * ```\n\t */\n\tintersectAll = this.createSetOperator('intersect', true);\n\n\t/**\n\t * Adds `except` set operator to the query.\n\t *\n\t * Calling this method will retrieve all unique rows from the left query, except for the rows that are present in the result set of the right query.\n\t *\n\t * See docs: {@link https://orm.drizzle.team/docs/set-operations#except}\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * // Select all courses offered in department A but not in department B\n\t * await db.select({ courseName: depA.courseName })\n\t *   .from(depA)\n\t *   .except(\n\t *     db.select({ courseName: depB.courseName }).from(depB)\n\t *   );\n\t * // or\n\t * import { except } from 'drizzle-orm/pg-core'\n\t *\n\t * await except(\n\t *   db.select({ courseName: depA.courseName }).from(depA),\n\t *   db.select({ courseName: depB.courseName }).from(depB)\n\t * );\n\t * ```\n\t */\n\texcept = this.createSetOperator('except', false);\n\n\t/**\n\t * Adds `except all` set operator to the query.\n\t *\n\t * Calling this method will retrieve all rows from the left query, except for the rows that are present in the result set of the right query.\n\t *\n\t * See docs: {@link https://orm.drizzle.team/docs/set-operations#except-all}\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * // Select all products that are ordered by regular customers but not by VIP customers\n\t * await db.select({\n\t *   productId: regularCustomerOrders.productId,\n\t *   quantityOrdered: regularCustomerOrders.quantityOrdered,\n\t * })\n\t * .from(regularCustomerOrders)\n\t * .exceptAll(\n\t *   db.select({\n\t *     productId: vipCustomerOrders.productId,\n\t *     quantityOrdered: vipCustomerOrders.quantityOrdered,\n\t *   })\n\t *   .from(vipCustomerOrders)\n\t * );\n\t * // or\n\t * import { exceptAll } from 'drizzle-orm/pg-core'\n\t *\n\t * await exceptAll(\n\t *   db.select({\n\t *     productId: regularCustomerOrders.productId,\n\t *     quantityOrdered: regularCustomerOrders.quantityOrdered\n\t *   })\n\t *   .from(regularCustomerOrders),\n\t *   db.select({\n\t *     productId: vipCustomerOrders.productId,\n\t *     quantityOrdered: vipCustomerOrders.quantityOrdered\n\t *   })\n\t *   .from(vipCustomerOrders)\n\t * );\n\t * ```\n\t */\n\texceptAll = this.createSetOperator('except', true);\n\n\t/** @internal */\n\taddSetOperators(setOperators: PgSelectConfig['setOperators']): PgSelectWithout<\n\t\tthis,\n\t\tTDynamic,\n\t\tPgSetOperatorExcludedMethods,\n\t\ttrue\n\t> {\n\t\tthis.config.setOperators.push(...setOperators);\n\t\treturn this as any;\n\t}\n\n\t/**\n\t * Adds a `where` clause to the query.\n\t *\n\t * Calling this method will select only those rows that fulfill a specified condition.\n\t *\n\t * See docs: {@link https://orm.drizzle.team/docs/select#filtering}\n\t *\n\t * @param where the `where` clause.\n\t *\n\t * @example\n\t * You can use conditional operators and `sql function` to filter the rows to be selected.\n\t *\n\t * ```ts\n\t * // Select all cars with green color\n\t * await db.select().from(cars).where(eq(cars.color, 'green'));\n\t * // or\n\t * await db.select().from(cars).where(sql`${cars.color} = 'green'`)\n\t * ```\n\t *\n\t * You can logically combine conditional operators with `and()` and `or()` operators:\n\t *\n\t * ```ts\n\t * // Select all BMW cars with a green color\n\t * await db.select().from(cars).where(and(eq(cars.color, 'green'), eq(cars.brand, 'BMW')));\n\t *\n\t * // Select all cars with the green or blue color\n\t * await db.select().from(cars).where(or(eq(cars.color, 'green'), eq(cars.color, 'blue')));\n\t * ```\n\t */\n\twhere(\n\t\twhere: ((aliases: this['_']['selection']) => SQL | undefined) | SQL | undefined,\n\t): PgSelectWithout<this, TDynamic, 'where'> {\n\t\tif (typeof where === 'function') {\n\t\t\twhere = where(\n\t\t\t\tnew Proxy(\n\t\t\t\t\tthis.config.fields,\n\t\t\t\t\tnew SelectionProxyHandler({ sqlAliasedBehavior: 'sql', sqlBehavior: 'sql' }),\n\t\t\t\t) as TSelection,\n\t\t\t);\n\t\t}\n\t\tthis.config.where = where;\n\t\treturn this as any;\n\t}\n\n\t/**\n\t * Adds a `having` clause to the query.\n\t *\n\t * Calling this method will select only those rows that fulfill a specified condition. It is typically used with aggregate functions to filter the aggregated data based on a specified condition.\n\t *\n\t * See docs: {@link https://orm.drizzle.team/docs/select#aggregations}\n\t *\n\t * @param having the `having` clause.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * // Select all brands with more than one car\n\t * await db.select({\n\t * \tbrand: cars.brand,\n\t * \tcount: sql<number>`cast(count(${cars.id}) as int)`,\n\t * })\n\t *   .from(cars)\n\t *   .groupBy(cars.brand)\n\t *   .having(({ count }) => gt(count, 1));\n\t * ```\n\t */\n\thaving(\n\t\thaving: ((aliases: this['_']['selection']) => SQL | undefined) | SQL | undefined,\n\t): PgSelectWithout<this, TDynamic, 'having'> {\n\t\tif (typeof having === 'function') {\n\t\t\thaving = having(\n\t\t\t\tnew Proxy(\n\t\t\t\t\tthis.config.fields,\n\t\t\t\t\tnew SelectionProxyHandler({ sqlAliasedBehavior: 'sql', sqlBehavior: 'sql' }),\n\t\t\t\t) as TSelection,\n\t\t\t);\n\t\t}\n\t\tthis.config.having = having;\n\t\treturn this as any;\n\t}\n\n\t/**\n\t * Adds a `group by` clause to the query.\n\t *\n\t * Calling this method will group rows that have the same values into summary rows, often used for aggregation purposes.\n\t *\n\t * See docs: {@link https://orm.drizzle.team/docs/select#aggregations}\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * // Group and count people by their last names\n\t * await db.select({\n\t *    lastName: people.lastName,\n\t *    count: sql<number>`cast(count(*) as int)`\n\t * })\n\t *   .from(people)\n\t *   .groupBy(people.lastName);\n\t * ```\n\t */\n\tgroupBy(\n\t\tbuilder: (aliases: this['_']['selection']) => ValueOrArray<PgColumn | SQL | SQL.Aliased>,\n\t): PgSelectWithout<this, TDynamic, 'groupBy'>;\n\tgroupBy(...columns: (PgColumn | SQL | SQL.Aliased)[]): PgSelectWithout<this, TDynamic, 'groupBy'>;\n\tgroupBy(\n\t\t...columns:\n\t\t\t| [(aliases: this['_']['selection']) => ValueOrArray<PgColumn | SQL | SQL.Aliased>]\n\t\t\t| (PgColumn | SQL | SQL.Aliased)[]\n\t): PgSelectWithout<this, TDynamic, 'groupBy'> {\n\t\tif (typeof columns[0] === 'function') {\n\t\t\tconst groupBy = columns[0](\n\t\t\t\tnew Proxy(\n\t\t\t\t\tthis.config.fields,\n\t\t\t\t\tnew SelectionProxyHandler({ sqlAliasedBehavior: 'alias', sqlBehavior: 'sql' }),\n\t\t\t\t) as TSelection,\n\t\t\t);\n\t\t\tthis.config.groupBy = Array.isArray(groupBy) ? groupBy : [groupBy];\n\t\t} else {\n\t\t\tthis.config.groupBy = columns as (PgColumn | SQL | SQL.Aliased)[];\n\t\t}\n\t\treturn this as any;\n\t}\n\n\t/**\n\t * Adds an `order by` clause to the query.\n\t *\n\t * Calling this method will sort the result-set in ascending or descending order. By default, the sort order is ascending.\n\t *\n\t * See docs: {@link https://orm.drizzle.team/docs/select#order-by}\n\t *\n\t * @example\n\t *\n\t * ```\n\t * // Select cars ordered by year\n\t * await db.select().from(cars).orderBy(cars.year);\n\t * ```\n\t *\n\t * You can specify whether results are in ascending or descending order with the `asc()` and `desc()` operators.\n\t *\n\t * ```ts\n\t * // Select cars ordered by year in descending order\n\t * await db.select().from(cars).orderBy(desc(cars.year));\n\t *\n\t * // Select cars ordered by year and price\n\t * await db.select().from(cars).orderBy(asc(cars.year), desc(cars.price));\n\t * ```\n\t */\n\torderBy(\n\t\tbuilder: (aliases: this['_']['selection']) => ValueOrArray<PgColumn | SQL | SQL.Aliased>,\n\t): PgSelectWithout<this, TDynamic, 'orderBy'>;\n\torderBy(...columns: (PgColumn | SQL | SQL.Aliased)[]): PgSelectWithout<this, TDynamic, 'orderBy'>;\n\torderBy(\n\t\t...columns:\n\t\t\t| [(aliases: this['_']['selection']) => ValueOrArray<PgColumn | SQL | SQL.Aliased>]\n\t\t\t| (PgColumn | SQL | SQL.Aliased)[]\n\t): PgSelectWithout<this, TDynamic, 'orderBy'> {\n\t\tif (typeof columns[0] === 'function') {\n\t\t\tconst orderBy = columns[0](\n\t\t\t\tnew Proxy(\n\t\t\t\t\tthis.config.fields,\n\t\t\t\t\tnew SelectionProxyHandler({ sqlAliasedBehavior: 'alias', sqlBehavior: 'sql' }),\n\t\t\t\t) as TSelection,\n\t\t\t);\n\n\t\t\tconst orderByArray = Array.isArray(orderBy) ? orderBy : [orderBy];\n\n\t\t\tif (this.config.setOperators.length > 0) {\n\t\t\t\tthis.config.setOperators.at(-1)!.orderBy = orderByArray;\n\t\t\t} else {\n\t\t\t\tthis.config.orderBy = orderByArray;\n\t\t\t}\n\t\t} else {\n\t\t\tconst orderByArray = columns as (PgColumn | SQL | SQL.Aliased)[];\n\n\t\t\tif (this.config.setOperators.length > 0) {\n\t\t\t\tthis.config.setOperators.at(-1)!.orderBy = orderByArray;\n\t\t\t} else {\n\t\t\t\tthis.config.orderBy = orderByArray;\n\t\t\t}\n\t\t}\n\t\treturn this as any;\n\t}\n\n\t/**\n\t * Adds a `limit` clause to the query.\n\t *\n\t * Calling this method will set the maximum number of rows that will be returned by this query.\n\t *\n\t * See docs: {@link https://orm.drizzle.team/docs/select#limit--offset}\n\t *\n\t * @param limit the `limit` clause.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * // Get the first 10 people from this query.\n\t * await db.select().from(people).limit(10);\n\t * ```\n\t */\n\tlimit(limit: number | Placeholder): PgSelectWithout<this, TDynamic, 'limit'> {\n\t\tif (this.config.setOperators.length > 0) {\n\t\t\tthis.config.setOperators.at(-1)!.limit = limit;\n\t\t} else {\n\t\t\tthis.config.limit = limit;\n\t\t}\n\t\treturn this as any;\n\t}\n\n\t/**\n\t * Adds an `offset` clause to the query.\n\t *\n\t * Calling this method will skip a number of rows when returning results from this query.\n\t *\n\t * See docs: {@link https://orm.drizzle.team/docs/select#limit--offset}\n\t *\n\t * @param offset the `offset` clause.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * // Get the 10th-20th people from this query.\n\t * await db.select().from(people).offset(10).limit(10);\n\t * ```\n\t */\n\toffset(offset: number | Placeholder): PgSelectWithout<this, TDynamic, 'offset'> {\n\t\tif (this.config.setOperators.length > 0) {\n\t\t\tthis.config.setOperators.at(-1)!.offset = offset;\n\t\t} else {\n\t\t\tthis.config.offset = offset;\n\t\t}\n\t\treturn this as any;\n\t}\n\n\t/**\n\t * Adds a `for` clause to the query.\n\t *\n\t * Calling this method will specify a lock strength for this query that controls how strictly it acquires exclusive access to the rows being queried.\n\t *\n\t * See docs: {@link https://www.postgresql.org/docs/current/sql-select.html#SQL-FOR-UPDATE-SHARE}\n\t *\n\t * @param strength the lock strength.\n\t * @param config the lock configuration.\n\t */\n\tfor(strength: LockStrength, config: LockConfig = {}): PgSelectWithout<this, TDynamic, 'for'> {\n\t\tthis.config.lockingClause = { strength, config };\n\t\treturn this as any;\n\t}\n\n\t/** @internal */\n\tgetSQL(): SQL {\n\t\treturn this.dialect.buildSelectQuery(this.config);\n\t}\n\n\ttoSQL(): Query {\n\t\tconst { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());\n\t\treturn rest;\n\t}\n\n\tas<TAlias extends string>(\n\t\talias: TAlias,\n\t): SubqueryWithSelection<this['_']['selectedFields'], TAlias> {\n\t\treturn new Proxy(\n\t\t\tnew Subquery(this.getSQL(), this.config.fields, alias),\n\t\t\tnew SelectionProxyHandler({ alias, sqlAliasedBehavior: 'alias', sqlBehavior: 'error' }),\n\t\t) as SubqueryWithSelection<this['_']['selectedFields'], TAlias>;\n\t}\n\n\t/** @internal */\n\toverride getSelectedFields(): this['_']['selectedFields'] {\n\t\treturn new Proxy(\n\t\t\tthis.config.fields,\n\t\t\tnew SelectionProxyHandler({ alias: this.tableName, sqlAliasedBehavior: 'alias', sqlBehavior: 'error' }),\n\t\t) as this['_']['selectedFields'];\n\t}\n\n\t$dynamic(): PgSelectDynamic<this> {\n\t\treturn this;\n\t}\n}\n\nexport interface PgSelectBase<\n\tTTableName extends string | undefined,\n\tTSelection extends ColumnsSelection,\n\tTSelectMode extends SelectMode,\n\tTNullabilityMap extends Record<string, JoinNullability> = TTableName extends string ? Record<TTableName, 'not-null'>\n\t\t: {},\n\tTDynamic extends boolean = false,\n\tTExcludedMethods extends string = never,\n\tTResult extends any[] = SelectResult<TSelection, TSelectMode, TNullabilityMap>[],\n\tTSelectedFields extends ColumnsSelection = BuildSubquerySelection<TSelection, TNullabilityMap>,\n> extends\n\tPgSelectQueryBuilderBase<\n\t\tPgSelectHKT,\n\t\tTTableName,\n\t\tTSelection,\n\t\tTSelectMode,\n\t\tTNullabilityMap,\n\t\tTDynamic,\n\t\tTExcludedMethods,\n\t\tTResult,\n\t\tTSelectedFields\n\t>,\n\tQueryPromise<TResult>,\n\tSQLWrapper\n{}\n\nexport class PgSelectBase<\n\tTTableName extends string | undefined,\n\tTSelection extends ColumnsSelection,\n\tTSelectMode extends SelectMode,\n\tTNullabilityMap extends Record<string, JoinNullability> = TTableName extends string ? Record<TTableName, 'not-null'>\n\t\t: {},\n\tTDynamic extends boolean = false,\n\tTExcludedMethods extends string = never,\n\tTResult = SelectResult<TSelection, TSelectMode, TNullabilityMap>[],\n\tTSelectedFields = BuildSubquerySelection<TSelection, TNullabilityMap>,\n> extends PgSelectQueryBuilderBase<\n\tPgSelectHKT,\n\tTTableName,\n\tTSelection,\n\tTSelectMode,\n\tTNullabilityMap,\n\tTDynamic,\n\tTExcludedMethods,\n\tTResult,\n\tTSelectedFields\n> implements RunnableQuery<TResult, 'pg'>, SQLWrapper {\n\tstatic readonly [entityKind]: string = 'PgSelect';\n\n\t/** @internal */\n\t_prepare(name?: string): PgSelectPrepare<this> {\n\t\tconst { session, config, dialect, joinsNotNullableMap } = this;\n\t\tif (!session) {\n\t\t\tthrow new Error('Cannot execute a query on a query builder. Please use a database instance instead.');\n\t\t}\n\t\treturn tracer.startActiveSpan('drizzle.prepareQuery', () => {\n\t\t\tconst fieldsList = orderSelectedFields<PgColumn>(config.fields);\n\t\t\tconst query = session.prepareQuery<\n\t\t\t\tPreparedQueryConfig & { execute: TResult }\n\t\t\t>(dialect.sqlToQuery(this.getSQL()), fieldsList, name);\n\t\t\tquery.joinsNotNullableMap = joinsNotNullableMap;\n\t\t\treturn query;\n\t\t});\n\t}\n\n\t/**\n\t * Create a prepared statement for this query. This allows\n\t * the database to remember this query for the given session\n\t * and call it by name, rather than specifying the full query.\n\t *\n\t * {@link https://www.postgresql.org/docs/current/sql-prepare.html | Postgres prepare documentation}\n\t */\n\tprepare(name: string): PgSelectPrepare<this> {\n\t\treturn this._prepare(name);\n\t}\n\n\texecute: ReturnType<this['prepare']>['execute'] = (placeholderValues) => {\n\t\treturn tracer.startActiveSpan('drizzle.operation', () => {\n\t\t\treturn this._prepare().execute(placeholderValues);\n\t\t});\n\t};\n}\n\napplyMixins(PgSelectBase, [QueryPromise]);\n\nfunction createSetOperator(type: SetOperator, isAll: boolean): PgCreateSetOperatorFn {\n\treturn (leftSelect, rightSelect, ...restSelects) => {\n\t\tconst setOperators = [rightSelect, ...restSelects].map((select) => ({\n\t\t\ttype,\n\t\t\tisAll,\n\t\t\trightSelect: select as AnyPgSelect,\n\t\t}));\n\n\t\tfor (const setOperator of setOperators) {\n\t\t\tif (!haveSameKeys((leftSelect as any).getSelectedFields(), setOperator.rightSelect.getSelectedFields())) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t'Set operator error (union / intersect / except): selected fields are not the same or are in a different order',\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\treturn (leftSelect as AnyPgSelect).addSetOperators(setOperators) as any;\n\t};\n}\n\nconst getPgSetOperators = () => ({\n\tunion,\n\tunionAll,\n\tintersect,\n\tintersectAll,\n\texcept,\n\texceptAll,\n});\n\n/**\n * Adds `union` set operator to the query.\n *\n * Calling this method will combine the result sets of the `select` statements and remove any duplicate rows that appear across them.\n *\n * See docs: {@link https://orm.drizzle.team/docs/set-operations#union}\n *\n * @example\n *\n * ```ts\n * // Select all unique names from customers and users tables\n * import { union } from 'drizzle-orm/pg-core'\n *\n * await union(\n *   db.select({ name: users.name }).from(users),\n *   db.select({ name: customers.name }).from(customers)\n * );\n * // or\n * await db.select({ name: users.name })\n *   .from(users)\n *   .union(\n *     db.select({ name: customers.name }).from(customers)\n *   );\n * ```\n */\nexport const union = createSetOperator('union', false);\n\n/**\n * Adds `union all` set operator to the query.\n *\n * Calling this method will combine the result-set of the `select` statements and keep all duplicate rows that appear across them.\n *\n * See docs: {@link https://orm.drizzle.team/docs/set-operations#union-all}\n *\n * @example\n *\n * ```ts\n * // Select all transaction ids from both online and in-store sales\n * import { unionAll } from 'drizzle-orm/pg-core'\n *\n * await unionAll(\n *   db.select({ transaction: onlineSales.transactionId }).from(onlineSales),\n *   db.select({ transaction: inStoreSales.transactionId }).from(inStoreSales)\n * );\n * // or\n * await db.select({ transaction: onlineSales.transactionId })\n *   .from(onlineSales)\n *   .unionAll(\n *     db.select({ transaction: inStoreSales.transactionId }).from(inStoreSales)\n *   );\n * ```\n */\nexport const unionAll = createSetOperator('union', true);\n\n/**\n * Adds `intersect` set operator to the query.\n *\n * Calling this method will retain only the rows that are present in both result sets and eliminate duplicates.\n *\n * See docs: {@link https://orm.drizzle.team/docs/set-operations#intersect}\n *\n * @example\n *\n * ```ts\n * // Select course names that are offered in both departments A and B\n * import { intersect } from 'drizzle-orm/pg-core'\n *\n * await intersect(\n *   db.select({ courseName: depA.courseName }).from(depA),\n *   db.select({ courseName: depB.courseName }).from(depB)\n * );\n * // or\n * await db.select({ courseName: depA.courseName })\n *   .from(depA)\n *   .intersect(\n *     db.select({ courseName: depB.courseName }).from(depB)\n *   );\n * ```\n */\nexport const intersect = createSetOperator('intersect', false);\n\n/**\n * Adds `intersect all` set operator to the query.\n *\n * Calling this method will retain only the rows that are present in both result sets including all duplicates.\n *\n * See docs: {@link https://orm.drizzle.team/docs/set-operations#intersect-all}\n *\n * @example\n *\n * ```ts\n * // Select all products and quantities that are ordered by both regular and VIP customers\n * import { intersectAll } from 'drizzle-orm/pg-core'\n *\n * await intersectAll(\n *   db.select({\n *     productId: regularCustomerOrders.productId,\n *     quantityOrdered: regularCustomerOrders.quantityOrdered\n *   })\n *   .from(regularCustomerOrders),\n *   db.select({\n *     productId: vipCustomerOrders.productId,\n *     quantityOrdered: vipCustomerOrders.quantityOrdered\n *   })\n *   .from(vipCustomerOrders)\n * );\n * // or\n * await db.select({\n *   productId: regularCustomerOrders.productId,\n *   quantityOrdered: regularCustomerOrders.quantityOrdered\n * })\n * .from(regularCustomerOrders)\n * .intersectAll(\n *   db.select({\n *     productId: vipCustomerOrders.productId,\n *     quantityOrdered: vipCustomerOrders.quantityOrdered\n *   })\n *   .from(vipCustomerOrders)\n * );\n * ```\n */\nexport const intersectAll = createSetOperator('intersect', true);\n\n/**\n * Adds `except` set operator to the query.\n *\n * Calling this method will retrieve all unique rows from the left query, except for the rows that are present in the result set of the right query.\n *\n * See docs: {@link https://orm.drizzle.team/docs/set-operations#except}\n *\n * @example\n *\n * ```ts\n * // Select all courses offered in department A but not in department B\n * import { except } from 'drizzle-orm/pg-core'\n *\n * await except(\n *   db.select({ courseName: depA.courseName }).from(depA),\n *   db.select({ courseName: depB.courseName }).from(depB)\n * );\n * // or\n * await db.select({ courseName: depA.courseName })\n *   .from(depA)\n *   .except(\n *     db.select({ courseName: depB.courseName }).from(depB)\n *   );\n * ```\n */\nexport const except = createSetOperator('except', false);\n\n/**\n * Adds `except all` set operator to the query.\n *\n * Calling this method will retrieve all rows from the left query, except for the rows that are present in the result set of the right query.\n *\n * See docs: {@link https://orm.drizzle.team/docs/set-operations#except-all}\n *\n * @example\n *\n * ```ts\n * // Select all products that are ordered by regular customers but not by VIP customers\n * import { exceptAll } from 'drizzle-orm/pg-core'\n *\n * await exceptAll(\n *   db.select({\n *     productId: regularCustomerOrders.productId,\n *     quantityOrdered: regularCustomerOrders.quantityOrdered\n *   })\n *   .from(regularCustomerOrders),\n *   db.select({\n *     productId: vipCustomerOrders.productId,\n *     quantityOrdered: vipCustomerOrders.quantityOrdered\n *   })\n *   .from(vipCustomerOrders)\n * );\n * // or\n * await db.select({\n *   productId: regularCustomerOrders.productId,\n *   quantityOrdered: regularCustomerOrders.quantityOrdered,\n * })\n * .from(regularCustomerOrders)\n * .exceptAll(\n *   db.select({\n *     productId: vipCustomerOrders.productId,\n *     quantityOrdered: vipCustomerOrders.quantityOrdered,\n *   })\n *   .from(vipCustomerOrders)\n * );\n * ```\n */\nexport const exceptAll = createSetOperator('except', true);\n","import { entityKind } from '~/entity.ts';\nimport { PgDialect } from '~/pg-core/dialect.ts';\nimport type { TypedQueryBuilder } from '~/query-builders/query-builder.ts';\nimport type { ColumnsSelection, SQLWrapper } from '~/sql/sql.ts';\nimport type { PgColumn } from '../columns/index.ts';\nimport type { WithSubqueryWithSelection } from '../subquery.ts';\nimport { PgSelectBuilder } from './select.ts';\nimport type { SelectedFields } from './select.types.ts';\nimport { WithSubquery } from '~/subquery.ts';\nimport { SelectionProxyHandler } from '~/selection-proxy.ts';\n\nexport class QueryBuilder {\n\tstatic readonly [entityKind]: string = 'PgQueryBuilder';\n\n\tprivate dialect: PgDialect | undefined;\n\n\t$with<TAlias extends string>(alias: TAlias) {\n\t\tconst queryBuilder = this;\n\n\t\treturn {\n\t\t\tas<TSelection extends ColumnsSelection>(\n\t\t\t\tqb: TypedQueryBuilder<TSelection> | ((qb: QueryBuilder) => TypedQueryBuilder<TSelection>),\n\t\t\t): WithSubqueryWithSelection<TSelection, TAlias> {\n\t\t\t\tif (typeof qb === 'function') {\n\t\t\t\t\tqb = qb(queryBuilder);\n\t\t\t\t}\n\n\t\t\t\treturn new Proxy(\n\t\t\t\t\tnew WithSubquery(qb.getSQL(), qb.getSelectedFields() as SelectedFields, alias, true),\n\t\t\t\t\tnew SelectionProxyHandler({ alias, sqlAliasedBehavior: 'alias', sqlBehavior: 'error' }),\n\t\t\t\t) as WithSubqueryWithSelection<TSelection, TAlias>;\n\t\t\t},\n\t\t};\n\t}\n\n\twith(...queries: WithSubquery[]) {\n\t\tconst self = this;\n\n\t\tfunction select(): PgSelectBuilder<undefined, 'qb'>;\n\t\tfunction select<TSelection extends SelectedFields>(fields: TSelection): PgSelectBuilder<TSelection, 'qb'>;\n\t\tfunction select<TSelection extends SelectedFields>(\n\t\t\tfields?: TSelection,\n\t\t): PgSelectBuilder<TSelection | undefined, 'qb'> {\n\t\t\treturn new PgSelectBuilder({\n\t\t\t\tfields: fields ?? undefined,\n\t\t\t\tsession: undefined,\n\t\t\t\tdialect: self.getDialect(),\n\t\t\t\twithList: queries,\n\t\t\t});\n\t\t}\n\n\t\tfunction selectDistinct(): PgSelectBuilder<undefined, 'qb'>;\n\t\tfunction selectDistinct<TSelection extends SelectedFields>(fields: TSelection): PgSelectBuilder<TSelection, 'qb'>;\n\t\tfunction selectDistinct(fields?: SelectedFields): PgSelectBuilder<SelectedFields | undefined, 'qb'> {\n\t\t\treturn new PgSelectBuilder({\n\t\t\t\tfields: fields ?? undefined,\n\t\t\t\tsession: undefined,\n\t\t\t\tdialect: self.getDialect(),\n\t\t\t\tdistinct: true,\n\t\t\t});\n\t\t}\n\n\t\tfunction selectDistinctOn(on: (PgColumn | SQLWrapper)[]): PgSelectBuilder<undefined, 'qb'>;\n\t\tfunction selectDistinctOn<TSelection extends SelectedFields>(\n\t\t\ton: (PgColumn | SQLWrapper)[],\n\t\t\tfields: TSelection,\n\t\t): PgSelectBuilder<TSelection, 'qb'>;\n\t\tfunction selectDistinctOn(\n\t\t\ton: (PgColumn | SQLWrapper)[],\n\t\t\tfields?: SelectedFields,\n\t\t): PgSelectBuilder<SelectedFields | undefined, 'qb'> {\n\t\t\treturn new PgSelectBuilder({\n\t\t\t\tfields: fields ?? undefined,\n\t\t\t\tsession: undefined,\n\t\t\t\tdialect: self.getDialect(),\n\t\t\t\tdistinct: { on },\n\t\t\t});\n\t\t}\n\n\t\treturn { select, selectDistinct, selectDistinctOn };\n\t}\n\n\tselect(): PgSelectBuilder<undefined, 'qb'>;\n\tselect<TSelection extends SelectedFields>(fields: TSelection): PgSelectBuilder<TSelection, 'qb'>;\n\tselect<TSelection extends SelectedFields>(fields?: TSelection): PgSelectBuilder<TSelection | undefined, 'qb'> {\n\t\treturn new PgSelectBuilder({\n\t\t\tfields: fields ?? undefined,\n\t\t\tsession: undefined,\n\t\t\tdialect: this.getDialect(),\n\t\t});\n\t}\n\n\tselectDistinct(): PgSelectBuilder<undefined>;\n\tselectDistinct<TSelection extends SelectedFields>(fields: TSelection): PgSelectBuilder<TSelection>;\n\tselectDistinct(fields?: SelectedFields): PgSelectBuilder<SelectedFields | undefined> {\n\t\treturn new PgSelectBuilder({\n\t\t\tfields: fields ?? undefined,\n\t\t\tsession: undefined,\n\t\t\tdialect: this.getDialect(),\n\t\t\tdistinct: true,\n\t\t});\n\t}\n\n\tselectDistinctOn(on: (PgColumn | SQLWrapper)[]): PgSelectBuilder<undefined>;\n\tselectDistinctOn<TSelection extends SelectedFields>(\n\t\ton: (PgColumn | SQLWrapper)[],\n\t\tfields: TSelection,\n\t): PgSelectBuilder<TSelection>;\n\tselectDistinctOn(\n\t\ton: (PgColumn | SQLWrapper)[],\n\t\tfields?: SelectedFields,\n\t): PgSelectBuilder<SelectedFields | undefined> {\n\t\treturn new PgSelectBuilder({\n\t\t\tfields: fields ?? undefined,\n\t\t\tsession: undefined,\n\t\t\tdialect: this.getDialect(),\n\t\t\tdistinct: { on },\n\t\t});\n\t}\n\n\t// Lazy load dialect to avoid circular dependency\n\tprivate getDialect() {\n\t\tif (!this.dialect) {\n\t\t\tthis.dialect = new PgDialect();\n\t\t}\n\n\t\treturn this.dialect;\n\t}\n}\n","import { entityKind } from '~/entity.ts';\nimport type { PgDialect } from '~/pg-core/dialect.ts';\nimport type {\n\tPgPreparedQuery,\n\tPgSession,\n\tPreparedQueryConfig,\n\tQueryResultHKT,\n\tQueryResultKind,\n} from '~/pg-core/session.ts';\nimport type { PgMaterializedView } from '~/pg-core/view.ts';\nimport { QueryPromise } from '~/query-promise.ts';\nimport type { RunnableQuery } from '~/runnable-query.ts';\nimport type { Query, SQL, SQLWrapper } from '~/sql/sql.ts';\nimport { tracer } from '~/tracing.ts';\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\nexport interface PgRefreshMaterializedView<TQueryResult extends QueryResultHKT>\n\textends\n\t\tQueryPromise<QueryResultKind<TQueryResult, never>>,\n\t\tRunnableQuery<QueryResultKind<TQueryResult, never>, 'pg'>,\n\t\tSQLWrapper\n{\n\treadonly _: {\n\t\treadonly dialect: 'pg';\n\t\treadonly result: QueryResultKind<TQueryResult, never>;\n\t};\n}\n\nexport class PgRefreshMaterializedView<TQueryResult extends QueryResultHKT>\n\textends QueryPromise<QueryResultKind<TQueryResult, never>>\n\timplements RunnableQuery<QueryResultKind<TQueryResult, never>, 'pg'>, SQLWrapper\n{\n\tstatic readonly [entityKind]: string = 'PgRefreshMaterializedView';\n\n\tprivate config: {\n\t\tview: PgMaterializedView;\n\t\tconcurrently?: boolean;\n\t\twithNoData?: boolean;\n\t};\n\n\tconstructor(\n\t\tview: PgMaterializedView,\n\t\tprivate session: PgSession,\n\t\tprivate dialect: PgDialect,\n\t) {\n\t\tsuper();\n\t\tthis.config = { view };\n\t}\n\n\tconcurrently(): this {\n\t\tif (this.config.withNoData !== undefined) {\n\t\t\tthrow new Error('Cannot use concurrently and withNoData together');\n\t\t}\n\t\tthis.config.concurrently = true;\n\t\treturn this;\n\t}\n\n\twithNoData(): this {\n\t\tif (this.config.concurrently !== undefined) {\n\t\t\tthrow new Error('Cannot use concurrently and withNoData together');\n\t\t}\n\t\tthis.config.withNoData = true;\n\t\treturn this;\n\t}\n\n\t/** @internal */\n\tgetSQL(): SQL {\n\t\treturn this.dialect.buildRefreshMaterializedViewQuery(this.config);\n\t}\n\n\ttoSQL(): Query {\n\t\tconst { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());\n\t\treturn rest;\n\t}\n\n\t/** @internal */\n\t_prepare(name?: string): PgPreparedQuery<\n\t\tPreparedQueryConfig & {\n\t\t\texecute: QueryResultKind<TQueryResult, never>;\n\t\t}\n\t> {\n\t\treturn tracer.startActiveSpan('drizzle.prepareQuery', () => {\n\t\t\treturn this.session.prepareQuery(this.dialect.sqlToQuery(this.getSQL()), undefined, name);\n\t\t});\n\t}\n\n\tprepare(name: string): PgPreparedQuery<\n\t\tPreparedQueryConfig & {\n\t\t\texecute: QueryResultKind<TQueryResult, never>;\n\t\t}\n\t> {\n\t\treturn this._prepare(name);\n\t}\n\n\texecute: ReturnType<this['prepare']>['execute'] = (placeholderValues) => {\n\t\treturn tracer.startActiveSpan('drizzle.operation', () => {\n\t\t\treturn this._prepare().execute(placeholderValues);\n\t\t});\n\t};\n}\n","import type { GetColumnData } from '~/column.ts';\nimport { entityKind } from '~/entity.ts';\nimport type { PgDialect } from '~/pg-core/dialect.ts';\nimport type {\n\tPgPreparedQuery,\n\tPgSession,\n\tPreparedQueryConfig,\n\tQueryResultHKT,\n\tQueryResultKind,\n} from '~/pg-core/session.ts';\nimport type { PgTable } from '~/pg-core/table.ts';\nimport type { SelectResultFields } from '~/query-builders/select.types.ts';\nimport { QueryPromise } from '~/query-promise.ts';\nimport type { RunnableQuery } from '~/runnable-query.ts';\nimport type { Query, SQL, SQLWrapper } from '~/sql/sql.ts';\nimport type { Subquery } from '~/subquery.ts';\nimport { Table } from '~/table.ts';\nimport { mapUpdateSet, orderSelectedFields, type UpdateSet } from '~/utils.ts';\nimport type { PgColumn } from '../columns/common.ts';\nimport type { SelectedFields, SelectedFieldsOrdered } from './select.types.ts';\n\nexport interface PgUpdateConfig {\n\twhere?: SQL | undefined;\n\tset: UpdateSet;\n\ttable: PgTable;\n\treturning?: SelectedFieldsOrdered;\n\twithList?: Subquery[];\n}\n\nexport type PgUpdateSetSource<TTable extends PgTable> =\n\t& {\n\t\t[Key in keyof TTable['_']['columns']]?:\n\t\t\t| GetColumnData<TTable['_']['columns'][Key]>\n\t\t\t| SQL;\n\t}\n\t& {};\n\nexport class PgUpdateBuilder<TTable extends PgTable, TQueryResult extends QueryResultHKT> {\n\tstatic readonly [entityKind]: string = 'PgUpdateBuilder';\n\n\tdeclare readonly _: {\n\t\treadonly table: TTable;\n\t};\n\n\tconstructor(\n\t\tprivate table: TTable,\n\t\tprivate session: PgSession,\n\t\tprivate dialect: PgDialect,\n\t\tprivate withList?: Subquery[],\n\t) {}\n\n\tset(values: PgUpdateSetSource<TTable>): PgUpdateBase<TTable, TQueryResult> {\n\t\treturn new PgUpdateBase<TTable, TQueryResult>(\n\t\t\tthis.table,\n\t\t\tmapUpdateSet(this.table, values),\n\t\t\tthis.session,\n\t\t\tthis.dialect,\n\t\t\tthis.withList,\n\t\t);\n\t}\n}\n\nexport type PgUpdateWithout<\n\tT extends AnyPgUpdate,\n\tTDynamic extends boolean,\n\tK extends keyof T & string,\n> = TDynamic extends true ? T : Omit<\n\tPgUpdateBase<\n\t\tT['_']['table'],\n\t\tT['_']['queryResult'],\n\t\tT['_']['returning'],\n\t\tTDynamic,\n\t\tT['_']['excludedMethods'] | K\n\t>,\n\tT['_']['excludedMethods'] | K\n>;\n\nexport type PgUpdateReturningAll<T extends AnyPgUpdate, TDynamic extends boolean> = PgUpdateWithout<\n\tPgUpdateBase<\n\t\tT['_']['table'],\n\t\tT['_']['queryResult'],\n\t\tT['_']['table']['$inferSelect'],\n\t\tTDynamic,\n\t\tT['_']['excludedMethods']\n\t>,\n\tTDynamic,\n\t'returning'\n>;\n\nexport type PgUpdateReturning<\n\tT extends AnyPgUpdate,\n\tTDynamic extends boolean,\n\tTSelectedFields extends SelectedFields,\n> = PgUpdateWithout<\n\tPgUpdateBase<\n\t\tT['_']['table'],\n\t\tT['_']['queryResult'],\n\t\tSelectResultFields<TSelectedFields>,\n\t\tTDynamic,\n\t\tT['_']['excludedMethods']\n\t>,\n\tTDynamic,\n\t'returning'\n>;\n\nexport type PgUpdatePrepare<T extends AnyPgUpdate> = PgPreparedQuery<\n\tPreparedQueryConfig & {\n\t\texecute: T['_']['returning'] extends undefined ? QueryResultKind<T['_']['queryResult'], never>\n\t\t\t: T['_']['returning'][];\n\t}\n>;\n\nexport type PgUpdateDynamic<T extends AnyPgUpdate> = PgUpdate<\n\tT['_']['table'],\n\tT['_']['queryResult'],\n\tT['_']['returning']\n>;\n\nexport type PgUpdate<\n\tTTable extends PgTable = PgTable,\n\tTQueryResult extends QueryResultHKT = QueryResultHKT,\n\tTReturning extends Record<string, unknown> | undefined = Record<string, unknown> | undefined,\n> = PgUpdateBase<TTable, TQueryResult, TReturning, true, never>;\n\ntype AnyPgUpdate = PgUpdateBase<any, any, any, any, any>;\n\nexport interface PgUpdateBase<\n\tTTable extends PgTable,\n\tTQueryResult extends QueryResultHKT,\n\tTReturning extends Record<string, unknown> | undefined = undefined,\n\tTDynamic extends boolean = false,\n\tTExcludedMethods extends string = never,\n> extends\n\tQueryPromise<TReturning extends undefined ? QueryResultKind<TQueryResult, never> : TReturning[]>,\n\tRunnableQuery<TReturning extends undefined ? QueryResultKind<TQueryResult, never> : TReturning[], 'pg'>,\n\tSQLWrapper\n{\n\treadonly _: {\n\t\treadonly dialect: 'pg';\n\t\treadonly table: TTable;\n\t\treadonly queryResult: TQueryResult;\n\t\treadonly returning: TReturning;\n\t\treadonly dynamic: TDynamic;\n\t\treadonly excludedMethods: TExcludedMethods;\n\t\treadonly result: TReturning extends undefined ? QueryResultKind<TQueryResult, never> : TReturning[];\n\t};\n}\n\nexport class PgUpdateBase<\n\tTTable extends PgTable,\n\tTQueryResult extends QueryResultHKT,\n\tTReturning extends Record<string, unknown> | undefined = undefined,\n\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\tTDynamic extends boolean = false,\n\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\tTExcludedMethods extends string = never,\n> extends QueryPromise<TReturning extends undefined ? QueryResultKind<TQueryResult, never> : TReturning[]>\n\timplements\n\t\tRunnableQuery<TReturning extends undefined ? QueryResultKind<TQueryResult, never> : TReturning[], 'pg'>,\n\t\tSQLWrapper\n{\n\tstatic readonly [entityKind]: string = 'PgUpdate';\n\n\tprivate config: PgUpdateConfig;\n\n\tconstructor(\n\t\ttable: TTable,\n\t\tset: UpdateSet,\n\t\tprivate session: PgSession,\n\t\tprivate dialect: PgDialect,\n\t\twithList?: Subquery[],\n\t) {\n\t\tsuper();\n\t\tthis.config = { set, table, withList };\n\t}\n\n\t/**\n\t * Adds a 'where' clause to the query.\n\t *\n\t * Calling this method will update only those rows that fulfill a specified condition.\n\t *\n\t * See docs: {@link https://orm.drizzle.team/docs/update}\n\t *\n\t * @param where the 'where' clause.\n\t *\n\t * @example\n\t * You can use conditional operators and `sql function` to filter the rows to be updated.\n\t *\n\t * ```ts\n\t * // Update all cars with green color\n\t * await db.update(cars).set({ color: 'red' })\n\t *   .where(eq(cars.color, 'green'));\n\t * // or\n\t * await db.update(cars).set({ color: 'red' })\n\t *   .where(sql`${cars.color} = 'green'`)\n\t * ```\n\t *\n\t * You can logically combine conditional operators with `and()` and `or()` operators:\n\t *\n\t * ```ts\n\t * // Update all BMW cars with a green color\n\t * await db.update(cars).set({ color: 'red' })\n\t *   .where(and(eq(cars.color, 'green'), eq(cars.brand, 'BMW')));\n\t *\n\t * // Update all cars with the green or blue color\n\t * await db.update(cars).set({ color: 'red' })\n\t *   .where(or(eq(cars.color, 'green'), eq(cars.color, 'blue')));\n\t * ```\n\t */\n\twhere(where: SQL | undefined): PgUpdateWithout<this, TDynamic, 'where'> {\n\t\tthis.config.where = where;\n\t\treturn this as any;\n\t}\n\n\t/**\n\t * Adds a `returning` clause to the query.\n\t *\n\t * Calling this method will return the specified fields of the updated rows. If no fields are specified, all fields will be returned.\n\t *\n\t * See docs: {@link https://orm.drizzle.team/docs/update#update-with-returning}\n\t *\n\t * @example\n\t * ```ts\n\t * // Update all cars with the green color and return all fields\n\t * const updatedCars: Car[] = await db.update(cars)\n\t *   .set({ color: 'red' })\n\t *   .where(eq(cars.color, 'green'))\n\t *   .returning();\n\t *\n\t * // Update all cars with the green color and return only their id and brand fields\n\t * const updatedCarsIdsAndBrands: { id: number, brand: string }[] = await db.update(cars)\n\t *   .set({ color: 'red' })\n\t *   .where(eq(cars.color, 'green'))\n\t *   .returning({ id: cars.id, brand: cars.brand });\n\t * ```\n\t */\n\treturning(): PgUpdateReturningAll<this, TDynamic>;\n\treturning<TSelectedFields extends SelectedFields>(\n\t\tfields: TSelectedFields,\n\t): PgUpdateReturning<this, TDynamic, TSelectedFields>;\n\treturning(\n\t\tfields: SelectedFields = this.config.table[Table.Symbol.Columns],\n\t): PgUpdateWithout<AnyPgUpdate, TDynamic, 'returning'> {\n\t\tthis.config.returning = orderSelectedFields<PgColumn>(fields);\n\t\treturn this as any;\n\t}\n\n\t/** @internal */\n\tgetSQL(): SQL {\n\t\treturn this.dialect.buildUpdateQuery(this.config);\n\t}\n\n\ttoSQL(): Query {\n\t\tconst { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());\n\t\treturn rest;\n\t}\n\n\t/** @internal */\n\t_prepare(name?: string): PgUpdatePrepare<this> {\n\t\treturn this.session.prepareQuery(this.dialect.sqlToQuery(this.getSQL()), this.config.returning, name);\n\t}\n\n\tprepare(name: string): PgUpdatePrepare<this> {\n\t\treturn this._prepare(name);\n\t}\n\n\toverride execute: ReturnType<this['prepare']>['execute'] = (placeholderValues) => {\n\t\treturn this._prepare().execute(placeholderValues);\n\t};\n\n\t$dynamic(): PgUpdateDynamic<this> {\n\t\treturn this as any;\n\t}\n}\n","import { entityKind } from '~/entity.ts';\nimport { QueryPromise } from '~/query-promise.ts';\nimport {\n\ttype BuildQueryResult,\n\ttype BuildRelationalQueryResult,\n\ttype DBQueryConfig,\n\tmapRelationalRow,\n\ttype TableRelationalConfig,\n\ttype TablesRelationalConfig,\n} from '~/relations.ts';\nimport type { RunnableQuery } from '~/runnable-query.ts';\nimport type { Query, QueryWithTypings, SQL, SQLWrapper } from '~/sql/sql.ts';\nimport { tracer } from '~/tracing.ts';\nimport type { KnownKeysOnly } from '~/utils.ts';\nimport type { PgDialect } from '../dialect.ts';\nimport type { PgPreparedQuery, PgSession, PreparedQueryConfig } from '../session.ts';\nimport type { PgTable } from '../table.ts';\n\nexport class RelationalQueryBuilder<TSchema extends TablesRelationalConfig, TFields extends TableRelationalConfig> {\n\tstatic readonly [entityKind]: string = 'PgRelationalQueryBuilder';\n\n\tconstructor(\n\t\tprivate fullSchema: Record<string, unknown>,\n\t\tprivate schema: TSchema,\n\t\tprivate tableNamesMap: Record<string, string>,\n\t\tprivate table: PgTable,\n\t\tprivate tableConfig: TableRelationalConfig,\n\t\tprivate dialect: PgDialect,\n\t\tprivate session: PgSession,\n\t) {}\n\n\tfindMany<TConfig extends DBQueryConfig<'many', true, TSchema, TFields>>(\n\t\tconfig?: KnownKeysOnly<TConfig, DBQueryConfig<'many', true, TSchema, TFields>>,\n\t): PgRelationalQuery<BuildQueryResult<TSchema, TFields, TConfig>[]> {\n\t\treturn new PgRelationalQuery(\n\t\t\tthis.fullSchema,\n\t\t\tthis.schema,\n\t\t\tthis.tableNamesMap,\n\t\t\tthis.table,\n\t\t\tthis.tableConfig,\n\t\t\tthis.dialect,\n\t\t\tthis.session,\n\t\t\tconfig ? (config as DBQueryConfig<'many', true>) : {},\n\t\t\t'many',\n\t\t);\n\t}\n\n\tfindFirst<TSelection extends Omit<DBQueryConfig<'many', true, TSchema, TFields>, 'limit'>>(\n\t\tconfig?: KnownKeysOnly<TSelection, Omit<DBQueryConfig<'many', true, TSchema, TFields>, 'limit'>>,\n\t): PgRelationalQuery<BuildQueryResult<TSchema, TFields, TSelection> | undefined> {\n\t\treturn new PgRelationalQuery(\n\t\t\tthis.fullSchema,\n\t\t\tthis.schema,\n\t\t\tthis.tableNamesMap,\n\t\t\tthis.table,\n\t\t\tthis.tableConfig,\n\t\t\tthis.dialect,\n\t\t\tthis.session,\n\t\t\tconfig ? { ...(config as DBQueryConfig<'many', true> | undefined), limit: 1 } : { limit: 1 },\n\t\t\t'first',\n\t\t);\n\t}\n}\n\nexport class PgRelationalQuery<TResult> extends QueryPromise<TResult>\n\timplements RunnableQuery<TResult, 'pg'>, SQLWrapper\n{\n\tstatic readonly [entityKind]: string = 'PgRelationalQuery';\n\n\tdeclare readonly _: {\n\t\treadonly dialect: 'pg';\n\t\treadonly result: TResult;\n\t};\n\n\tconstructor(\n\t\tprivate fullSchema: Record<string, unknown>,\n\t\tprivate schema: TablesRelationalConfig,\n\t\tprivate tableNamesMap: Record<string, string>,\n\t\tprivate table: PgTable,\n\t\tprivate tableConfig: TableRelationalConfig,\n\t\tprivate dialect: PgDialect,\n\t\tprivate session: PgSession,\n\t\tprivate config: DBQueryConfig<'many', true> | true,\n\t\tprivate mode: 'many' | 'first',\n\t) {\n\t\tsuper();\n\t}\n\n\t/** @internal */\n\t_prepare(name?: string): PgPreparedQuery<PreparedQueryConfig & { execute: TResult }> {\n\t\treturn tracer.startActiveSpan('drizzle.prepareQuery', () => {\n\t\t\tconst { query, builtQuery } = this._toSQL();\n\n\t\t\treturn this.session.prepareQuery<PreparedQueryConfig & { execute: TResult }>(\n\t\t\t\tbuiltQuery,\n\t\t\t\tundefined,\n\t\t\t\tname,\n\t\t\t\t(rawRows, mapColumnValue) => {\n\t\t\t\t\tconst rows = rawRows.map((row) =>\n\t\t\t\t\t\tmapRelationalRow(this.schema, this.tableConfig, row, query.selection, mapColumnValue)\n\t\t\t\t\t);\n\t\t\t\t\tif (this.mode === 'first') {\n\t\t\t\t\t\treturn rows[0] as TResult;\n\t\t\t\t\t}\n\t\t\t\t\treturn rows as TResult;\n\t\t\t\t},\n\t\t\t);\n\t\t});\n\t}\n\n\tprepare(name: string): PgPreparedQuery<PreparedQueryConfig & { execute: TResult }> {\n\t\treturn this._prepare(name);\n\t}\n\n\tprivate _getQuery() {\n\t\treturn this.dialect.buildRelationalQueryWithoutPK({\n\t\t\tfullSchema: this.fullSchema,\n\t\t\tschema: this.schema,\n\t\t\ttableNamesMap: this.tableNamesMap,\n\t\t\ttable: this.table,\n\t\t\ttableConfig: this.tableConfig,\n\t\t\tqueryConfig: this.config,\n\t\t\ttableAlias: this.tableConfig.tsName,\n\t\t});\n\t}\n\n\t/** @internal */\n\tgetSQL(): SQL {\n\t\treturn this._getQuery().sql as SQL;\n\t}\n\n\tprivate _toSQL(): { query: BuildRelationalQueryResult; builtQuery: QueryWithTypings } {\n\t\tconst query = this._getQuery();\n\n\t\tconst builtQuery = this.dialect.sqlToQuery(query.sql as SQL);\n\n\t\treturn { query, builtQuery };\n\t}\n\n\ttoSQL(): Query {\n\t\treturn this._toSQL().builtQuery;\n\t}\n\n\toverride execute(): Promise<TResult> {\n\t\treturn tracer.startActiveSpan('drizzle.operation', () => {\n\t\t\treturn this._prepare().execute();\n\t\t});\n\t}\n}\n","import { entityKind } from '~/entity.ts';\nimport { QueryPromise } from '~/query-promise.ts';\nimport type { RunnableQuery } from '~/runnable-query.ts';\nimport type { PreparedQuery } from '~/session.ts';\nimport type { Query, SQL, SQLWrapper } from '~/sql/sql.ts';\n\nexport interface PgRaw<TResult>\n\textends QueryPromise<TResult>, RunnableQuery<TResult, 'pg'>, SQLWrapper, PreparedQuery\n{}\n\nexport class PgRaw<TResult> extends QueryPromise<TResult>\n\timplements RunnableQuery<TResult, 'pg'>, SQLWrapper, PreparedQuery\n{\n\tstatic readonly [entityKind]: string = 'PgRaw';\n\n\tdeclare readonly _: {\n\t\treadonly dialect: 'pg';\n\t\treadonly result: TResult;\n\t};\n\n\tconstructor(\n\t\tpublic execute: () => Promise<TResult>,\n\t\tprivate sql: SQL,\n\t\tprivate query: Query,\n\t\tprivate mapBatchResult: (result: unknown) => unknown,\n\t) {\n\t\tsuper();\n\t}\n\n\t/** @internal */\n\tgetSQL() {\n\t\treturn this.sql;\n\t}\n\n\tgetQuery() {\n\t\treturn this.query;\n\t}\n\n\tmapResult(result: unknown, isFromBatch?: boolean) {\n\t\treturn isFromBatch ? this.mapBatchResult(result) : result;\n\t}\n\n\t_prepare(): PreparedQuery {\n\t\treturn this;\n\t}\n}\n","import { entityKind } from '~/entity.ts';\nimport type { PgDialect } from '~/pg-core/dialect.ts';\nimport {\n\tPgDeleteBase,\n\tPgInsertBuilder,\n\tPgSelectBuilder,\n\tPgUpdateBuilder,\n\tQueryBuilder,\n} from '~/pg-core/query-builders/index.ts';\nimport type {\n\tPgSession,\n\tPgTransaction,\n\tPgTransactionConfig,\n\tPreparedQueryConfig,\n\tQueryResultHKT,\n\tQueryResultKind,\n} from '~/pg-core/session.ts';\nimport type { PgTable } from '~/pg-core/table.ts';\nimport type { TypedQueryBuilder } from '~/query-builders/query-builder.ts';\nimport type { ExtractTablesWithRelations, RelationalSchemaConfig, TablesRelationalConfig } from '~/relations.ts';\nimport { SelectionProxyHandler } from '~/selection-proxy.ts';\nimport type { ColumnsSelection, SQLWrapper } from '~/sql/sql.ts';\nimport { WithSubquery } from '~/subquery.ts';\nimport type { DrizzleTypeError } from '~/utils.ts';\nimport type { PgColumn } from './columns/index.ts';\nimport { RelationalQueryBuilder } from './query-builders/query.ts';\nimport { PgRaw } from './query-builders/raw.ts';\nimport { PgRefreshMaterializedView } from './query-builders/refresh-materialized-view.ts';\nimport type { SelectedFields } from './query-builders/select.types.ts';\nimport type { WithSubqueryWithSelection } from './subquery.ts';\nimport type { PgMaterializedView } from './view.ts';\n\nexport class PgDatabase<\n\tTQueryResult extends QueryResultHKT,\n\tTFullSchema extends Record<string, unknown> = Record<string, never>,\n\tTSchema extends TablesRelationalConfig = ExtractTablesWithRelations<TFullSchema>,\n> {\n\tstatic readonly [entityKind]: string = 'PgDatabase';\n\n\tdeclare readonly _: {\n\t\treadonly schema: TSchema | undefined;\n\t\treadonly tableNamesMap: Record<string, string>;\n\t};\n\n\tquery: TFullSchema extends Record<string, never>\n\t\t? DrizzleTypeError<'Seems like the schema generic is missing - did you forget to add it to your DB type?'>\n\t\t: {\n\t\t\t[K in keyof TSchema]: RelationalQueryBuilder<TSchema, TSchema[K]>;\n\t\t};\n\n\tconstructor(\n\t\t/** @internal */\n\t\treadonly dialect: PgDialect,\n\t\t/** @internal */\n\t\treadonly session: PgSession<any, any, any>,\n\t\tschema: RelationalSchemaConfig<TSchema> | undefined,\n\t) {\n\t\tthis._ = schema\n\t\t\t? { schema: schema.schema, tableNamesMap: schema.tableNamesMap }\n\t\t\t: { schema: undefined, tableNamesMap: {} };\n\t\tthis.query = {} as typeof this['query'];\n\t\tif (this._.schema) {\n\t\t\tfor (const [tableName, columns] of Object.entries(this._.schema)) {\n\t\t\t\t(this.query as PgDatabase<TQueryResult, Record<string, any>>['query'])[tableName] = new RelationalQueryBuilder(\n\t\t\t\t\tschema!.fullSchema,\n\t\t\t\t\tthis._.schema,\n\t\t\t\t\tthis._.tableNamesMap,\n\t\t\t\t\tschema!.fullSchema[tableName] as PgTable,\n\t\t\t\t\tcolumns,\n\t\t\t\t\tdialect,\n\t\t\t\t\tsession,\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Creates a subquery that defines a temporary named result set as a CTE.\n\t *\n\t * It is useful for breaking down complex queries into simpler parts and for reusing the result set in subsequent parts of the query.\n\t *\n\t * See docs: {@link https://orm.drizzle.team/docs/select#with-clause}\n\t *\n\t * @param alias The alias for the subquery.\n\t *\n\t * Failure to provide an alias will result in a DrizzleTypeError, preventing the subquery from being referenced in other queries.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * // Create a subquery with alias 'sq' and use it in the select query\n\t * const sq = db.$with('sq').as(db.select().from(users).where(eq(users.id, 42)));\n\t *\n\t * const result = await db.with(sq).select().from(sq);\n\t * ```\n\t *\n\t * To select arbitrary SQL values as fields in a CTE and reference them in other CTEs or in the main query, you need to add aliases to them:\n\t *\n\t * ```ts\n\t * // Select an arbitrary SQL value as a field in a CTE and reference it in the main query\n\t * const sq = db.$with('sq').as(db.select({\n\t *   name: sql<string>`upper(${users.name})`.as('name'),\n\t * })\n\t * .from(users));\n\t *\n\t * const result = await db.with(sq).select({ name: sq.name }).from(sq);\n\t * ```\n\t */\n\t$with<TAlias extends string>(alias: TAlias) {\n\t\treturn {\n\t\t\tas<TSelection extends ColumnsSelection>(\n\t\t\t\tqb: TypedQueryBuilder<TSelection> | ((qb: QueryBuilder) => TypedQueryBuilder<TSelection>),\n\t\t\t): WithSubqueryWithSelection<TSelection, TAlias> {\n\t\t\t\tif (typeof qb === 'function') {\n\t\t\t\t\tqb = qb(new QueryBuilder());\n\t\t\t\t}\n\n\t\t\t\treturn new Proxy(\n\t\t\t\t\tnew WithSubquery(qb.getSQL(), qb.getSelectedFields() as SelectedFields, alias, true),\n\t\t\t\t\tnew SelectionProxyHandler({ alias, sqlAliasedBehavior: 'alias', sqlBehavior: 'error' }),\n\t\t\t\t) as WithSubqueryWithSelection<TSelection, TAlias>;\n\t\t\t},\n\t\t};\n\t}\n\n\t/**\n\t * Incorporates a previously defined CTE (using `$with`) into the main query.\n\t *\n\t * This method allows the main query to reference a temporary named result set.\n\t *\n\t * See docs: {@link https://orm.drizzle.team/docs/select#with-clause}\n\t *\n\t * @param queries The CTEs to incorporate into the main query.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * // Define a subquery 'sq' as a CTE using $with\n\t * const sq = db.$with('sq').as(db.select().from(users).where(eq(users.id, 42)));\n\t *\n\t * // Incorporate the CTE 'sq' into the main query and select from it\n\t * const result = await db.with(sq).select().from(sq);\n\t * ```\n\t */\n\twith(...queries: WithSubquery[]) {\n\t\tconst self = this;\n\n\t\t/**\n\t\t * Creates a select query.\n\t\t *\n\t\t * Calling this method with no arguments will select all columns from the table. Pass a selection object to specify the columns you want to select.\n\t\t *\n\t\t * Use `.from()` method to specify which table to select from.\n\t\t *\n\t\t * See docs: {@link https://orm.drizzle.team/docs/select}\n\t\t *\n\t\t * @param fields The selection object.\n\t\t *\n\t\t * @example\n\t\t *\n\t\t * ```ts\n\t\t * // Select all columns and all rows from the 'cars' table\n\t\t * const allCars: Car[] = await db.select().from(cars);\n\t\t *\n\t\t * // Select specific columns and all rows from the 'cars' table\n\t\t * const carsIdsAndBrands: { id: number; brand: string }[] = await db.select({\n\t\t *   id: cars.id,\n\t\t *   brand: cars.brand\n\t\t * })\n\t\t *   .from(cars);\n\t\t * ```\n\t\t *\n\t\t * Like in SQL, you can use arbitrary expressions as selection fields, not just table columns:\n\t\t *\n\t\t * ```ts\n\t\t * // Select specific columns along with expression and all rows from the 'cars' table\n\t\t * const carsIdsAndLowerNames: { id: number; lowerBrand: string }[] = await db.select({\n\t\t *   id: cars.id,\n\t\t *   lowerBrand: sql<string>`lower(${cars.brand})`,\n\t\t * })\n\t\t *   .from(cars);\n\t\t * ```\n\t\t */\n\t\tfunction select(): PgSelectBuilder<undefined>;\n\t\tfunction select<TSelection extends SelectedFields>(fields: TSelection): PgSelectBuilder<TSelection>;\n\t\tfunction select(fields?: SelectedFields): PgSelectBuilder<SelectedFields | undefined> {\n\t\t\treturn new PgSelectBuilder({\n\t\t\t\tfields: fields ?? undefined,\n\t\t\t\tsession: self.session,\n\t\t\t\tdialect: self.dialect,\n\t\t\t\twithList: queries,\n\t\t\t});\n\t\t}\n\n\t\t/**\n\t\t * Adds `distinct` expression to the select query.\n\t\t *\n\t\t * Calling this method will return only unique values. When multiple columns are selected, it returns rows with unique combinations of values in these columns.\n\t\t *\n\t\t * Use `.from()` method to specify which table to select from.\n\t\t *\n\t\t * See docs: {@link https://orm.drizzle.team/docs/select#distinct}\n\t\t *\n\t\t * @param fields The selection object.\n\t\t *\n\t\t * @example\n\t\t * ```ts\n\t\t * // Select all unique rows from the 'cars' table\n\t\t * await db.selectDistinct()\n\t\t *   .from(cars)\n\t\t *   .orderBy(cars.id, cars.brand, cars.color);\n\t\t *\n\t\t * // Select all unique brands from the 'cars' table\n\t\t * await db.selectDistinct({ brand: cars.brand })\n\t\t *   .from(cars)\n\t\t *   .orderBy(cars.brand);\n\t\t * ```\n\t\t */\n\t\tfunction selectDistinct(): PgSelectBuilder<undefined>;\n\t\tfunction selectDistinct<TSelection extends SelectedFields>(fields: TSelection): PgSelectBuilder<TSelection>;\n\t\tfunction selectDistinct(fields?: SelectedFields): PgSelectBuilder<SelectedFields | undefined> {\n\t\t\treturn new PgSelectBuilder({\n\t\t\t\tfields: fields ?? undefined,\n\t\t\t\tsession: self.session,\n\t\t\t\tdialect: self.dialect,\n\t\t\t\twithList: queries,\n\t\t\t\tdistinct: true,\n\t\t\t});\n\t\t}\n\n\t\t/**\n\t\t * Adds `distinct on` expression to the select query.\n\t\t *\n\t\t * Calling this method will specify how the unique rows are determined.\n\t\t *\n\t\t * Use `.from()` method to specify which table to select from.\n\t\t *\n\t\t * See docs: {@link https://orm.drizzle.team/docs/select#distinct}\n\t\t *\n\t\t * @param on The expression defining uniqueness.\n\t\t * @param fields The selection object.\n\t\t *\n\t\t * @example\n\t\t * ```ts\n\t\t * // Select the first row for each unique brand from the 'cars' table\n\t\t * await db.selectDistinctOn([cars.brand])\n\t\t *   .from(cars)\n\t\t *   .orderBy(cars.brand);\n\t\t *\n\t\t * // Selects the first occurrence of each unique car brand along with its color from the 'cars' table\n\t\t * await db.selectDistinctOn([cars.brand], { brand: cars.brand, color: cars.color })\n\t\t *   .from(cars)\n\t\t *   .orderBy(cars.brand, cars.color);\n\t\t * ```\n\t\t */\n\t\tfunction selectDistinctOn(on: (PgColumn | SQLWrapper)[]): PgSelectBuilder<undefined>;\n\t\tfunction selectDistinctOn<TSelection extends SelectedFields>(\n\t\t\ton: (PgColumn | SQLWrapper)[],\n\t\t\tfields: TSelection,\n\t\t): PgSelectBuilder<TSelection>;\n\t\tfunction selectDistinctOn(\n\t\t\ton: (PgColumn | SQLWrapper)[],\n\t\t\tfields?: SelectedFields,\n\t\t): PgSelectBuilder<SelectedFields | undefined> {\n\t\t\treturn new PgSelectBuilder({\n\t\t\t\tfields: fields ?? undefined,\n\t\t\t\tsession: self.session,\n\t\t\t\tdialect: self.dialect,\n\t\t\t\twithList: queries,\n\t\t\t\tdistinct: { on },\n\t\t\t});\n\t\t}\n\n\t\t/**\n\t\t * Creates an update query.\n\t\t *\n\t\t * Calling this method without `.where()` clause will update all rows in a table. The `.where()` clause specifies which rows should be updated.\n\t\t *\n\t\t * Use `.set()` method to specify which values to update.\n\t\t *\n\t\t * See docs: {@link https://orm.drizzle.team/docs/update}\n\t\t *\n\t\t * @param table The table to update.\n\t\t *\n\t\t * @example\n\t\t *\n\t\t * ```ts\n\t\t * // Update all rows in the 'cars' table\n\t\t * await db.update(cars).set({ color: 'red' });\n\t\t *\n\t\t * // Update rows with filters and conditions\n\t\t * await db.update(cars).set({ color: 'red' }).where(eq(cars.brand, 'BMW'));\n\t\t *\n\t\t * // Update with returning clause\n\t\t * const updatedCar: Car[] = await db.update(cars)\n\t\t *   .set({ color: 'red' })\n\t\t *   .where(eq(cars.id, 1))\n\t\t *   .returning();\n\t\t * ```\n\t\t */\n\t\tfunction update<TTable extends PgTable>(table: TTable): PgUpdateBuilder<TTable, TQueryResult> {\n\t\t\treturn new PgUpdateBuilder(table, self.session, self.dialect, queries);\n\t\t}\n\n\t\t/**\n\t\t * Creates an insert query.\n\t\t *\n\t\t * Calling this method will create new rows in a table. Use `.values()` method to specify which values to insert.\n\t\t *\n\t\t * See docs: {@link https://orm.drizzle.team/docs/insert}\n\t\t *\n\t\t * @param table The table to insert into.\n\t\t *\n\t\t * @example\n\t\t *\n\t\t * ```ts\n\t\t * // Insert one row\n\t\t * await db.insert(cars).values({ brand: 'BMW' });\n\t\t *\n\t\t * // Insert multiple rows\n\t\t * await db.insert(cars).values([{ brand: 'BMW' }, { brand: 'Porsche' }]);\n\t\t *\n\t\t * // Insert with returning clause\n\t\t * const insertedCar: Car[] = await db.insert(cars)\n\t\t *   .values({ brand: 'BMW' })\n\t\t *   .returning();\n\t\t * ```\n\t\t */\n\t\tfunction insert<TTable extends PgTable>(table: TTable): PgInsertBuilder<TTable, TQueryResult> {\n\t\t\treturn new PgInsertBuilder(table, self.session, self.dialect, queries);\n\t\t}\n\n\t\t/**\n\t\t * Creates a delete query.\n\t\t *\n\t\t * Calling this method without `.where()` clause will delete all rows in a table. The `.where()` clause specifies which rows should be deleted.\n\t\t *\n\t\t * See docs: {@link https://orm.drizzle.team/docs/delete}\n\t\t *\n\t\t * @param table The table to delete from.\n\t\t *\n\t\t * @example\n\t\t *\n\t\t * ```ts\n\t\t * // Delete all rows in the 'cars' table\n\t\t * await db.delete(cars);\n\t\t *\n\t\t * // Delete rows with filters and conditions\n\t\t * await db.delete(cars).where(eq(cars.color, 'green'));\n\t\t *\n\t\t * // Delete with returning clause\n\t\t * const deletedCar: Car[] = await db.delete(cars)\n\t\t *   .where(eq(cars.id, 1))\n\t\t *   .returning();\n\t\t * ```\n\t\t */\n\t\tfunction delete_<TTable extends PgTable>(table: TTable): PgDeleteBase<TTable, TQueryResult> {\n\t\t\treturn new PgDeleteBase(table, self.session, self.dialect, queries);\n\t\t}\n\n\t\treturn { select, selectDistinct, selectDistinctOn, update, insert, delete: delete_ };\n\t}\n\n\t/**\n\t * Creates a select query.\n\t *\n\t * Calling this method with no arguments will select all columns from the table. Pass a selection object to specify the columns you want to select.\n\t *\n\t * Use `.from()` method to specify which table to select from.\n\t *\n\t * See docs: {@link https://orm.drizzle.team/docs/select}\n\t *\n\t * @param fields The selection object.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * // Select all columns and all rows from the 'cars' table\n\t * const allCars: Car[] = await db.select().from(cars);\n\t *\n\t * // Select specific columns and all rows from the 'cars' table\n\t * const carsIdsAndBrands: { id: number; brand: string }[] = await db.select({\n\t *   id: cars.id,\n\t *   brand: cars.brand\n\t * })\n\t *   .from(cars);\n\t * ```\n\t *\n\t * Like in SQL, you can use arbitrary expressions as selection fields, not just table columns:\n\t *\n\t * ```ts\n\t * // Select specific columns along with expression and all rows from the 'cars' table\n\t * const carsIdsAndLowerNames: { id: number; lowerBrand: string }[] = await db.select({\n\t *   id: cars.id,\n\t *   lowerBrand: sql<string>`lower(${cars.brand})`,\n\t * })\n\t *   .from(cars);\n\t * ```\n\t */\n\tselect(): PgSelectBuilder<undefined>;\n\tselect<TSelection extends SelectedFields>(fields: TSelection): PgSelectBuilder<TSelection>;\n\tselect(fields?: SelectedFields): PgSelectBuilder<SelectedFields | undefined> {\n\t\treturn new PgSelectBuilder({\n\t\t\tfields: fields ?? undefined,\n\t\t\tsession: this.session,\n\t\t\tdialect: this.dialect,\n\t\t});\n\t}\n\n\t/**\n\t * Adds `distinct` expression to the select query.\n\t *\n\t * Calling this method will return only unique values. When multiple columns are selected, it returns rows with unique combinations of values in these columns.\n\t *\n\t * Use `.from()` method to specify which table to select from.\n\t *\n\t * See docs: {@link https://orm.drizzle.team/docs/select#distinct}\n\t *\n\t * @param fields The selection object.\n\t *\n\t * @example\n\t * ```ts\n\t * // Select all unique rows from the 'cars' table\n\t * await db.selectDistinct()\n\t *   .from(cars)\n\t *   .orderBy(cars.id, cars.brand, cars.color);\n\t *\n\t * // Select all unique brands from the 'cars' table\n\t * await db.selectDistinct({ brand: cars.brand })\n\t *   .from(cars)\n\t *   .orderBy(cars.brand);\n\t * ```\n\t */\n\tselectDistinct(): PgSelectBuilder<undefined>;\n\tselectDistinct<TSelection extends SelectedFields>(fields: TSelection): PgSelectBuilder<TSelection>;\n\tselectDistinct(fields?: SelectedFields): PgSelectBuilder<SelectedFields | undefined> {\n\t\treturn new PgSelectBuilder({\n\t\t\tfields: fields ?? undefined,\n\t\t\tsession: this.session,\n\t\t\tdialect: this.dialect,\n\t\t\tdistinct: true,\n\t\t});\n\t}\n\n\t/**\n\t * Adds `distinct on` expression to the select query.\n\t *\n\t * Calling this method will specify how the unique rows are determined.\n\t *\n\t * Use `.from()` method to specify which table to select from.\n\t *\n\t * See docs: {@link https://orm.drizzle.team/docs/select#distinct}\n\t *\n\t * @param on The expression defining uniqueness.\n\t * @param fields The selection object.\n\t *\n\t * @example\n\t * ```ts\n\t * // Select the first row for each unique brand from the 'cars' table\n\t * await db.selectDistinctOn([cars.brand])\n\t *   .from(cars)\n\t *   .orderBy(cars.brand);\n\t *\n\t * // Selects the first occurrence of each unique car brand along with its color from the 'cars' table\n\t * await db.selectDistinctOn([cars.brand], { brand: cars.brand, color: cars.color })\n\t *   .from(cars)\n\t *   .orderBy(cars.brand, cars.color);\n\t * ```\n\t */\n\tselectDistinctOn(on: (PgColumn | SQLWrapper)[]): PgSelectBuilder<undefined>;\n\tselectDistinctOn<TSelection extends SelectedFields>(\n\t\ton: (PgColumn | SQLWrapper)[],\n\t\tfields: TSelection,\n\t): PgSelectBuilder<TSelection>;\n\tselectDistinctOn(\n\t\ton: (PgColumn | SQLWrapper)[],\n\t\tfields?: SelectedFields,\n\t): PgSelectBuilder<SelectedFields | undefined> {\n\t\treturn new PgSelectBuilder({\n\t\t\tfields: fields ?? undefined,\n\t\t\tsession: this.session,\n\t\t\tdialect: this.dialect,\n\t\t\tdistinct: { on },\n\t\t});\n\t}\n\n\t/**\n\t * Creates an update query.\n\t *\n\t * Calling this method without `.where()` clause will update all rows in a table. The `.where()` clause specifies which rows should be updated.\n\t *\n\t * Use `.set()` method to specify which values to update.\n\t *\n\t * See docs: {@link https://orm.drizzle.team/docs/update}\n\t *\n\t * @param table The table to update.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * // Update all rows in the 'cars' table\n\t * await db.update(cars).set({ color: 'red' });\n\t *\n\t * // Update rows with filters and conditions\n\t * await db.update(cars).set({ color: 'red' }).where(eq(cars.brand, 'BMW'));\n\t *\n\t * // Update with returning clause\n\t * const updatedCar: Car[] = await db.update(cars)\n\t *   .set({ color: 'red' })\n\t *   .where(eq(cars.id, 1))\n\t *   .returning();\n\t * ```\n\t */\n\tupdate<TTable extends PgTable>(table: TTable): PgUpdateBuilder<TTable, TQueryResult> {\n\t\treturn new PgUpdateBuilder(table, this.session, this.dialect);\n\t}\n\n\t/**\n\t * Creates an insert query.\n\t *\n\t * Calling this method will create new rows in a table. Use `.values()` method to specify which values to insert.\n\t *\n\t * See docs: {@link https://orm.drizzle.team/docs/insert}\n\t *\n\t * @param table The table to insert into.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * // Insert one row\n\t * await db.insert(cars).values({ brand: 'BMW' });\n\t *\n\t * // Insert multiple rows\n\t * await db.insert(cars).values([{ brand: 'BMW' }, { brand: 'Porsche' }]);\n\t *\n\t * // Insert with returning clause\n\t * const insertedCar: Car[] = await db.insert(cars)\n\t *   .values({ brand: 'BMW' })\n\t *   .returning();\n\t * ```\n\t */\n\tinsert<TTable extends PgTable>(table: TTable): PgInsertBuilder<TTable, TQueryResult> {\n\t\treturn new PgInsertBuilder(table, this.session, this.dialect);\n\t}\n\n\t/**\n\t * Creates a delete query.\n\t *\n\t * Calling this method without `.where()` clause will delete all rows in a table. The `.where()` clause specifies which rows should be deleted.\n\t *\n\t * See docs: {@link https://orm.drizzle.team/docs/delete}\n\t *\n\t * @param table The table to delete from.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * // Delete all rows in the 'cars' table\n\t * await db.delete(cars);\n\t *\n\t * // Delete rows with filters and conditions\n\t * await db.delete(cars).where(eq(cars.color, 'green'));\n\t *\n\t * // Delete with returning clause\n\t * const deletedCar: Car[] = await db.delete(cars)\n\t *   .where(eq(cars.id, 1))\n\t *   .returning();\n\t * ```\n\t */\n\tdelete<TTable extends PgTable>(table: TTable): PgDeleteBase<TTable, TQueryResult> {\n\t\treturn new PgDeleteBase(table, this.session, this.dialect);\n\t}\n\n\trefreshMaterializedView<TView extends PgMaterializedView>(view: TView): PgRefreshMaterializedView<TQueryResult> {\n\t\treturn new PgRefreshMaterializedView(view, this.session, this.dialect);\n\t}\n\n\texecute<TRow extends Record<string, unknown> = Record<string, unknown>>(\n\t\tquery: SQLWrapper,\n\t): /* PgRaw<QueryResultKind<TQueryResult, TRow>> */ Promise<QueryResultKind<TQueryResult, TRow>> {\n\t\tconst sql = query.getSQL();\n\t\tconst builtQuery = this.dialect.sqlToQuery(sql);\n\t\tconst prepared = this.session.prepareQuery<PreparedQueryConfig & { execute: QueryResultKind<TQueryResult, TRow> }>(\n\t\t\tbuiltQuery,\n\t\t\tundefined,\n\t\t\tundefined,\n\t\t);\n\t\treturn new PgRaw(\n\t\t\t() => prepared.execute(),\n\t\t\tsql,\n\t\t\tbuiltQuery,\n\t\t\t(result) => prepared.mapResult(result, false),\n\t\t);\n\t}\n\n\ttransaction<T>(\n\t\ttransaction: (tx: PgTransaction<TQueryResult, TFullSchema, TSchema>) => Promise<T>,\n\t\tconfig?: PgTransactionConfig,\n\t): Promise<T> {\n\t\treturn this.session.transaction(transaction, config);\n\t}\n}\n\nexport type PgWithReplicas<Q> = Q & { $primary: Q };\n\nexport const withReplicas = <\n\tHKT extends QueryResultHKT,\n\tTFullSchema extends Record<string, unknown>,\n\tTSchema extends TablesRelationalConfig,\n\tQ extends PgDatabase<HKT, TFullSchema, TSchema>,\n>(\n\tprimary: Q,\n\treplicas: [Q, ...Q[]],\n\tgetReplica: (replicas: Q[]) => Q = () => replicas[Math.floor(Math.random() * replicas.length)]!,\n): PgWithReplicas<Q> => {\n\tconst select: Q['select'] = (...args: []) => getReplica(replicas).select(...args);\n\tconst selectDistinct: Q['selectDistinct'] = (...args: []) => getReplica(replicas).selectDistinct(...args);\n\tconst selectDistinctOn: Q['selectDistinctOn'] = (...args: [any]) => getReplica(replicas).selectDistinctOn(...args);\n\tconst $with: Q['with'] = (...args: any) => getReplica(replicas).with(...args);\n\n\tconst update: Q['update'] = (...args: [any]) => primary.update(...args);\n\tconst insert: Q['insert'] = (...args: [any]) => primary.insert(...args);\n\tconst $delete: Q['delete'] = (...args: [any]) => primary.delete(...args);\n\tconst execute: Q['execute'] = (...args: [any]) => primary.execute(...args);\n\tconst transaction: Q['transaction'] = (...args: [any]) => primary.transaction(...args);\n\tconst refreshMaterializedView: Q['refreshMaterializedView'] = (...args: [any]) =>\n\t\tprimary.refreshMaterializedView(...args);\n\n\treturn {\n\t\t...primary,\n\t\tupdate,\n\t\tinsert,\n\t\tdelete: $delete,\n\t\texecute,\n\t\ttransaction,\n\t\trefreshMaterializedView,\n\t\t$primary: primary,\n\t\tselect,\n\t\tselectDistinct,\n\t\tselectDistinctOn,\n\t\twith: $with,\n\t\tget query() {\n\t\t\treturn getReplica(replicas).query;\n\t\t},\n\t};\n};\n","import { entityKind } from '~/entity.ts';\nimport { TransactionRollbackError } from '~/errors.ts';\nimport type { TablesRelationalConfig } from '~/relations.ts';\nimport type { PreparedQuery } from '~/session.ts';\nimport { type Query, type SQL, sql } from '~/sql/index.ts';\nimport { tracer } from '~/tracing.ts';\nimport { PgDatabase } from './db.ts';\nimport type { PgDialect } from './dialect.ts';\nimport type { SelectedFieldsOrdered } from './query-builders/select.types.ts';\n\nexport interface PreparedQueryConfig {\n\texecute: unknown;\n\tall: unknown;\n\tvalues: unknown;\n}\n\nexport abstract class PgPreparedQuery<T extends PreparedQueryConfig> implements PreparedQuery {\n\tconstructor(protected query: Query) {}\n\n\tgetQuery(): Query {\n\t\treturn this.query;\n\t}\n\n\tmapResult(response: unknown, _isFromBatch?: boolean): unknown {\n\t\treturn response;\n\t}\n\n\tstatic readonly [entityKind]: string = 'PgPreparedQuery';\n\n\t/** @internal */\n\tjoinsNotNullableMap?: Record<string, boolean>;\n\n\tabstract execute(placeholderValues?: Record<string, unknown>): Promise<T['execute']>;\n\n\t/** @internal */\n\tabstract all(placeholderValues?: Record<string, unknown>): Promise<T['all']>;\n}\n\nexport interface PgTransactionConfig {\n\tisolationLevel?: 'read uncommitted' | 'read committed' | 'repeatable read' | 'serializable';\n\taccessMode?: 'read only' | 'read write';\n\tdeferrable?: boolean;\n}\n\nexport abstract class PgSession<\n\tTQueryResult extends QueryResultHKT = QueryResultHKT,\n\tTFullSchema extends Record<string, unknown> = Record<string, never>,\n\tTSchema extends TablesRelationalConfig = Record<string, never>,\n> {\n\tstatic readonly [entityKind]: string = 'PgSession';\n\n\tconstructor(protected dialect: PgDialect) {}\n\n\tabstract prepareQuery<T extends PreparedQueryConfig = PreparedQueryConfig>(\n\t\tquery: Query,\n\t\tfields: SelectedFieldsOrdered | undefined,\n\t\tname: string | undefined,\n\t\tcustomResultMapper?: (rows: unknown[][], mapColumnValue?: (value: unknown) => unknown) => T['execute'],\n\t): PgPreparedQuery<T>;\n\n\texecute<T>(query: SQL): Promise<T> {\n\t\treturn tracer.startActiveSpan('drizzle.operation', () => {\n\t\t\tconst prepared = tracer.startActiveSpan('drizzle.prepareQuery', () => {\n\t\t\t\treturn this.prepareQuery<PreparedQueryConfig & { execute: T }>(\n\t\t\t\t\tthis.dialect.sqlToQuery(query),\n\t\t\t\t\tundefined,\n\t\t\t\t\tundefined,\n\t\t\t\t);\n\t\t\t});\n\n\t\t\treturn prepared.execute();\n\t\t});\n\t}\n\n\tall<T = unknown>(query: SQL): Promise<T[]> {\n\t\treturn this.prepareQuery<PreparedQueryConfig & { all: T[] }>(\n\t\t\tthis.dialect.sqlToQuery(query),\n\t\t\tundefined,\n\t\t\tundefined,\n\t\t).all();\n\t}\n\n\tabstract transaction<T>(\n\t\ttransaction: (tx: PgTransaction<TQueryResult, TFullSchema, TSchema>) => Promise<T>,\n\t\tconfig?: PgTransactionConfig,\n\t): Promise<T>;\n}\n\nexport abstract class PgTransaction<\n\tTQueryResult extends QueryResultHKT,\n\tTFullSchema extends Record<string, unknown> = Record<string, never>,\n\tTSchema extends TablesRelationalConfig = Record<string, never>,\n> extends PgDatabase<TQueryResult, TFullSchema, TSchema> {\n\tstatic readonly [entityKind]: string = 'PgTransaction';\n\n\tconstructor(\n\t\tdialect: PgDialect,\n\t\tsession: PgSession<any, any, any>,\n\t\tprotected schema: {\n\t\t\tfullSchema: Record<string, unknown>;\n\t\t\tschema: TSchema;\n\t\t\ttableNamesMap: Record<string, string>;\n\t\t} | undefined,\n\t\tprotected readonly nestedIndex = 0,\n\t) {\n\t\tsuper(dialect, session, schema);\n\t}\n\n\trollback(): never {\n\t\tthrow new TransactionRollbackError();\n\t}\n\n\t/** @internal */\n\tgetTransactionConfigSQL(config: PgTransactionConfig): SQL {\n\t\tconst chunks: string[] = [];\n\t\tif (config.isolationLevel) {\n\t\t\tchunks.push(`isolation level ${config.isolationLevel}`);\n\t\t}\n\t\tif (config.accessMode) {\n\t\t\tchunks.push(config.accessMode);\n\t\t}\n\t\tif (typeof config.deferrable === 'boolean') {\n\t\t\tchunks.push(config.deferrable ? 'deferrable' : 'not deferrable');\n\t\t}\n\t\treturn sql.raw(chunks.join(' '));\n\t}\n\n\tsetTransaction(config: PgTransactionConfig): Promise<void> {\n\t\treturn this.session.execute(sql`set transaction ${this.getTransactionConfigSQL(config)}`);\n\t}\n\n\tabstract override transaction<T>(\n\t\ttransaction: (tx: PgTransaction<TQueryResult, TFullSchema, TSchema>) => Promise<T>,\n\t): Promise<T>;\n}\n\nexport interface QueryResultHKT {\n\treadonly $brand: 'QueryRowHKT';\n\treadonly row: unknown;\n\treadonly type: unknown;\n}\n\nexport type QueryResultKind<TKind extends QueryResultHKT, TRow> = (TKind & {\n\treadonly row: TRow;\n})['type'];\n","import type { Row, RowList, Sql, TransactionSql } from 'postgres';\nimport { entityKind } from '~/entity.ts';\nimport type { Logger } from '~/logger.ts';\nimport { NoopLogger } from '~/logger.ts';\nimport type { PgDialect } from '~/pg-core/dialect.ts';\nimport { PgTransaction } from '~/pg-core/index.ts';\nimport type { SelectedFieldsOrdered } from '~/pg-core/query-builders/select.types.ts';\nimport type { PgTransactionConfig, PreparedQueryConfig, QueryResultHKT } from '~/pg-core/session.ts';\nimport { PgPreparedQuery, PgSession } from '~/pg-core/session.ts';\nimport type { RelationalSchemaConfig, TablesRelationalConfig } from '~/relations.ts';\nimport { fillPlaceholders, type Query } from '~/sql/sql.ts';\nimport { tracer } from '~/tracing.ts';\nimport { type Assume, mapResultRow } from '~/utils.ts';\n\nexport class PostgresJsPreparedQuery<T extends PreparedQueryConfig> extends PgPreparedQuery<T> {\n\tstatic readonly [entityKind]: string = 'PostgresJsPreparedQuery';\n\n\tconstructor(\n\t\tprivate client: Sql,\n\t\tprivate queryString: string,\n\t\tprivate params: unknown[],\n\t\tprivate logger: Logger,\n\t\tprivate fields: SelectedFieldsOrdered | undefined,\n\t\tprivate customResultMapper?: (rows: unknown[][]) => T['execute'],\n\t) {\n\t\tsuper({ sql: queryString, params });\n\t}\n\n\tasync execute(placeholderValues: Record<string, unknown> | undefined = {}): Promise<T['execute']> {\n\t\treturn tracer.startActiveSpan('drizzle.execute', async (span) => {\n\t\t\tconst params = fillPlaceholders(this.params, placeholderValues);\n\n\t\t\tspan?.setAttributes({\n\t\t\t\t'drizzle.query.text': this.queryString,\n\t\t\t\t'drizzle.query.params': JSON.stringify(params),\n\t\t\t});\n\n\t\t\tthis.logger.logQuery(this.queryString, params);\n\n\t\t\tconst { fields, queryString: query, client, joinsNotNullableMap, customResultMapper } = this;\n\t\t\tif (!fields && !customResultMapper) {\n\t\t\t\treturn tracer.startActiveSpan('drizzle.driver.execute', () => {\n\t\t\t\t\treturn client.unsafe(query, params as any[]);\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tconst rows = await tracer.startActiveSpan('drizzle.driver.execute', () => {\n\t\t\t\tspan?.setAttributes({\n\t\t\t\t\t'drizzle.query.text': query,\n\t\t\t\t\t'drizzle.query.params': JSON.stringify(params),\n\t\t\t\t});\n\n\t\t\t\treturn client.unsafe(query, params as any[]).values();\n\t\t\t});\n\n\t\t\treturn tracer.startActiveSpan('drizzle.mapResponse', () => {\n\t\t\t\treturn customResultMapper\n\t\t\t\t\t? customResultMapper(rows)\n\t\t\t\t\t: rows.map((row) => mapResultRow<T['execute']>(fields!, row, joinsNotNullableMap));\n\t\t\t});\n\t\t});\n\t}\n\n\tall(placeholderValues: Record<string, unknown> | undefined = {}): Promise<T['all']> {\n\t\treturn tracer.startActiveSpan('drizzle.execute', async (span) => {\n\t\t\tconst params = fillPlaceholders(this.params, placeholderValues);\n\t\t\tspan?.setAttributes({\n\t\t\t\t'drizzle.query.text': this.queryString,\n\t\t\t\t'drizzle.query.params': JSON.stringify(params),\n\t\t\t});\n\t\t\tthis.logger.logQuery(this.queryString, params);\n\t\t\treturn tracer.startActiveSpan('drizzle.driver.execute', () => {\n\t\t\t\tspan?.setAttributes({\n\t\t\t\t\t'drizzle.query.text': this.queryString,\n\t\t\t\t\t'drizzle.query.params': JSON.stringify(params),\n\t\t\t\t});\n\t\t\t\treturn this.client.unsafe(this.queryString, params as any[]);\n\t\t\t});\n\t\t});\n\t}\n}\n\nexport interface PostgresJsSessionOptions {\n\tlogger?: Logger;\n}\n\nexport class PostgresJsSession<\n\tTSQL extends Sql,\n\tTFullSchema extends Record<string, unknown>,\n\tTSchema extends TablesRelationalConfig,\n> extends PgSession<PostgresJsQueryResultHKT, TFullSchema, TSchema> {\n\tstatic readonly [entityKind]: string = 'PostgresJsSession';\n\n\tlogger: Logger;\n\n\tconstructor(\n\t\tpublic client: TSQL,\n\t\tdialect: PgDialect,\n\t\tprivate schema: RelationalSchemaConfig<TSchema> | undefined,\n\t\t/** @internal */\n\t\treadonly options: PostgresJsSessionOptions = {},\n\t) {\n\t\tsuper(dialect);\n\t\tthis.logger = options.logger ?? new NoopLogger();\n\t}\n\n\tprepareQuery<T extends PreparedQueryConfig = PreparedQueryConfig>(\n\t\tquery: Query,\n\t\tfields: SelectedFieldsOrdered | undefined,\n\t\tname: string | undefined,\n\t\tcustomResultMapper?: (rows: unknown[][]) => T['execute'],\n\t): PgPreparedQuery<T> {\n\t\treturn new PostgresJsPreparedQuery(this.client, query.sql, query.params, this.logger, fields, customResultMapper);\n\t}\n\n\tquery(query: string, params: unknown[]): Promise<RowList<Row[]>> {\n\t\tthis.logger.logQuery(query, params);\n\t\treturn this.client.unsafe(query, params as any[]).values();\n\t}\n\n\tqueryObjects<T extends Row>(\n\t\tquery: string,\n\t\tparams: unknown[],\n\t): Promise<RowList<T[]>> {\n\t\treturn this.client.unsafe(query, params as any[]);\n\t}\n\n\toverride transaction<T>(\n\t\ttransaction: (tx: PostgresJsTransaction<TFullSchema, TSchema>) => Promise<T>,\n\t\tconfig?: PgTransactionConfig,\n\t): Promise<T> {\n\t\treturn this.client.begin(async (client) => {\n\t\t\tconst session = new PostgresJsSession<TransactionSql, TFullSchema, TSchema>(\n\t\t\t\tclient,\n\t\t\t\tthis.dialect,\n\t\t\t\tthis.schema,\n\t\t\t\tthis.options,\n\t\t\t);\n\t\t\tconst tx = new PostgresJsTransaction(this.dialect, session, this.schema);\n\t\t\tif (config) {\n\t\t\t\tawait tx.setTransaction(config);\n\t\t\t}\n\t\t\treturn transaction(tx);\n\t\t}) as Promise<T>;\n\t}\n}\n\nexport class PostgresJsTransaction<\n\tTFullSchema extends Record<string, unknown>,\n\tTSchema extends TablesRelationalConfig,\n> extends PgTransaction<PostgresJsQueryResultHKT, TFullSchema, TSchema> {\n\tstatic readonly [entityKind]: string = 'PostgresJsTransaction';\n\n\tconstructor(\n\t\tdialect: PgDialect,\n\t\t/** @internal */\n\t\toverride readonly session: PostgresJsSession<TransactionSql, TFullSchema, TSchema>,\n\t\tschema: RelationalSchemaConfig<TSchema> | undefined,\n\t\tnestedIndex = 0,\n\t) {\n\t\tsuper(dialect, session, schema, nestedIndex);\n\t}\n\n\toverride transaction<T>(\n\t\ttransaction: (tx: PostgresJsTransaction<TFullSchema, TSchema>) => Promise<T>,\n\t): Promise<T> {\n\t\treturn this.session.client.savepoint((client) => {\n\t\t\tconst session = new PostgresJsSession(client, this.dialect, this.schema, this.session.options);\n\t\t\tconst tx = new PostgresJsTransaction(this.dialect, session, this.schema);\n\t\t\treturn transaction(tx);\n\t\t}) as Promise<T>;\n\t}\n}\n\nexport interface PostgresJsQueryResultHKT extends QueryResultHKT {\n\ttype: RowList<Assume<this['row'], Row>[]>;\n}\n","import type { Sql } from 'postgres';\nimport { DefaultLogger } from '~/logger.ts';\nimport { PgDatabase } from '~/pg-core/db.ts';\nimport { PgDialect } from '~/pg-core/dialect.ts';\nimport {\n\tcreateTableRelationsHelpers,\n\textractTablesRelationalConfig,\n\ttype RelationalSchemaConfig,\n\ttype TablesRelationalConfig,\n} from '~/relations.ts';\nimport type { DrizzleConfig } from '~/utils.ts';\nimport type { PostgresJsQueryResultHKT } from './session.ts';\nimport { PostgresJsSession } from './session.ts';\n\nexport type PostgresJsDatabase<\n\tTSchema extends Record<string, unknown> = Record<string, never>,\n> = PgDatabase<PostgresJsQueryResultHKT, TSchema>;\n\nexport function drizzle<TSchema extends Record<string, unknown> = Record<string, never>>(\n\tclient: Sql,\n\tconfig: DrizzleConfig<TSchema> = {},\n): PostgresJsDatabase<TSchema> {\n\tconst dialect = new PgDialect();\n\tlet logger;\n\tif (config.logger === true) {\n\t\tlogger = new DefaultLogger();\n\t} else if (config.logger !== false) {\n\t\tlogger = config.logger;\n\t}\n\n\tlet schema: RelationalSchemaConfig<TablesRelationalConfig> | undefined;\n\tif (config.schema) {\n\t\tconst tablesConfig = extractTablesRelationalConfig(\n\t\t\tconfig.schema,\n\t\t\tcreateTableRelationsHelpers,\n\t\t);\n\t\tschema = {\n\t\t\tfullSchema: config.schema,\n\t\t\tschema: tablesConfig.tables,\n\t\t\ttableNamesMap: tablesConfig.tableNamesMap,\n\t\t};\n\t}\n\n\tconst session = new PostgresJsSession(client, dialect, schema, { logger });\n\treturn new PgDatabase(dialect, session, schema) as PostgresJsDatabase<TSchema>;\n}\n","import { drizzle } from 'drizzle-orm/postgres-js';\r\nimport postgres from 'postgres';\r\nimport * as schema from './schema';\r\n\r\nconst connectionString = process.env.DATABASE_URL || 'postgres://postgres:postgres@localhost:5432/dietkem';\r\n\r\n// for query purposes\r\nexport const queryClient = postgres(connectionString);\r\nexport const db = drizzle(queryClient, { schema });\r\n\r\nexport * from './schema'; ","import { pgTable, serial, varchar, timestamp, integer, decimal, text, pgEnum, boolean } from 'drizzle-orm/pg-core';\n\n// Enums\nexport const userRoleEnum = pgEnum('user_role', [\n  'subscriber_basic',\n  'subscriber_pro',\n  'clinic_admin',\n  'dietitian_team_member',\n  'admin',\n  'superadmin',\n]);\n\nexport const mealTypeEnum = pgEnum('meal_type', ['breakfast', 'lunch', 'dinner', 'snack']);\n\n// Users table\nexport const users = pgTable('users', {\n  id: serial('id').primaryKey(),\n  clerk_id: varchar('clerk_id', { length: 255 }).unique(),\n  email: varchar('email', { length: 255 }).notNull().unique(),\n  password: varchar('password', { length: 255 }),\n  role: userRoleEnum('role').notNull().default('subscriber_basic'),\n  created_at: timestamp('created_at').defaultNow().notNull(),\n  updated_at: timestamp('updated_at').defaultNow().notNull(),\n  first_name: varchar('first_name', { length: 255 }),\n  last_name: varchar('last_name', { length: 255 }),\n  username: varchar('username', { length: 255 }),\n  avatar_url: varchar('avatar_url', { length: 512 }).default('https://res.cloudinary.com/dietkem/image/upload/v1/avatar.jpg'),\n  trial_started_at: timestamp('trial_started_at'),\n  trial_used: text('trial_used').default('false'),\n  first_subscription_started_at: timestamp('first_subscription_started_at'),\n});\n\n// Email verification codes table\nexport const emailVerificationCodes = pgTable('email_verification_codes', {\n  id: serial('id').primaryKey(),\n  email: varchar('email', { length: 255 }).notNull(),\n  code: varchar('code', { length: 6 }).notNull(),\n  expires_at: timestamp('expires_at').notNull(),\n  used: text('used').default('false'),\n  created_at: timestamp('created_at').defaultNow().notNull(),\n});\n\n// NextAuth session tables\nexport const sessions = pgTable('sessions', {\n  id: varchar('id', { length: 255 }).primaryKey(),\n  sessionToken: varchar('session_token', { length: 255 }).notNull().unique(),\n  userId: varchar('user_id', { length: 255 }).notNull(),\n  expires: timestamp('expires').notNull(),\n});\n\nexport const accounts = pgTable('accounts', {\n  id: varchar('id', { length: 255 }).primaryKey(),\n  userId: varchar('user_id', { length: 255 }).notNull(),\n  type: varchar('type', { length: 255 }).notNull(),\n  provider: varchar('provider', { length: 255 }).notNull(),\n  providerAccountId: varchar('provider_account_id', { length: 255 }).notNull(),\n  refresh_token: text('refresh_token'),\n  access_token: text('access_token'),\n  expires_at: serial('expires_at'),\n  token_type: varchar('token_type', { length: 255 }),\n  scope: varchar('scope', { length: 255 }),\n  id_token: text('id_token'),\n  session_state: varchar('session_state', { length: 255 }),\n});\n\nexport const verificationTokens = pgTable('verification_tokens', {\n  identifier: varchar('identifier', { length: 255 }).notNull(),\n  token: varchar('token', { length: 255 }).notNull(),\n  expires: timestamp('expires').notNull(),\n});\n\n// Clients table\nexport const clients = pgTable('clients', {\n  id: serial('id').primaryKey(),\n  name: varchar('name', { length: 255 }).notNull(),\n  gender: varchar('gender', { length: 50 }),\n  birth_date: timestamp('birth_date'),\n  height_cm: decimal('height_cm', { precision: 5, scale: 2 }),\n  email: varchar('email', { length: 255 }),\n  phone: varchar('phone', { length: 20 }),\n  notes: text('notes'),\n  diseases: text('diseases'),\n  allergies: text('allergies'),\n  medications: text('medications'),\n  has_active_plan: boolean('has_active_plan').default(false),\n  status: varchar('status', { length: 10 }).notNull().default('active'),\n  created_at: timestamp('created_at').defaultNow().notNull(),\n  activity_level: varchar('activity_level', { length: 32 }),\n});\n\n// Measurements table\nexport const measurements = pgTable('measurements', {\n  id: serial('id').primaryKey(),\n  client_id: integer('client_id').references(() => clients.id).notNull(),\n  measured_at: text('measured_at'),\n  weight_kg: decimal('weight_kg', { precision: 5, scale: 2 }).notNull(),\n  waist_cm: decimal('waist_cm', { precision: 5, scale: 2 }),\n  hip_cm: decimal('hip_cm', { precision: 5, scale: 2 }),\n  neck_cm: decimal('neck_cm', { precision: 5, scale: 2 }),\n  chest_cm: decimal('chest_cm', { precision: 5, scale: 2 }),\n  arm_cm: decimal('arm_cm', { precision: 5, scale: 2 }),\n  thigh_cm: decimal('thigh_cm', { precision: 5, scale: 2 }),\n  body_fat_percent: decimal('body_fat_percent', { precision: 4, scale: 2 }),\n  note: text('note'),\n  created_at: timestamp('created_at').defaultNow(),\n});\n\n// Meal plans table\nexport const meal_plans = pgTable('meal_plans', {\n  id: serial('id').primaryKey(),\n  client_id: integer('client_id').references(() => clients.id).notNull(),\n  start_date: timestamp('start_date').notNull(),\n  end_date: timestamp('end_date').notNull(),\n  total_calories: integer('total_calories').notNull(),\n  notes: text('notes'),\n  created_by: integer('created_by').references(() => users.id).notNull(),\n});\n\n// Meal plan days table\nexport const meal_plan_days = pgTable('meal_plan_days', {\n  id: serial('id').primaryKey(),\n  meal_plan_id: integer('meal_plan_id').references(() => meal_plans.id).notNull(),\n  date: timestamp('date').notNull(),\n  notes: text('notes'),\n});\n\n// Meals table\nexport const meals = pgTable('meals', {\n  id: serial('id').primaryKey(),\n  meal_plan_day_id: integer('meal_plan_day_id').references(() => meal_plan_days.id).notNull(),\n  meal_type: mealTypeEnum('meal_type').notNull(),\n  name: varchar('name', { length: 255 }).notNull(),\n  calories: integer('calories').notNull(),\n  protein_g: decimal('protein_g', { precision: 5, scale: 2 }).notNull(),\n  carbs_g: decimal('carbs_g', { precision: 5, scale: 2 }).notNull(),\n  fat_g: decimal('fat_g', { precision: 5, scale: 2 }).notNull(),\n  description: text('description'),\n});\n\n// Foods table\nexport const foods = pgTable('foods', {\n  id: serial('id').primaryKey(),\n  name: varchar('name', { length: 255 }).notNull(),\n  description: text('description'),\n  calories_per_100g: integer('calories_per_100g').notNull(),\n  protein_per_100g: decimal('protein_per_100g', { precision: 5, scale: 2 }).notNull(),\n  carbs_per_100g: decimal('carbs_per_100g', { precision: 5, scale: 2 }).notNull(),\n  fat_per_100g: decimal('fat_per_100g', { precision: 5, scale: 2 }).notNull(),\n  locale: varchar('locale', { length: 10 }).notNull().default('en'),\n});\n\n// Water logs table\nexport const water_logs = pgTable('water_logs', {\n  id: serial('id').primaryKey(),\n  client_id: integer('client_id').references(() => clients.id).notNull(),\n  date: timestamp('date').notNull(),\n  value_liters: decimal('value_liters', { precision: 4, scale: 2 }).notNull(),\n});\n\n// Weight logs table\nexport const weight_logs = pgTable('weight_logs', {\n  id: serial('id').primaryKey(),\n  client_id: integer('client_id').references(() => clients.id).notNull(),\n  date: timestamp('date').notNull(),\n  weight_kg: decimal('weight_kg', { precision: 5, scale: 2 }).notNull(),\n}); "],"mappings":"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","names":["_a","_a","_a","_b","otel","rawTracer","_a","_a","_b","sql","_a","_a","param","sql","placeholder","name","SQL","_a","_a","_b","name","result","_a","_b","_a","_b","_a","_a","_b","_a","_a","_b","_c","_d","name","_a","_a","value","startFrom","_a","_b","ref","actions","_a","_b","_a","_b","_a","_b","_a","_b","_a","_b","_a","_b","_a","_b","_a","_b","_a","_b","_a","_b","_a","_b","_a","_b","_a","_b","_a","_b","_a","_a","_b","relations","_a","_b","_a","table","sql","joinOn","field","_a","_a","_a","_b","_a","_a","_b","_a","_b","_a","_b","_a","_b","sql","_a","sql","_a","_b","_a","_b"]}